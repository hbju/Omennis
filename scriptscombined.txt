### arena_manager.gd ###
# ArenaManager.gd
extends Node # Or Control/Node2D depending on your root

@onready var combat_scene: CombatMap = $combat_scene
@onready var skill_ui: SkillUI = $skill_ui
@onready var progression_screen: Control = $arena_progression_screen
@onready var class_selection_screen: Control = $arena_class_selection
@onready var game_over_screen: Control = $game_over_screen

var current_wave: int = 0
var player_character: PartyMember = null # The single character for the arena
var is_in_combat: bool = false
var is_in_progression: bool = false # To manage UI state

func _ready():
	# Hide elements initially
	combat_scene.visible = false
	combat_scene.toggle_ui(false) # Ensure combat UI is off
	skill_ui.visible = false
	skill_ui.skills_confirmed.connect(_on_progression_continue_pressed)

	class_selection_screen.class_selected.connect(_on_arena_class_chosen)

	progression_screen.view_skills_pressed.connect(_on_view_skills_pressed)
	progression_screen.next_wave_pressed.connect(_on_progression_continue_pressed)

	game_over_screen.retry_arena_pressed.connect(_on_retry_arena)
	game_over_screen.main_menu_pressed.connect(_on_return_to_main_menu)
	
	# Connect combat end signal
	combat_scene.combat_ended.connect(_on_combat_ended)

	# Start the arena when ready
	call_deferred("show_class_selection") # Use call_deferred ensure everything is ready

func show_class_selection():
	combat_scene.visible = false
	combat_scene.toggle_ui(false)
	skill_ui.visible = false
	progression_screen.hide()

	class_selection_screen.prompt_class_selection()

func _prepare_next_wave():
	is_in_combat = false
	is_in_progression = false
	current_wave += 1
	print("--- Preparing Wave %d ---" % current_wave)

	# 1. Hide Progression/Skill UI (if they were visible)
	skill_ui.visible = false
	progression_screen.hide() # Add later

	# 2. Generate Enemies for the wave
	var enemies_for_wave: Array[Character] = _generate_enemies(current_wave)
	if enemies_for_wave.is_empty():
		printerr("Failed to generate enemies for wave ", current_wave)
		_game_over() # Or handle differently
		return

	# 3. Configure Combat Map (Layout, Obstacles - Placeholder for now)
	_configure_combat_map()

	# 4. Start Combat
	print("Starting combat for Wave ", current_wave)
	AudioManager.play_music(AudioManager.BATTLE_MUSIC, true) # Play battle music
	is_in_combat = true
	combat_scene.visible = true
	combat_scene.toggle_ui(true) # Turn combat UI on
	combat_scene.enter_combat([player_character], enemies_for_wave) # NEW function needed in CombatMap

func _generate_enemies(wave_num: int) -> Array[Character]:
	print("Generating enemies for wave ", wave_num)
	var enemies: Array[Character] = []
	# --- Enemy Generation Logic ---
	# Simple V1: Increase count and level slightly each wave
	var enemy_count = 1 + floori(wave_num / 3.0)
	var enemy_level = 1 + floori(wave_num / 3.0)

	print("Wave %d: %d enemies, Level %d" % [wave_num, enemy_count, enemy_level])

	var class_keys = EnemyData.ENEMY_CLASS_DEFINITIONS.keys()

	for i in range(enemy_count):
		var chosen_class_key = class_keys[randi() % class_keys.size()]
		var class_data = EnemyData.ENEMY_CLASS_DEFINITIONS[chosen_class_key]

		var enemy_actual_level = max(1, enemy_level + randi_range(-1, 1)) # +/- 1 level variance

		var max_hp = class_data.base_hp + (enemy_actual_level - 1) * class_data.hp_per_level
		var damage_stat = class_data.base_damage_stat + (enemy_actual_level - 1) * class_data.damage_stat_per_level

		var portrait_idx = class_data.portraits[randi() % class_data.portraits.size()]
		var enemy_name = chosen_class_key + " Mk." + str(enemy_actual_level) # Simple name

		var new_char_def = Character.new(
			enemy_name,
			class_data.class_enum, 
			portrait_idx,
			enemy_actual_level,
			max_hp,
			damage_stat,
		)

		for skill_entry in class_data.skill_pool_config:
			if enemy_actual_level >= skill_entry.min_level:
				new_char_def.skill_list.append(skill_entry.skill.new())

		enemies.append(new_char_def) # Add the Character definition

	return enemies


func _configure_combat_map():
	# Placeholder: Later, load different layouts or place obstacles
	print("Configuring combat map layout (Placeholder)")
	# combat_scene.load_layout(current_wave % 3) # Example

func _on_arena_class_chosen(selected_class_enum: Character.CLASSES):
	print("ArenaManager: Class chosen - ", Character.CLASSES.keys()[selected_class_enum])
	current_wave = 0 # Reset wave count for a new run

	var sex = PartyMember.SEX.Male if randi() % 2 == 0 else PartyMember.SEX.Female
	var portrait_idx = randi() % (PartyMember.NB_MALE_PORTRAIT if sex == PartyMember.SEX.Male else PartyMember.NB_FEMALE_PORTRAIT)

	player_character = PartyMember.new(
		"Arena Champion",
		selected_class_enum,
		portrait_idx, # Example random portrait
		1,            # Start at level 1
		sex           # Example random sex
	)

	print("Player Character Created: ", player_character.character_name, " as ", player_character.get_char_class())

	# Proceed to the first wave
	_prepare_next_wave() # This will show combat scene, etc.


func _on_combat_ended(victory: bool):
	if not is_in_combat: return # Prevent double calls

	AudioManager.play_music(AudioManager.VICTORY_STINGER if victory else AudioManager.DEFEAT_STINGER)

	print("Combat Ended! Victory: ", victory)
	is_in_combat = false
	# combat_scene.visible = false
	combat_scene.character_tooltip_instance.hide() # Hide character tooltip
	combat_scene.toggle_ui(false) # Turn combat UI off

	if victory:
		# Go to Progression Phase
		_show_progression_screen()
	else :
		# Game Over
		_game_over()

func _show_progression_screen():
	is_in_progression = true
	print("Showing Progression Screen for Wave ", current_wave)

	# 1. Calculate XP
	# Simple V1: Fixed XP per wave + bonus
	var xp_reward = 500 + current_wave **2 * 50
	xp_reward = roundi(xp_reward * randf_range(0.9, 1.1))
	print("XP Reward: ", xp_reward)

	# 2. Get state BEFORE applying XP
	var char_before = player_character.duplicate() # Use the copy method!

	# 3. Apply XP (Directly modify the character instance for arena)
	player_character.receive_experience(xp_reward)

	# 4. Show Progression UI (Implement this scene in next phase)
	progression_screen.setup(char_before, player_character, xp_reward)
	progression_screen.show()


# Called when player confirms progression/skill choices
func _on_progression_continue_pressed(): # Connect this signal from ProgressionScreen/SkillUI later
	if not is_in_progression: return

	is_in_progression = false
	skill_ui.visible = false
	progression_screen.hide()
	_prepare_next_wave()

func _on_view_skills_pressed():
	if not is_in_progression: return

	progression_screen.hide() # Hide progression screen
	skill_ui.update_ui(player_character) # Update skill UI with current char
	skill_ui.visible = true # Show skill UI

func _on_retry_arena():
	show_class_selection() # Go back to class selection for a fresh start

func _on_return_to_main_menu():
	var err = get_tree().change_scene_to_file("res://scenes/main_menu.tscn") # Adjust path
	if err != OK:
		printerr("Error changing scene to Main Menu: ", err)

func _game_over():
	is_in_combat = false # Ensure flags are reset
	is_in_progression = false
	combat_scene.visible = false
	if combat_scene.has_method("toggle_ui"): combat_scene.toggle_ui(false)
	if skill_ui: skill_ui.visible = false
	if progression_screen and progression_screen.is_visible_in_tree(): progression_screen.hide()

	game_over_screen.show_screen(current_wave, player_character)

### main_scene.gd ###
extends Node2D

@onready var combat_scene: CombatMap = $combat_scene
@onready var overworld: Overworld = $overworld

const PostFightScreenScene = preload("res://scenes/post_fight_screen.tscn")
var post_fight_screen_instance: Control = null

var XP_PER_ENEMY_LEVEL = 250

# Called when the node enters the scene tree for the first time.
func _ready():
	combat_scene.visible = false
	combat_scene.toggle_ui(false)
	overworld.visible = true
	overworld.toggle_ui(true)

	overworld.event_manager.fight_ui.launch_fight.connect(lauch_combat)
	overworld.event_manager.fight_ui.resolve_fight.connect(_end_combat)
	combat_scene.combat_ended.connect(_end_combat)

	AudioManager.play_music(AudioManager.OVERWORLD_MUSIC[0]) # Play overworld music


func lauch_combat(party: Array[PartyMember], enemies: EnemyGroup):
	combat_scene.visible = true
	combat_scene.toggle_ui(true)
	overworld.visible = false
	overworld.toggle_ui(false)
	overworld.player.toggle_camera(false)
	overworld.disable_collisions(true)

	combat_scene.enter_combat(party, enemies.enemies)
	AudioManager.play_music(AudioManager.BATTLE_MUSIC, true) 


func _end_combat(victory: bool):
	combat_scene.visible = false
	combat_scene.toggle_ui(false)
	overworld.visible = true

	overworld.toggle_ui(true)
	overworld.player.toggle_camera(true)
	overworld.disable_collisions(false)

	var last_enemy_group: EnemyGroup = overworld.event_manager.fight_ui.enemy_group

	var xp_reward = 0
	if last_enemy_group:
		for enemy_char in last_enemy_group.enemies:
			# Base XP per enemy level, modify as needed
			xp_reward += enemy_char.character_level * XP_PER_ENEMY_LEVEL
		if not victory:
			xp_reward *= 0.3 # Penalty for losing (or set to 0?)
	else:
		printerr("Cannot calculate XP, last_enemy_group is null!")


	var party_before: Array[PartyMember] = []
	for member in game_state.party:
		party_before.append(member.duplicate())

	if xp_reward > 0:
		game_state.receive_experience(xp_reward)

	if PostFightScreenScene:
		if post_fight_screen_instance == null or not is_instance_valid(post_fight_screen_instance):
			post_fight_screen_instance = PostFightScreenScene.instantiate()
			overworld.get_node("UI").add_child(post_fight_screen_instance) # Add to main scene tree
			post_fight_screen_instance.get_node("background/proceed_button").pressed.connect(_on_post_fight_proceed.bind(victory)) # Connect button

		# Pass data to the screen's script (needs a function like setup())
		AudioManager.play_music(AudioManager.VICTORY_STINGER if victory else AudioManager.DEFEAT_STINGER)
		post_fight_screen_instance.setup(party_before, game_state.party, xp_reward, victory)
		post_fight_screen_instance.show()
	else:
		printerr("PostFightScreenScene not loaded!")
		# If screen fails, proceed directly
		_on_post_fight_proceed(victory)

func _on_post_fight_proceed(victory: bool):
	AudioManager.play_music(AudioManager.OVERWORLD_MUSIC[0]) # Resume overworld music

	if post_fight_screen_instance and is_instance_valid(post_fight_screen_instance):
		post_fight_screen_instance.hide()

	overworld.event_manager.exit_fight(victory)





### test_scene.gd ###
extends TileMap

var last_clicked_cell: Vector2i = Vector2(3, 2) 
var highlighted_cells: Array[Vector2i] = []

func _input(event):
	var curr_cell = local_to_map(to_local(get_global_mouse_position()))


	if event is InputEventMouseMotion:
		for cell in highlighted_cells:
			set_cell(0, cell, 22, get_cell_atlas_coords(0, cell), 0)
		highlighted_cells = HexHelper.oddr_linedraw(last_clicked_cell, curr_cell)
		for cell in highlighted_cells:
			set_cell(0, cell, 22, get_cell_atlas_coords(0, cell), 3)

	if event is InputEventMouseButton:
		if event.button_index == MOUSE_BUTTON_LEFT and event.pressed:
			print(highlighted_cells)
			print(HexHelper.cube_linedraw(HexHelper.axial_to_cube(HexHelper.oddr_to_axial(last_clicked_cell)), HexHelper.axial_to_cube(HexHelper.oddr_to_axial(curr_cell))))
			print(curr_cell)
			print()
			last_clicked_cell = curr_cell

			


### character.gd ###
class_name Character

var character_name: String
var character_class: CLASSES
var character_portrait: int
var character_level: int

var max_health: int
var base_damage: float

var base_skill: Skill
var skill_list: Array[Skill] = []

enum CLASSES {Warrior, Mage, Rogue, None}

func _init(name, _class, portrait, level, health: int = 100, damage: float = 10):
	self.character_name = name
	self.character_class = _class
	self.character_portrait = portrait
	self.character_level = level
	self.max_health = health
	self.base_damage = damage

	if _class == CLASSES.Warrior:
		self.base_skill = BoundingLeap.new()
	elif _class == CLASSES.Mage:
		self.base_skill = FiresparkMage.new()

func reset_skills(): 
	for skill in skill_list:
		skill.cooldown = 0
	if base_skill:
		base_skill.cooldown = 0

func get_char_class() -> String : 
	return CLASSES.keys()[character_class]

func get_portrait_path() -> String : 
	return "res://assets/enemies/monster_" + "%02d" % character_portrait + ".png"

func duplicate() -> Character:
	var new_character = Character.new(character_name, character_class, character_portrait, character_level)
	new_character.skill_list = skill_list.duplicate(true)
	return new_character

### enemy_group.gd ###
class_name EnemyGroup

var enemies: Array[Character] = []
var enemy: Character

func _init(name, enemies_class, enemies_portrait, enemies_level, enemies_count, enemies_hp=100, enemies_damage=10):
	for i in range(enemies_count):
		enemies.append(Character.new(name, enemies_class, enemies_portrait, enemies_level, enemies_hp, enemies_damage))

	enemy = Character.new(name, enemies_class, enemies_portrait, enemies_level)


### party_member.gd ###
extends Character
class_name PartyMember

var character_sex: SEX
var character_experience: int
var skill_points: int
var spent_skill_points: int

const NB_FEMALE_PORTRAIT = 36
const NB_MALE_PORTRAIT = 21

enum SEX {Male, Female, Other}

func _init(char_name, _class, portrait, level, sex, _skill_list: Array[Skill] = [], health: int = 100, damage: float = 10):
	super(char_name, _class, portrait, level, health, damage)
	self.character_sex = sex

	
static func new_rand() -> PartyMember: 
	var sex = randi_range(0, 1)
	var names = load("res://text/characters/" + ("female_character_names.json" if sex == 1 else "male_character_names.json")).data.names
	var char_name = names[randi() % names.size()]
	var portrait = randi() % (NB_FEMALE_PORTRAIT if sex == 1 else NB_MALE_PORTRAIT)
	var char_class: CLASSES = CLASSES.values()[randi_range(0, CLASSES.size() - 3)]

	var new_char = PartyMember.new(char_name, char_class, portrait, 1, sex)
	
	return new_char
	
func receive_experience(experience: int) : 
	var threshold = next_level()
	character_experience += experience
	while character_experience > threshold : 
		character_level += 1
		skill_points += 1
		max_health += round(0.2 * max_health * randf_range(0.9, 1.1))
		base_damage += round(0.1 * base_damage * randf_range(0.9, 1.1))
		character_experience -= threshold
		threshold = next_level()

func spend_skill_point() : 
	if skill_points > 0 : 
		skill_points -= 1
		spent_skill_points += 1
	
func next_level() : 
	return floor(1000 * pow(character_level, 1.5))

func get_portrait_path() -> String : 
	return "res://assets/chars/" + ("female/female_" if character_sex == 1 else "male/male_") + "%02d" % character_portrait + ".png"

func _to_string():
	return "Name: " + character_name + "\n" + \
		"Class: " + get_char_class() + "\n" + \
		"Level: " + str(character_level) + "\n" + \
		"Experience: " + str(character_experience) + "\n" + \
		"Skill Points: " + str(skill_points) + "\n" + \
		"Spent Skill Points: " + str(spent_skill_points) + "\n"

func duplicate() -> PartyMember:
	var new_character = PartyMember.new(character_name, character_class, character_portrait, character_level, character_sex)
	new_character.skill_list = skill_list.duplicate(true)
	new_character.character_experience = character_experience
	new_character.skill_points = skill_points
	new_character.spent_skill_points = spent_skill_points
	return new_character


### ai_combat_character.gd ###
extends CombatCharacter
class_name AICombatCharacter

const enemy_character = preload("res://scenes/ai_combat_character.tscn")

var attack_range: int = 1
var move_range: int = 1 # Number of tiles the enemy can move per turn


##
## Create a new AI enemy character [br]
## [code] _char [/code]: Character to create the AI character from  [br]
## [code] return [/code]: the new AI character
##
static func new_character(_char: Character) -> AICombatCharacter:
	var new_char = enemy_character.instantiate()
	new_char.character = _char
	for skill in _char.skill_list : 
		skill.skill_finished.connect(new_char.finish_turn)
	
	if _char.base_skill:
		_char.base_skill.skill_finished.connect(new_char.finish_turn)
	
	return new_char


func _ready():
	super()
	walkable_cells = [0, 2, 6, 7, 8, 9, 10, 11, 14, 15, 16]


##
## Take a turn for the AI character, moving and attacking the closest player if possible
## If no player is in range, the AI will move to a random walkable cell
##
func take_turn():
	await get_tree().create_timer(0.25).timeout
	for skill in character.skill_list : 
		skill.decrease_cooldown()
	if character.base_skill:
		character.base_skill.decrease_cooldown()

	if char_statuses["stunned"] > 0 :
		char_statuses["stunned"] -= 1
		if char_statuses["stunned"] == 0:
			curr_stun_animation.queue_free()
			curr_stun_animation = null
		turn_finished.emit()
		return


	var party = map.get_alive_party_members()
	var current_pos = map.get_cell_coords(global_position)
	var usable_skills = get_usable_skills()

	map.enable_disable_cells(true, false, true)

	var possible_actions = evaluate_potential_actions(current_pos, party, usable_skills)

	if possible_actions.size() > 0:
		var selected_action = score_and_select_action(possible_actions)
		# print("Selected Action: ", selected_action.type, " | Skill: ", selected_action.skill.get_skill_name() if selected_action.skill else "N/A", " | Target: ", selected_action.target_character.character.character_name if selected_action.target_character else str(selected_action.target_cell), " | Score: ", selected_action.score)

		match selected_action.type:
			"attack":
				attack(map.to_local(selected_action.target_character.global_position))
				deal_damage(selected_action.target_character, 1)
			"skill":
				selected_action.skill.use_skill(self, selected_action.target_cell, map)
			"move":
				move_to(map.map_to_local(selected_action.target_cell))
			"wait" :
				finish_turn()

	map.enable_disable_cells(true, false, false)


##
## Get the closest player and the path to reach him
## [code] party [/code]: Array of players to check for the closest one
## [code] return [/code]: Array containing the closest player and the path to reach him
##
func get_closest_player_path(party: Array[PlayerCombatCharacter]) -> Array:
	var closest_player = null
	var closest_path = null
	for player in party:
		var path = _calculate_path_to_character(map.get_cell_coords(player.global_position))
		var distance = path.size()
		if  closest_path == null or distance < closest_path.size():
			closest_path = path
			closest_player = player
	return [closest_player, closest_path]

func get_lowest_health_player_path(party: Array[PlayerCombatCharacter]) -> Array:
	party = party.duplicate()
	party.sort_custom(func (a, b): return a.health < b.health)
	for player in party:
		var path = _calculate_path_to_character(map.get_cell_coords(player.global_position))
		var distance = path.size()
		if distance > 0:
			return [player, path] 
	return [null, null]

	

func get_usable_skills() -> Array[Skill]:
	var usable_skills: Array[Skill] = []
	if character.base_skill && character.base_skill.cooldown == 0:
		usable_skills.append(character.base_skill)
	for skill in character.skill_list:
		if skill.cooldown == 0:
			usable_skills.append(skill)
	return usable_skills

func evaluate_potential_actions(current_pos: Vector2i, alive_players: Array[PlayerCombatCharacter], usable_skills: Array[Skill]) -> Array[Dictionary] :
	var possible_actions: Array[Dictionary] = []
	
	var attackable_cells = HexHelper.hex_reachable(current_pos, attack_range, map.can_walk)

	for cell in attackable_cells:
		if HexHelper.distance(current_pos, cell) > 0: # Don't attack self cell
			var target_char = map.get_character(cell)
			if target_char and target_char is PlayerCombatCharacter: # TODO have to check if the target is an enemy
				var action = {
					"type": "attack",
					"target_character": target_char,
					"target_cell": cell,
					"skill": null, # No specific skill object for basic attack
					"targets_hit": [target_char], # List of characters affected
					"score": 0.0 # Score will be calculated later
				}
				possible_actions.append(action)
				# print("Added Basic Attack action vs ", target_char.character.character_name)
			
	for skill in usable_skills:
		var potential_initiations: Array[TargetInfo] = skill.generate_targets(self, map)

		for initiation_info in potential_initiations:
			possible_actions.append({
				"type": "skill",
				"target_character": initiation_info.primary_target, # The primary target/caster or null
				"target_cell": initiation_info.target_cell,     # The cell targeted or AoE center
				"skill": skill,                                 # The skill being used
				"targets_hit": initiation_info.affected_targets,# The characters affected
				"score": 0.0                                    # Score calculated later
			})
			# print("Added Skill Action: ", skill.get_skill_name(), " based on ", initiation_info._to_string())


	if not alive_players.is_empty() and not char_statuses["rooted"] > 0:
		for player in alive_players:
			var path = _calculate_path_to_character(map.get_cell_coords(player.global_position))
			if path.size() > 1: 
				var primary_target = player
				possible_actions.append({
					"type": "move",
					"target_character": primary_target,
					"target_cell": path[1],
					"skill": null,
					"targets_hit": [],
					"score": 0.0 # Score calculated later
				}) 
				# print("Added Move Action towards ", primary_target.character.character_name, " to cell ", path[1])
		

	possible_actions.append({
		"type": "wait",
		"target_character": null,
		"target_cell": current_pos, # Wait at current location
		"skill": null,
		"targets_hit": [],
		"score": 1.0 # Minimal base score for waiting
	})

	# print("Generated ", possible_actions.size(), " possible actions.")
	return possible_actions

func score_and_select_action(possible_actions: Array[Dictionary]) -> Dictionary:
	if possible_actions.is_empty(): return {} # Should not happen due to Wait action

	var scored_actions: Array[Dictionary] = []
	for action in possible_actions:
		var current_score = 0.0
		match action.type:
			"attack":
				current_score = score_basic_attack(self, action.targets_hit[0]) # Pass the single target
			"skill":
				current_score = action.skill.score_action(self, action.targets_hit, action.target_cell, map)
			"move":
				current_score = score_move_action(self, action.target_character, action.target_cell)
			"wait":
				current_score = action.score # Use default wait score

		action.score = current_score
		scored_actions.append(action)
		# print("Scored ", action.type, " | Skill: ", action.skill.get_skill_name() if action.skill else "N/A", " | Target: ", action.target_character.character.character_name if action.target_character else str(action.target_cell), " | Score: ", current_score)

	# Sort by score descending
	scored_actions.sort_custom(func(a, b): return a.score > b.score)

	# TODO: Add weighted random selection here instead of just taking the best?
	if not scored_actions.is_empty():
		# print("Selected Action: ", scored_actions[0].type, " with score ", scored_actions[0].score)
		return scored_actions[0]
	else:
		return {} # Fallback

func score_basic_attack(caster: AICombatCharacter, target: CombatCharacter) -> float:
	var score = 10.0 # Placeholder
	var potential_damage = caster.get_damage() * 1.0 # Basic attack damage mult = 1?
	score += potential_damage * AIScoringWeights.WEIGHT_DAMAGE
	if target.health <= potential_damage: score += AIScoringWeights.WEIGHT_KILL_BONUS
	return score

func score_move_action(caster: AICombatCharacter, primary_target: CombatCharacter, destination_cell: Vector2i) -> float:
	var score = 5.0 # Placeholder
	var current_pos = map.get_cell_coords(caster.global_position)
	if primary_target:
		var target_pos = map.get_cell_coords(primary_target.global_position)
		var current_dist = HexHelper.distance(current_pos, target_pos)
		var new_dist = HexHelper.distance(destination_cell, target_pos)
		score += (current_dist - new_dist) * AIScoringWeights.WEIGHT_POSITIONING_CLOSER
	return score


### ai_scoring_weights.gd ###
class_name AIScoringWeights 
static var WEIGHT_BASE_MELEE = 5.0 # Base score for a possible action
static var WEIGHT_BASE_RANGED = 10.0
static var WEIGHT_BASE_MOBILITY = 5.0 # Base score for a possible action
static var WEIGHT_SKILL_DISTANCE = 1.5 # Bonus for the distance from the target
static var WEIGHT_DAMAGE = 1.0
static var WEIGHT_DAMAGE_PER_HP = 0.5 # Bonus for damaging low-health targets
static var WEIGHT_KILL_BONUS = 50.0
static var WEIGHT_HEAL = 1.2
static var WEIGHT_HEAL_LOW_HP_BONUS = 30.0 # Bonus per % health missing
static var WEIGHT_SHIELD = 0.8
static var WEIGHT_SHIELD_ENEMY = 0.1 # Penalty for hitting shielded enemies
static var WEIGHT_BUFF_POSITIVE = 15.0 # Base value for applying a useful buff
static var WEIGHT_BUFF_NEGATIVE = 20.0 # Base value for applying a useful debuff
static var WEIGHT_DISABLE_TURN = 40.0 # Value of stun/root
static var WEIGHT_AOE_TARGET_ENEMY = 1.0 # Multiplier per enemy hit
static var WEIGHT_AOE_TARGET_ALLY_HEAL = 1.0 # Multiplier per ally healed
static var WEIGHT_AOE_TARGET_ALLY_BUFF = 0.8 # Multiplier per ally buffed
static var WEIGHT_AOE_TARGET_ALLY_DAMAGE_PENALTY = -30 # Penalty for hitting allies with damage
static var WEIGHT_POSITIONING_CLOSER = 10.0 # Value per hex closer to primary target
static var WEIGHT_POSITIONING_SAFETY = 5.0 # Value per hex closer to safety
static var WEIGHT_HEALTH_COST_PENALTY = -0.5 # Penalty per % max health cost
static var WEIGHT_SETUP_BONUS = 10.0 # Bonus for applying debuffs like vulnerable/mark
static var WEIGHT_SKILL_LOW_HEALTH = -5 # Penalty for using a skill when low on health

### combat_character.gd ###
extends CharacterBody2D
class_name CombatCharacter

var map: CombatMap

var move_target = null
var attack_target = null
var knockback_target = null
var init_pos = null
@export var speed: int = 1000

signal turn_finished
signal hover_entered(character)
signal hover_exited(character)

@onready var health_bar = $health_bar
@onready var health_label = $health_bar/curr_health
@onready var shield_bar = $shield_bar
@onready var shield_label = $shield_bar/curr_shield
@onready var status_effects_container: BoxContainer = $status_effects_container
@onready var character_highlight = $character_portrait_bg/character_background
@onready var attack_swing_player: AudioStreamPlayer2D = $attack_swing_player
@onready var take_damage_player: AudioStreamPlayer2D = $take_damage_player
@onready var death_player: AudioStreamPlayer2D = $death_player
@onready var footstep_player: AudioStreamPlayer2D = $footstep_player

const ATTACK_SWING_SFX = [
	preload("res://audio/sfx/combat/swing_melee_01.wav"),
	preload("res://audio/sfx/combat/swing_melee_02.wav"),
	preload("res://audio/sfx/combat/swing_melee_03.wav"),
]
const TAKE_DAMAGE_SFX = [ # Use array for variety
	preload("res://audio/sfx/combat/hit_flesh_01.wav"),
	preload("res://audio/sfx/combat/hit_flesh_02.wav"),
	preload("res://audio/sfx/combat/hit_flesh_03.wav"),
]
const FOOTSTEP_SFX = [
	preload("res://audio/sfx/combat/footstep_dirt_01.wav"),
	preload("res://audio/sfx/combat/footstep_dirt_02.wav")
]

const StatusIconScene = preload("res://scenes/status_icon.tscn")
const STATUS_ICON_MAP = {
	"stunned": "res://assets/ui/status/stunned_icon.png",
	"defensive": "res://assets/ui/status/defensive_icon.png",
	"weak": "res://assets/ui/status/weak_icon.png",
	"strong": "res://assets/ui/status/strong_icon.png",
	"vulnerable": "res://assets/ui/status/vulnerable_icon.png",
	"rooted": "res://assets/ui/status/rooted_icon.png",
	"decay": "res://assets/ui/status/decay_icon.png",
	"thorns": "res://assets/ui/status/thorns_icon.png",
	"blessed": "res://assets/ui/status/blessed_icon.png",
	 "leech": "res://assets/ui/status/leech_icon.png",
	 "imbue": "res://assets/ui/status/imbue_icon.png" 
}

@onready var character_portrait = $character_portrait_bg/character_portrait
signal character_died(character)

var char_statuses: Dictionary = {"stunned": 0, "rooted": 0, "vulnerable": 0, "defensive" : 0, "weak": 0, "blessed" : 0, "strong" : 0, "leech" : [], "imbue" : [0,0], "thorns" : [0,0], "decay" : [0,0]}

var stunned_animation = preload("res://scenes/stun_animation.tscn")
var curr_stun_animation = null

var character: Character


var shield: float = 0
var max_health: float = 100
var health: float = 100
var base_damage: float = 10

var walkable_cells: Array[int] = []

func _ready() : 
	map = get_parent().get_parent().get_parent()
	character_portrait.texture = load(character.get_portrait_path())
	max_health = character.max_health
	health = character.max_health
	base_damage = character.base_damage
	_update_health_bar()
	_update_shield_bar()
	mouse_entered.connect(_on_mouse_entered)
	mouse_exited.connect(_on_mouse_exited)
	call_deferred("update_status_icons")


##
## Move to a new target [br]
## If the character is not already moving, set the new target as the move target [br]
## If the character is already moving, ignore the new target [br]
## [code] new_target [/code]: The position of the target character
##
func move_to(new_target) : 
	if not move_target :
		if not FOOTSTEP_SFX.is_empty() :
			footstep_player.stream = FOOTSTEP_SFX[randi() % FOOTSTEP_SFX.size()]
			footstep_player.play()
		move_target = new_target

##
## Attack a new target [br]
## If the character is not already attacking, set the new target as the attack target [br]
## If the character is already attacking, ignore the new target	[br]
## [code] new_target [/code]: The position of the target character [br]
## [code] ranged [/code]: If the attack is ranged or not
##
func attack(new_target: Vector2i, ranged: bool = false) :
	if not attack_target :
		attack_target = new_target
		if ranged : 
			init_pos = position
		else : 
			var path = _calculate_path_to_character(map.local_to_map(new_target))
			init_pos = map.map_to_local(path[path.size() - 2])

func _physics_process(_delta):
	if not move_target and not attack_target and not knockback_target : 
		return

	if move_target :	
		move_to_target()
	elif attack_target :
		move_to_attack_target()
	elif knockback_target : 
		knock_to_target()

##
## Move the character to the move target [br]
## If the character is close enough to the target, finish the turn
##
func move_to_target() :
	velocity = position.direction_to(move_target) * speed
	if position.distance_to(move_target) > 50:
		move_and_slide()
	else :
		position = move_target
		finish_turn()

func knock_to_target() :
	velocity = position.direction_to(knockback_target) * speed
	if position.distance_to(knockback_target) > 50:
		move_and_slide()
	else :
		position = knockback_target
		knockback_target = null

##
## Move the character to the attack target [br]
## If the character is close enough to the target, moves the character back to the initial position [br]
##
func move_to_attack_target() :		
	z_index = 10
	velocity = position.direction_to(attack_target) * speed
	if position.distance_to(attack_target) > 50:
		move_and_slide()
	else :
		position = attack_target
		if init_pos :
			if not ATTACK_SWING_SFX.is_empty() :
				footstep_player.stream = ATTACK_SWING_SFX[randi() % ATTACK_SWING_SFX.size()]
				footstep_player.play()
			attack_target = init_pos
			init_pos = null
		else :
			finish_turn()

##
## Decrease the health of the character by the damage taken [br]
## Update the health bar [br]
## If the health is less than or equal to 0, emit the character_died signal
## [code] damage_taken [/code]: The amount of base_damage taken
##
func take_damage(damage_taken: float) -> float :
	if char_statuses["defensive"] > 0 : 
		damage_taken = damage_taken / 2
	if char_statuses["vulnerable"] > 0 : 
		damage_taken = damage_taken * 3/2

	if shield > 0 :
		if shield >= damage_taken : 
			shield -= damage_taken
			damage_taken = 0
		else : 
			damage_taken -= shield
			shield = 0

	if damage_taken > 0 and not TAKE_DAMAGE_SFX.is_empty() :
		take_damage_player.stream = TAKE_DAMAGE_SFX[randi() % TAKE_DAMAGE_SFX.size()]
		take_damage_player.play()

	health -= damage_taken

	_update_health_bar()
	_update_shield_bar()

	if health <= 0 :
		queue_free()
		character_died.emit(self)
	
	return damage_taken

##
## Decrease the health of the character by the health_spent. Ignore statuses and shield. [br]
## Update the health bar [br]
## If the health is less than or equal to 0, emit the character_died signal
## [code] health_spent [/code]: The amount of health to spend
##
func spend_health(health_spent: float) : 
	health -= health_spent
	_update_health_bar()

	if health <= 0 :
		queue_free()
		character_died.emit(self)

##
## Heal the character by the heal_amount [br]
## If the character is blessed, the heal_amount is increased by 10% times the level of blessed [br]
## [code] heal_amount [/code]: The amount of health to heal
##
func heal(heal_amount: float) -> float: 
	var blessed_lvl = char_statuses["blessed"]
	if blessed_lvl > 0 : 
		heal_amount = heal_amount * (1 + blessed_lvl/10.0)
	health = min(max_health, health + heal_amount)
	_update_health_bar()

	return heal_amount

##
## Gain shield up to the max health of the character [br]
## [code] shield_percentage [/code]: The percentage of max_health to gain as shield
##
func gain_shield(shield_percentage: float) -> float:
	return gain_shield_flat(max_health * shield_percentage / 100.0)

##
## Gain shield up to the max health of the character [br]
## [code] shield_amount [/code]: The amount of shield to gain
## [code] return [/code]: The amount of shield gained
##
func gain_shield_flat(shield_amount: float) -> float:
	var old_value = shield 
	shield = min(max_health, shield + shield_amount)
	_update_shield_bar()
	return shield - old_value

##
## Update the health bar [br]
## The health bar value is the health divided by the max_health [br]
## The health label is the health divided by the max_health
##
func _update_health_bar() : 
	health_bar.value = (health / max_health) * health_bar.max_value
	health_label.text = str(roundi(health)) + "/" + str(max_health)

func _update_shield_bar() : 
	if shield <= 0 : 
		shield_bar.visible = false
		shield_label.visible = false
	else : 
		shield_bar.visible = true
		shield_label.visible = true
		shield_bar.max_value = max_health
		shield_bar.value = (shield / max_health) * shield_bar.max_value
		shield_label.text = str(roundi(shield)) + "/" + str(max_health)

##
## Get the amount of damage the character will deal on the next attack [br]
## If the character is weak, the base_damage is reduced by a third [br]
## [code] return [/code]: The amount of base_damage the character can deal
##
func get_damage() -> float :
	var damage =  base_damage + char_statuses["imbue"][1] if char_statuses["imbue"][0] > 0 else base_damage
	if char_statuses["weak"] > 0 : 
		damage = damage * 2 / 3
	if char_statuses["strong"] > 0 : 
		damage = damage * 3 / 2
	return damage

func deal_damage(other: CombatCharacter, damage_mult: float) -> float : 
	var damage = get_damage() * damage_mult
	other.take_damage(damage)

	if (other.char_statuses["thorns"][0] > 0) :
		take_damage(other.char_statuses["thorns"][1])

	if char_statuses["leech"].size() > 0 : 
		var leech_stats = char_statuses["leech"]
		var leech_level = 0
		for i in range(leech_stats.size()) : 
			if leech_stats[i][0] > 0 : 
				leech_level += leech_stats[i][1]
		heal(damage * leech_level / 100.0)

	return damage

func take_turn() : 
	assert(false, "take_turn not implemented")

##
## Finish the turn [br]
## Reset the move target and attack target [br]
## Emit the turn_finished signal
##
func finish_turn() : 
	z_index = 0
	attack_target = null
	move_target = null
	char_statuses["defensive"] = max(0, char_statuses["defensive"] - 1)
	char_statuses["vulnerable"] = max(0, char_statuses["vulnerable"] - 1)
	char_statuses["rooted"] = max(0, char_statuses["rooted"] - 1)
	char_statuses["weak"] = max(0, char_statuses["weak"] - 1)
	char_statuses["strong"] = max(0, char_statuses["strong"] - 1)
	char_statuses["imbue"][0] = max(0, char_statuses["imbue"][0] - 1)
	var new_leech = []
	for i in range(char_statuses["leech"].size()) : 
		char_statuses["leech"][i][0] = char_statuses["leech"][i][0] - 1
		if char_statuses["leech"][i][0] > 0 : 
			new_leech.append(char_statuses["leech"][i])
	char_statuses["leech"] = new_leech
	char_statuses["decay"][0] = max(0, char_statuses["decay"][0] - 1)
	char_statuses["thorns"][0] = max(0, char_statuses["thorns"][0] - 1)

	if char_statuses["decay"][0] > 0 : 
		take_damage(char_statuses["decay"][1] * max_health / 100.0)

	update_status_icons()
	await get_tree().create_timer(0.25).timeout
	turn_finished.emit()

##
## Calculate the path to the target character using the A* algorithm [br]
## [code] other_char_pos [/code]: The position of the target character [br]
## [code] return [/code]: The path to the target character
##
func _calculate_path_to_character(other_char_pos: Vector2i) -> PackedVector2Array:
	var this_tile_id = map.cell_ids[map.get_cell_coords(global_position)]
	var target_tile_id = map.cell_ids[other_char_pos]
	return map.astar.get_point_path(this_tile_id, target_tile_id)

func gain_status(status_name: String, nb_turns: int = 1, nb_level: int = 0) :
	match status_name : 
		"stunned" : 
			gain_stunned_status(nb_turns)
		"rooted" : 
			gain_rooted_status(nb_turns)
		"defensive" : 
			gain_defensive_status(nb_turns)
		"weak" : 
			gain_weak_status(nb_turns)
		"blessed" : 
			gain_blessed_status(nb_level)
		"strong" : 
			gain_strong_status(nb_turns)
		"imbue" : 
			gain_imbue_status(nb_turns, nb_level)
		"vulnerable" : 
			gain_vulnerable_status(nb_turns)
		"leech" :
			gain_leech_status(nb_turns, nb_level)
		"thorns":
			gain_thorn_status(nb_turns, nb_level)
		"decay":
			gain_decay_status(nb_turns, nb_level)

	update_status_icons()

##
## Stun the character, making him skip his next turn [br]
##
func gain_stunned_status(nb_turns: int = 1) : 
	char_statuses["stunned"] = nb_turns
	curr_stun_animation = stunned_animation.instantiate()
	add_child(curr_stun_animation)
	curr_stun_animation.position = Vector2(0, 0)
	curr_stun_animation.z_index = 10
	curr_stun_animation.play()

func gain_rooted_status(nb_turns: int = 1) : 
	char_statuses["rooted"] = max(nb_turns, char_statuses["rooted"])

func gain_defensive_status(nb_turns: int = 1) : 
	char_statuses["defensive"] = nb_turns
	if char_statuses["vulnerable"] > 0 : 
		char_statuses["vulnerable"] = 0

func gain_weak_status(nb_turns: int = 1) :
	char_statuses["weak"] = nb_turns
	if char_statuses["strong"] > 0 : 
		char_statuses["strong"] = 0

func gain_blessed_status(nb_level: int = 1) : 
	char_statuses["blessed"] = nb_level

func gain_strong_status(nb_turns: int = 1) : 
	char_statuses["strong"] = nb_turns
	if char_statuses["weak"] > 0 : 
		char_statuses["weak"] = 0

func gain_imbue_status(nb_turns: int = 1, imbue_strength: int = 10) :
	char_statuses["imbue"][0] = nb_turns
	char_statuses["imbue"][1] = imbue_strength

func gain_vulnerable_status(nb_turns: int = 1) : 
	char_statuses["vulnerable"] = nb_turns
	if char_statuses["defensive"] > 0 : 
		char_statuses["defensive"] = 0

func gain_leech_status(nb_turns: int = 1, nb_levels: int = 1) : 
	char_statuses["leech"].append([nb_turns, nb_levels])

func gain_thorn_status(nb_turns: int = 1, nb_levels: int = 1) :
	char_statuses["thorns"][0] = char_statuses["thorns"][0] + nb_turns
	char_statuses["thorns"][1] = max(char_statuses["thorns"][1], nb_levels)

func gain_decay_status(nb_turns: int = 1, decay_percent: int = 10) :
	char_statuses["decay"][0] = max(char_statuses["decay"][0], nb_turns)
	char_statuses["decay"][1] = char_statuses["decay"][1] + decay_percent

func knockback(knockback_distance: int, direction: int, knockback_damage: float) : 
	var curr_pos = map.get_cell_coords(global_position)
	var knock_target = curr_pos
	var knocked = false
	for i in range(knockback_distance) : 
		var neighbour = HexHelper.hex_neighbor(knock_target, direction)
		if not map.can_walk(neighbour) or map.cell_occupied(neighbour) : 
			knocked = true
			break
		knock_target = neighbour
	knockback_target = map.map_to_local(knock_target)
	if knocked : 
		take_damage(knockback_damage)


## UI

func _on_mouse_entered() : 
	hover_entered.emit(self)

func _on_mouse_exited() :
	hover_exited.emit(self)

func update_status_icons():
	if not is_inside_tree() or not status_effects_container: # Safety check
		return

	# Clear previous icons
	for child in status_effects_container.get_children():
		child.queue_free()

	# Add icons for current statuses
	for status_name in char_statuses.keys():
		var status_value = char_statuses[status_name]
		var show_icon = false
		var duration = -1
		var level = -1

		# Determine if the status is active and get display value
		match status_name:
			"leech":
				if status_value is Array and not status_value.is_empty():
					show_icon = true
					for i in range(status_value.size()):
						if status_value[i][0] > 0:
							show_icon = true
							duration += status_value[i][0] # Show duration
							level = max(status_value[i][1], level) # Show level
			"imbue", "thorns", "decay":
				if status_value is Array and status_value[0] > 0: # Check duration part
					show_icon = true
					duration = status_value[0] # Show duration
					level = status_value[1] # Show level
			_: # Default for simple duration/level statuses
				if status_value is int and status_value > 0:
					show_icon = true
					duration = status_value

		 # Instantiate and add icon if active
		if show_icon and STATUS_ICON_MAP.has(status_name):
			if StatusIconScene:
				var icon_instance = StatusIconScene.instantiate()
				icon_instance.call_deferred("set_data", load(STATUS_ICON_MAP[status_name]), duration, level)
				icon_instance.name = status_name
				
				status_effects_container.add_child(icon_instance)
				# Optional: Add tooltip to the icon instance here
				# icon_instance.tooltip_text = get_status_description(status_name)
			else:
				printerr("StatusIconScene not loaded!")

func set_highlight(is_highlighted: bool, color: Color = Color(0xffcd12ff)):
	if character_highlight:
		character_highlight.visible = is_highlighted
		character_highlight.color = color
	else :
		printerr("Character highlight not found!")


### combat_map.gd ###
extends TileMap
class_name CombatMap

@onready var skill_bar_ui: SkillBarUI = $UI/skill_ui
@onready var turn_order_container: HBoxContainer = $UI/turn_order_ui/portraits_container 
const TurnOrderPortraitScene = preload("res://scenes/turn_order_portrait.tscn")



@export var debug_mode: bool = false

const PLAYER_STARTING_POS = [Vector2i(0, 3), Vector2i(1, 3), Vector2i(1, 2), Vector2i(2, 2)]
const ENEMY_STARTING_POS = [Vector2i(7, 1), Vector2i(6, 1), Vector2i(7, 2), Vector2i(6, 2), Vector2i(7, 3), Vector2i(6, 3)]

var astar: AStar2D = AStar2D.new()
var cell_ids: Dictionary = {}

var characters: Array[CombatCharacter]
var turn = -1
var player_count = 0
var enemy_count = 0

const CombatCharacterTooltipScene = preload("res://scenes/character_tooltip.tscn")
var character_tooltip_instance: CombatCharacterTooltipUI

signal combat_ended(victory: bool)

func _ready():
	skill_bar_ui.choose_target.connect(_on_skill_selected)
	if debug_mode : 
		var party: Array[PartyMember] = [PartyMember.new_rand(), PartyMember.new_rand()]

		var enemy1 = Character.new("Dark Cultist", 1, 2, 2, 50, 5)
		var enemy2 = Character.new("Dark Cultist", 1, 2, 2)
		var enemies: Array[Character] = [enemy1, enemy2]
		enemy1.skill_list.append(BoundingLeap.new())
		enemy1.skill_list.append(DefensiveStance.new())
		enemy2.skill_list.append(FiresparkMage.new())
		enemy2.skill_list.append(ArcaneShield.new())
		
		enter_combat(party, enemies)

	if CombatCharacterTooltipScene :
		character_tooltip_instance = CombatCharacterTooltipScene.instantiate()
		character_tooltip_instance.hide()
		character_tooltip_instance.top_level = true
		$UI.add_child(character_tooltip_instance)
	else :
		printerr("CombatCharacterTooltipScene not found. Tooltip will not be displayed.")


##
## Enters the combat mode with the specified party members and enemies. [br]
##
## [code]party [/code]: An array of PartyMember objects representing the player's party members.[br]
## [code]enemies [/code]: An array of Character objects representing the enemies in the combat.
##
func enter_combat(party: Array[PartyMember], enemies: Array[Character]) :

	for character in characters : 
		character.queue_free()
	characters.clear()

	player_count = party.size()
	enemy_count = enemies.size()

	for i in range(0, max(party.size(), enemies.size())) : 
		if i < party.size() : 
			party[i].reset_skills()
			var player: CombatCharacter = PlayerCombatCharacter.new_character(party[i])
			get_node("characters/player_characters").add_child(player)
			player.position = map_to_local(PLAYER_STARTING_POS[i])

			characters.append(player)
			player.turn_finished.connect(_on_target_reached)
			player.character_died.connect(_on_character_died)

		if i < enemies.size() : 
			enemies[i].reset_skills()
			var enemy: CombatCharacter = AICombatCharacter.new_character(enemies[i])
			get_node("characters/enemies").add_child(enemy)
			enemy.position = map_to_local(ENEMY_STARTING_POS[i])

			characters.append(enemy)
			enemy.turn_finished.connect(_on_target_reached)
			enemy.character_died.connect(_on_character_died)	

	for character in characters : 
		character.hover_entered.connect(_on_character_hover_entered)
		character.hover_exited.connect(_on_character_hover_exited)

	characters.shuffle()

	_setup_astar()
	
	next_turn()



##
##  Advances the turn to the next character.
##  
func next_turn() -> void :
	reset_map()
	skill_bar_ui.reset_ui()
	turn = (turn + 1) % characters.size()
	update_turn_order_ui()
	characters[turn].take_turn()	
	skill_bar_ui.update_ui(characters[turn].character, not characters[turn] is PlayerCombatCharacter)

### --- UI --- ###
func update_turn_order_ui():
	if not turn_order_container or not TurnOrderPortraitScene: return # Safety checks

	# Clear existing portraits
	for child in turn_order_container.get_children():
		child.queue_free()

	# wait for next frame to ensure the UI is ready
	await get_tree().process_frame

	if characters.is_empty(): return # No characters left

	# Display portraits for the next N turns (e.g., 8 or characters.size())
	var num_to_display = min(8, characters.size())
	for i in range(num_to_display):
		var display_char_index = (turn + i) % characters.size()
		var character_to_display = characters[display_char_index]

		var portrait_instance = TurnOrderPortraitScene.instantiate()
		var is_current = (i == 0) # Highlight the first one in the sequence
		portrait_instance.call_deferred("set_character", character_to_display, is_current)
		#portrait_instance.mouse_entered.connect(character_to_display.set_highlight.bind(true, Color(0xffffffff)))
		#portrait_instance.mouse_exited.connect(character_to_display.set_highlight.bind(false))

		turn_order_container.add_child(portrait_instance)


##
## Checks if a given hexagon is occupied by a character.
##
## [code]hex [/code]: The coords of the hexagon to check if it is occupied.
## [code]return [/code]: True if the hexagon is occupied, false otherwise.
##
func cell_occupied(hex: Vector2i) -> bool : 
	for character in characters : 
		if get_cell_coords(character.global_position) == hex : 
			return true
	return false

##
## Returns the enemy character in a given hexagon. [br]
##
## [code]hex [/code]: The hexagon to check for an enemy character. [br]
## [code]return [/code]: The enemy character in the hexagon, or null if there is none. [br]
##
func enemy_in_cell(hex: Vector2i) -> CombatCharacter: 
	for character in characters : 
		if character is AICombatCharacter && get_cell_coords(character.global_position) == hex : 
			return character
	return null

##
## Returns the character in a given hexagon on the combat map.
##
## [code]hex [/code]: The hexagon to check for a character.[br]
## [code]return [/code]: The character in the hexagon, or null if there is none.
##
func get_character(hex: Vector2i) -> CombatCharacter : 
	for character in characters : 
		if get_cell_coords(character.global_position) == hex : 
			return character
	return null
	
##
## Checks if a given hexagon is walkable. [br]
##
## [code]hex [/code]: The hexagon to check if it is walkable. [br]
## [code]return [/code]: True if the hexagon is walkable, false otherwise. [br]
##
func can_walk(hex: Vector2i) -> bool : 
	return get_cell_source_id(0, hex) == 22 && get_cell_atlas_coords(0, hex).x in characters[turn].walkable_cells

##
## Resets the highlighted neighboring cells of a given hexagon on the combat map. [br]
##
## [code]highlighted_cells [/code]: An array of previously highlighted cells. [br]
##
func reset_neighbours(highlighted_cells: Array[Vector2i]) -> void : 
	for neighbour in highlighted_cells :
		set_cell(0, neighbour, 22, get_cell_atlas_coords(0, neighbour), 0)

func reset_map() -> void : 
	for hex in get_used_cells(0) :
		set_cell(0, hex, 22, get_cell_atlas_coords(0, hex), 0)



## 
## Highlights the neighboring cells of a given hexagon on the combat map.[br]
##
## [code]hex [/code]: The hexagon to highlight its neighbors.[br]
## [code]highlight_range [/code]: The range of neighbors to highlight (default: 0).[br]
## [code]empty_cell_alt [/code]: The alternative tile to use for empty cells (default: 1).[br]
## [code]highlighted_cells [/code]: An array of previously highlighted cells (default: []).[br]
## [code]return [/code]: An array of Vector2i representing the coordinates of the highlighted neighboring cells.
##
func highlight_neighbours(hex: Vector2i, highlight_range = 1, empty_cell_alt: int = 0, enemy_cell_alt: int = 0) -> Array[Vector2i]:
	# Function implementation goes here
	var highlighted_cells = {hex : 0}
	var queue = [hex]

	while queue.size() > 0 :
		var curr_cell = queue.pop_front()
		if highlighted_cells[curr_cell] >= highlight_range : 
			continue
			
		for i in range(0, 6) :
			var neighbour = HexHelper.hex_neighbor(curr_cell, i)
			if not neighbour in highlighted_cells : 
				var curr_range = highlighted_cells[curr_cell]
				if can_walk(neighbour) && !cell_occupied(neighbour): 
					set_cell(0, neighbour, 22, get_cell_atlas_coords(0, neighbour), empty_cell_alt)
					highlighted_cells[neighbour] = curr_range + 1
					queue.append(neighbour)

				if enemy_in_cell(neighbour) : 
					set_cell(0, neighbour, 22, get_cell_atlas_coords(0, neighbour), enemy_cell_alt)
					highlighted_cells[neighbour] = curr_range + 1

	var cells: Array[Vector2i] = []
	for cell in highlighted_cells.keys() : 
		cells.append(cell)
	return cells


##
## Highlights the columns of a given hexagon on the combat map.[br]
##
## [code]hex [/code]: The hexagon to highlight its columns.[br]
## [code]highlight_range [/code]: The range of columns to highlight (default: 1).[br]
## [code]return [/code]: An array of Vector2i representing the coordinates of the highlighted columns.
##
func highlight_columns(hex: Vector2i, highlight_range: int) -> Array[Vector2i] : 
	var highlighted_cells: Array[Vector2i] = []
	
	for i in range(0, 6) : 
		var neighbour = HexHelper.hex_neighbor(hex, i)
		if not can_walk(neighbour) or cell_occupied(neighbour) : 
			continue
		for j in range(highlight_range - 1) : 
			neighbour = HexHelper.hex_neighbor(neighbour, i)
			if not can_walk(neighbour) :
				break
			if cell_occupied(neighbour) :
				if get_character(neighbour) is AICombatCharacter:
					set_cell(0, neighbour, 22, get_cell_atlas_coords(0, neighbour), 4)
					highlighted_cells.append(neighbour)
				break
			 
			set_cell(0, neighbour, 22, get_cell_atlas_coords(0, neighbour), 3)
			highlighted_cells.append(neighbour)
	return highlighted_cells


##
## Returns the list of party members still alive in the combat.
##
## [code]return [/code]: An array of PlayerCombatCharacter objects representing the alive party members.
##
func get_alive_party_members() -> Array[PlayerCombatCharacter] : 
	var alive_party_members: Array[PlayerCombatCharacter] = []
	for character in characters : 
		if character is PlayerCombatCharacter : 
			alive_party_members.append(character)
	return alive_party_members

##
## Finds a random cell in the vicinity of the cell [code] hex [/code] on the combat map.[br]
##
## [code]hex [/code]: The hexagon to find a random cell in its vicinity.[br]
## [code]walkable_cells [/code]: An array of walkable cells on the combat map.[br]
## [code]return [/code]: A Vector2i representing the coordinates of the random cell.
##
func get_random_walkable_neighbor(hex: Vector2i, walkable_cells: Array[int]) -> Vector2i : 
	var parity = hex.y & 1
	var possible_neighbours = []
	for i in range(0, 6) :
		var diff = HexHelper.oddr_direction_differences[parity][i]
		var neighbour = Vector2i(hex.x + diff[0], hex.y + diff[1])
		if walkable_cells.has(get_cell_atlas_coords(0, neighbour).x) && !cell_occupied(neighbour) : 
			possible_neighbours.append(neighbour)
	if possible_neighbours.size() == 0 : 
		return Vector2i(-INF, -INF)
	return possible_neighbours[randi() % possible_neighbours.size()]

##
## Returns the hex-grid coordinates of a given position on the combat map.
##
## [code]pos [/code]: The position to get its cell coordinates.[br]
## [code]return [/code]: A Vector2i representing the coordinates of the position in the hex grid.
##
func get_cell_coords(pos: Vector2) -> Vector2i: 
	return local_to_map(to_local(pos))

##
## Returns the A* ID of a given position on the combat map.
##
## [code]cell_pos [/code]: The position to get its A* ID.[br]
## [code]return [/code]: The A* ID of the position.
##
func get_cell_astar_id(cell_pos) : 
	return cell_ids[get_cell_coords(cell_pos)]


##
## Disables or enables the cells occupied by the enemies or party members. [br]
##
## [code]enemies [/code]: A boolean indicating whether to disable or enable the cells occupied by the enemies.[br]
## [code]party [/code]: A boolean indicating whether to disable or enable the cells occupied by the party members.[br]
## [code]disable [/code]: A boolean indicating whether to disable or enable the cells.
##
func enable_disable_cells(enemies: bool, party: bool, disable: bool) : 
	for character in characters : 
			if enemies and character is AICombatCharacter : 
				astar.set_point_disabled(cell_ids[get_cell_coords(character.global_position)], disable)
			if party and character is PlayerCombatCharacter :
				astar.set_point_disabled(cell_ids[get_cell_coords(character.global_position)], disable)

##
## Turn the combat UI on or off.
##
func toggle_ui(show_ui: bool) : 
	$UI.visible = show_ui

func _on_character_hover_entered(character: CombatCharacter):
	if character_tooltip_instance and is_instance_valid(character):
		character_tooltip_instance.update_content(character)

		# Position the tooltip (similar logic to skill tree tooltip)
		var mouse_pos = get_global_mouse_position()
		var viewport_rect = get_viewport_rect()
		var tooltip_size = character_tooltip_instance.size
		var offset = Vector2(15, 15)
		var target_pos = mouse_pos + offset

		# Adjust if off-screen
		if target_pos.x + tooltip_size.x > viewport_rect.size.x:
			target_pos.x = mouse_pos.x - tooltip_size.x - offset.x
		if target_pos.y + tooltip_size.y > viewport_rect.size.y:
			target_pos.y = mouse_pos.y - tooltip_size.y - offset.y

		character_tooltip_instance.global_position = target_pos
		character_tooltip_instance.show()

func _on_character_hover_exited(_character: CombatCharacter):
	if character_tooltip_instance:
		character_tooltip_instance.hide()


func _on_target_reached() :
	next_turn()

func _on_character_died(character) : 
	var char_index = characters.find(character)
	characters.erase(character)

	if character is PlayerCombatCharacter : 
		player_count -= 1
	else : 
		enemy_count -= 1

	if turn > char_index :
		turn -= 1
	
	if player_count == 0 :
		for enemy in characters : 
			character.queue_free()
		emit_signal("combat_ended", false)

	elif enemy_count == 0 : 
		emit_signal("combat_ended", true)

func _setup_astar():
	var enemy_walkable_cells = [0, 2, 6, 7, 8, 9, 10, 11, 14, 15, 16]
	var id = 0

	for hex in get_used_cells(0):
		if get_cell_atlas_coords(0, hex).x in enemy_walkable_cells: # Assuming -1 is an invalid tile
			astar.add_point(id, hex)
			cell_ids[hex] = id
			id += 1

	for hex in cell_ids.keys():
		for i in range(0, 6):
			var neighbour = HexHelper.hex_neighbor(hex, i)
			if cell_ids.has(neighbour):
				astar.connect_points(cell_ids[hex], cell_ids[neighbour], false)


func _on_skill_selected(skill) : 
	if characters[turn] is PlayerCombatCharacter : 
		(characters[turn] as PlayerCombatCharacter).highlight_skill(skill)


### player_combat_character.gd ###
extends CombatCharacter
class_name PlayerCombatCharacter

const player_character = preload("res://scenes/player_combat_character.tscn")

var is_turn = false

var action_cells: Array[Vector2i] = []

var current_skill: Skill = null
signal use_skill(skill: Skill)

##
## Create a new player character [br]
## [code] _char [/code]: Character to create the player character from  [br]
## [code] return [/code]: the new player character
##
static func new_character(_char: Character) -> PlayerCombatCharacter:
	var new_char: PlayerCombatCharacter = player_character.instantiate()
	new_char.character = _char
	for skill in _char.skill_list : 
		skill.skill_finished.connect(new_char.finish_turn)
	_char.base_skill.skill_finished.connect(new_char.finish_turn)
	return new_char



func _ready():
	super()
	walkable_cells = [0, 2, 6, 7, 8, 9, 10, 11, 14, 15, 16]

##
## Make the player character take a turn, decreasing the cooldown of all skills, highlighting the possible actions and waiting for the player to make a move [br]
## [code] return [/code]: void
##
func take_turn() : 
	for skill in character.skill_list : 
		skill.decrease_cooldown()
	character.base_skill.decrease_cooldown()

	action_cells = map.highlight_neighbours(map.get_cell_coords(global_position), 1, 1, 4)
	action_cells.erase(map.get_cell_coords(global_position))
	current_skill = null
	is_turn = true

func finish_turn() : 
	map.reset_neighbours(action_cells)
	action_cells = []
	current_skill = null
	super()


##
## Highlight the cells that can be targeted by a skill [br]
## [code] skill [/code]: Skill to highlight the possible targets for [br]
## [code] return [/code]: void
##
func highlight_skill(skill: Skill) : 
	map.reset_map()

	if current_skill == skill : 
		action_cells = map.highlight_neighbours(map.get_cell_coords(global_position), 1, 1, 4)
		action_cells.erase(map.get_cell_coords(global_position))
		current_skill = null
		return

	current_skill = skill
	action_cells = skill.highlight_targets(self, map)

##
## Process the input of the player, moving the character or attacking an enemy [br]
## [code] event [/code]: Input event to process [br]
## [code] return [/code]: void
##
func _input(event):
	if not is_turn: 
		return
	
	if event is InputEventMouseMotion :
		if current_skill : 
			var mouse_cell = map.get_cell_coords(get_global_mouse_position())

			map.reset_neighbours(action_cells)
			action_cells = current_skill.highlight_mouse_pos(self, mouse_cell, map)
		

	if event is InputEventMouseButton :
		if event.button_index == MOUSE_BUTTON_LEFT && event.is_pressed():
			var click_pos = map.get_cell_coords(get_global_mouse_position())
			if not current_skill :
				if click_pos in action_cells && map.can_walk(click_pos) && !map.cell_occupied(click_pos): 
					move_to(map.map_to_local(click_pos))
					is_turn = false
					map.reset_neighbours(action_cells)

				var enemy = map.enemy_in_cell(click_pos)
				if click_pos in action_cells && enemy : 
					deal_damage(enemy, 1)
					attack(map.to_local(enemy.global_position))
					is_turn = false
					map.reset_neighbours(action_cells)

			else : 
				if click_pos in action_cells :
					current_skill.use_skill(self, click_pos, map)

	if event.is_action_pressed("combat_cancel_action") :
		map.reset_map()
		action_cells = map.highlight_neighbours(map.get_cell_coords(global_position), 1, 1, 4)
		action_cells.erase(map.get_cell_coords(global_position))
		current_skill = null


### impact_effect.gd ###
extends Node2D
class_name ImpactEffect

@onready var animated_sprite: AnimatedSprite2D = $impact_animation
@onready var impact_player: AudioStreamPlayer2D = $impact_player

const LIGHTNING_STORM_IMPACT = preload("res://audio/sfx/skills/thunder_impact_heavy.mp3")
const METEOR_IMPACT = preload("res://audio/sfx/skills/explosion_impact_01.wav")

var impact_type: String = "" 

func set_impact_type(type_name: String):
	impact_type = type_name
	match type_name:
		"thunderstrike":
			animated_sprite.play("thunderstrike_4")
			impact_player.stream = METEOR_IMPACT
		"lightning_storm":
			animated_sprite.play("thunderstrike_1")
			impact_player.stream = LIGHTNING_STORM_IMPACT

	impact_player.play() # Play the sound effect


### projectile_effect.gd ###
extends CharacterBody2D
class_name ProjectileEffect

signal target_reached

@export var speed: float = 1500.0 # Pixels per second
@onready var travel_player: AudioStreamPlayer2D = $travel_player # If using loop
@onready var impact_player: AudioStreamPlayer2D = $impact_player

const TRAVEL_SFX = preload("res://audio/sfx/skills/magic_missile.wav") # Example loop
const IMPACT_SFX = [
	preload("res://audio/sfx/skills/small_spell_impact_01.wav"),
	preload("res://audio/sfx/skills/small_spell_impact_02.wav"),
	preload("res://audio/sfx/skills/small_spell_impact_03.wav"),
]
	

var target_position = Vector2i.ZERO

func _ready():
	# Set a max lifetime
	$Timer.wait_time = 6.0 
	$Timer.one_shot = true
	$Timer.timeout.connect(queue_free) 
	$Timer.start()

	travel_player.stream = TRAVEL_SFX; 
	travel_player.play()

	$projectile_animation.play()

func set_target_position(global_pos: Vector2i):
	target_position = global_pos
	rotation = position.direction_to(target_position).angle()

func _physics_process(_delta):
	if not target_position: 
		return
	
	velocity = position.direction_to(target_position) * speed	
	if position.distance_to(target_position) > 100:
		move_and_slide()
	else :
		if not IMPACT_SFX.is_empty():
			impact_player.stream = IMPACT_SFX[randi() % IMPACT_SFX.size()]
			impact_player.play()
		target_reached.emit()
		target_position = null


### content_generator.gd ###
extends Node
class_name ContentGenerator

signal content_received(data: Dictionary)
signal error_received(error_message: String)

var api_endpoint = "http://localhost:5000/generate"

var http_request: HTTPRequest

func _ready():
    if not http_request:
        print("LLM_Communicator: Creating HTTPRequest node.")
        http_request = HTTPRequest.new()
        add_child(http_request)

    http_request.request_completed.connect(_on_request_completed)

func request_content(prompt_instruction: String, context_info: String = ""):
    print("LLM_Communicator: Requesting content...")

    var headers = ["Content-Type: application/json"]

    var system_message = "You are a helpful game master assistant for the fantasy RPG Omennis. Respond ONLY with valid JSON matching the requested structure."
    var user_request = prompt_instruction
    if not context_info.is_empty():
        user_request += "\n\nGame Context : \n" + context_info

    var json_format_instruction = """
    Please respond ONLY with a single, valid JSON object matching this exact structure:
    {
	    "id" : "",
	    "name": "",
    	"description" :	"",
		"possibilities" : [
	    	{
		    	"id" : "leave", 
			    "description" : ""
		    },
		    {
			    "id" : "leave", 
			    "description" : ""
		    },
		    {
			    "id" : "leave", 
			    "description" : ""
		    }
	    ]
    }

    Here is an example of output : 

    {
    	"id": "campfire_shared_hope",
	    "name": "A Glimmer of Hope",
    	"description": "Around the crackling campfire, [Name 0] and [Name 1] share tales of the harsh road. Despite the grim talk, a quiet understanding forms. 'It's... less lonely, traveling with others,' [Name 1] admits softly.",
	    "possibilities": [
    		{
		    	"id": "leave",
	    		"description": "Offer [Name 1] the last piece of your dried fruit.",
    		},
		    {
	    		"id": "leave",
    			"description": "Share a genuinely hopeful story from before the hard times.",
			    "outcome_hint": "[Name 1] relationship +1 (Trust), [Name 1] morale boost."
		    },
	    	{
    			"id": "leave",
			    "description": "Nod quietly and retreat into your own thoughts.",
			    "outcome_hint": "No relationship change, missed opportunity for bonding."
		    }
	    ]
    }

     """

    var full_prompt = system_message + "\n\n" + user_request + "\n\n" + json_format_instruction

    var payload = {
        "prompt" : full_prompt,
        "temperature": 0.7
    }

    var body_string = JSON.stringify(payload)
    
    var error = http_request.request(api_endpoint, headers, HTTPClient.METHOD_POST, body_string)

    if error != OK:
        var error_message = "LLM_Communicator: HTTPRequest initiation failed with error code: " + str(error)
        printerr(error_message)
        emit_signal("error_received", error_received)

func _on_request_completed(result, response_code, _headers, body) :
    if result != HTTPRequest.RESULT_SUCCESS:
        var error_message = "LLM_Communicator: HTTPRequest failed. Result code: " + str(result)
		# Specific check for connection error
        if result == HTTPRequest.RESULT_CANT_CONNECT:
            error_message += " - Could not connect to the Python server at " + api_endpoint + ". Is hf_server.py running?"
        printerr(error_message)
        emit_signal("error_received", error_message)
        return

    if response_code < 200 or response_code >= 300 :
        var error_message = "LLM_Communicator: Received non-success HTTP status code: " + str(response_code)
        printerr(error_message)
		# Attempt to get error details from the body if available
        var server_error_details = body.get_string_from_utf8()
        printerr("Server Response Body: ", server_error_details)
        emit_signal("error_received", error_message + " | Server response: " + server_error_details)
        return

    var json_string_from_server = body.get_string_from_utf8()
    var server_response_parse = JSON.parse_string(json_string_from_server)

    if server_response_parse == null:
        var error_message = "LLM_Communicator: Failed to parse JSON response from Flask server."
        printerr(error_message)
        printerr("Raw server response: ", json_string_from_server)
        emit_signal("error_received", error_message)
        return

    if not server_response_parse is Dictionary:
        var error_message = "LLM_Communicator: Unexpected response format from Flask server (expected JSON Dictionary)."
        printerr(error_message)
        printerr("Parsed server response: ", server_response_parse)
        emit_signal("error_received", error_message)
        return

    if server_response_parse.has("error"):
        var server_error = server_response_parse["error"]
        var error_message = "LLM_Communicator: Python server reported an error: " + str(server_error)
        printerr(error_message)
        emit_signal("error_received", error_message)
        return

    if not server_response_parse.has("generated_text"):
        var error_message = "LLM_Communicator: Response from Flask server is missing 'generated_text' field."
        printerr(error_message)
        printerr("Parsed server response: ", server_response_parse)
        emit_signal("error_received", error_message)
        return

    var llm_generated_string = server_response_parse["generated_text"]
    var final_data_parse = JSON.parse_string(llm_generated_string)

    if final_data_parse == null:
        var error_message = "LLM_Communicator: Failed to parse the JSON content generated by the LLM. The LLM likely did not follow the format instruction."
        printerr(error_message)
        printerr("LLM's raw output string: ", llm_generated_string)
        emit_signal("error_received", error_message + " | LLM Raw Output: " + llm_generated_string)
        return

    if not final_data_parse is Dictionary:
        var error_message = "LLM_Communicator: Parsed LLM content is not a Dictionary as expected."
        printerr(error_message)
        printerr("Parsed LLM data: ", final_data_parse)
        emit_signal("error_received", error_message)
        return

    print("LLM_Communicator: Successfully received and parsed content.")
    print("Final Data: ", final_data_parse) # Optional: Print the successful data
    emit_signal("content_received", final_data_parse)
    

### overworld.gd ###
extends TileMap
class_name Overworld

@onready var player = $player

@onready var gall = $gall
@onready var cauldron_mountains = $cauldron_mountains
@onready var whispering_hollow = $whispering_hollow

@onready var party_ui: PartyUI = $UI/party_ui
@onready var quest_log_ui: QuestLogUI = $UI/quest_log_ui
@onready var skill_ui: SkillUI = $UI/skill_ui
@onready var gold_amount = $UI/gold/gold_amount

@onready var game_state: GameState = $"/root/game_state"
@onready var content_generator: ContentGenerator = $"/root/content_generator"
@onready var event_manager: EventManager
@onready var quest_manager: QuestManager

@export var testing = false

var oddr_direction_differences = [
	[[+1,  0], [ 0, -1], [-1, -1], 
	 [-1,  0], [-1, +1], [ 0, +1]],
	
	[[+1,  0], [+1, -1], [ 0, -1], 
	 [-1,  0], [ 0, +1], [+1, +1]],
]

var nature_walkable_cells = [0, 1, 2, 6, 7, 8, 9, 10, 11, 14, 15, 16]

var next_random_event: Dictionary

func _ready():
	event_manager = EventManager.new($UI/event_ui, $UI/fight_ui, game_state)
	quest_manager = QuestManager.new()

	gall.body_entered.connect(_toggle_event_ui.bind("gall"))
	cauldron_mountains.body_entered.connect(_toggle_event_ui.bind("cauldron_mountains"))
	whispering_hollow.body_entered.connect(_toggle_event_ui.bind("whispering_hollow"))

	$UI/party_button.pressed.connect(_toggle_party_ui)
	$UI/party_button.pressed.connect(AudioManager.play_sfx.bind(AudioManager.UI_SCREEN_OPEN))

	$UI/quest_log_button.pressed.connect(_toggle_questlog_ui)
	$UI/quest_log_button.pressed.connect(AudioManager.play_sfx.bind(AudioManager.UI_SCREEN_OPEN))

	party_ui.fire_character.connect(_on_fire_character)
	party_ui.show_skill_tree.connect(_on_show_skill_tree)

	content_generator.content_received.connect(_on_content_received)
	var initial_random_event_prompt = "Generate a random event for the following party of adventurers : "
	for i in range(game_state.party.size()) :
		initial_random_event_prompt += "\n" + game_state.party[i].to_string()
	content_generator.request_content(initial_random_event_prompt)

	game_state.random_event.connect(_on_random_event)
	game_state.money_changed.connect(_on_money_changed)
	game_state.change_gold(100)
	
	if testing :
		game_state.accept_quest(1)
		game_state.new_candidate(PartyMember.new_rand())
		game_state.recruit_candidate()
		game_state.receive_experience(50000)

func oddr_offset_neighbor(hex, direction):
	var parity = hex.y & 1
	var diff = oddr_direction_differences[parity][direction]
	return Vector2(hex.x + diff[0], hex.y + diff[1])
	
func is_neighbour(hex, pos) : 
	var parity = hex.y & 1
	for i in range(0, 6) :
		var diff = oddr_direction_differences[parity][i]
		if Vector2i(hex.x + diff[0], hex.y + diff[1]) == pos : 
			return true
	return false
	
func can_walk(hex) : 
	return get_cell_source_id(0, hex) == 22 && get_cell_atlas_coords(0, hex).x in nature_walkable_cells
	
func _input(event):
	if game_state.in_event or game_state.in_ui :
		return
	if event is InputEventMouseButton :
		if event.button_index == MOUSE_BUTTON_LEFT && event.is_pressed():
			var click_pos = local_to_map(to_local(get_global_mouse_position()))
			var player_pos = local_to_map(to_local(player.global_position))
			
			if is_neighbour(player_pos, click_pos) && can_walk(click_pos): 
				player.move_to(map_to_local(click_pos))
				game_state.step_taken()

func toggle_ui(state: bool) : 
	$UI.visible = state

func disable_collisions(state: bool) : 
	$gall/CollisionShape2D.disabled = state
	$cauldron_mountains/CollisionShape2D.disabled = state
	$whispering_hollow/CollisionShape2D.disabled = state
	$player/CollisionShape2D.disabled = state
	
func _toggle_event_ui(_body, place_id: String): 
	event_manager.enter_event(place_id)
	
func _toggle_party_ui(): 
	party_ui.update_ui(game_state.party)
	party_ui.visible = not party_ui.visible
	quest_log_ui.visible = false
	game_state.in_ui = not game_state.in_ui
	
func _toggle_questlog_ui() :
	quest_log_ui.update_ui(game_state.quest_log)
	quest_log_ui.visible = not quest_log_ui.visible
	party_ui.visible = false
	game_state.in_ui = not game_state.in_ui
	
func _on_fire_character(index: int) : 
	game_state.fire_member(index)
	party_ui.update_ui(game_state.party)

func _on_show_skill_tree(index: int) : 
	skill_ui.update_ui(game_state.party[index])
	skill_ui.visible = true

func _on_content_received(data: Dictionary) :
	next_random_event = data
	
func _on_random_event() : 
	# if next_random_event.is_empty() :
	#	print("No random event available")
	#	return
	
	event_manager.random_event_manager(next_random_event)
	next_random_event = {}

	var party = game_state.party
	var prompt = """
	You are a creative game event generator for the Party RPG Omennis.
	Generate a brief but flavorful random event suitable for occurring during travel or at camp.
	The event should primarily feature an interaction between two party members, using placeholders like `[Name 0]` and `[Name 1]`.
	Make the event concise and entertaining, allowing for varied tones like tension, drama, humor, bonding, or discovery.

	The event description must lead into 2-3 distinct player choices ('possibilities').
	For each possibility, provide:
	- The id of the choice, which must always be `leave`, which means that the event is only a single panel.
	- A short `description` of the choice presented to the player.

	Ensure your final output will contain values for:
	- A unique event `id` (lowercase_snake_case, e.g., 'campfire_argument').
	- A short event `name` (Title Case, e.g., 'Heated Words').
	- The main event `description` (using the placeholders `[Name 0]` and `[Name 1]`).
	- The array named `possibilities` containing the choices as described above.
	"""
	var context_info = "The party consists of the following characters: \n"
	for i in range(party.size()) :
		context_info += "\n" + party[i]._to_string()
		context_info += "\n\n"
	context_info += "Current money: " + str(game_state.party_money) + "g"
	context_info += "\n\n"
	context_info += "Current quests: \n"
	for quest in game_state.quest_log.keys() : 
		var quest_info = load("res://text/quests/" + "%03d" % quest + ".json").data
		context_info += "\n" + quest_info.name + "\n"
		context_info += "Difficulty: {difficulty} \n" + \
			"Location: {location} \n" + \
			"Description: {description} \n" + \
			"Reward: {reward} \n".format({"difficulty" : quest_info.difficulty, "location" : quest_info.location,
			"description": quest_info.description, "reward": quest_info.reward})


	content_generator.request_content(prompt, context_info)
	
func _on_money_changed() : 
	gold_amount.text = str(game_state.party_money) + "g"


### place.gd ###
extends Area2D



### player.gd ###
extends CharacterBody2D

var target = null

@export var speed = 800
@onready var footstep_player: AudioStreamPlayer2D = $footstep_player
const FOOTSTEP_SFX = [
	preload("res://audio/sfx/character/footstep_dirt_01.wav"),
	preload("res://audio/sfx/character/footstep_dirt_02.wav"),
]

signal target_reached

func move_to(new_target) : 
	if not target :
		if not FOOTSTEP_SFX.is_empty():
			footstep_player.stream = FOOTSTEP_SFX[randi() % FOOTSTEP_SFX.size()]
			footstep_player.play()
		target = new_target

func _physics_process(_delta):
	if not target : 
		return
	velocity = position.direction_to(target) * speed
	if position.distance_to(target) > 50:
		move_and_slide()
	else :
		position = target
		target_reached.emit()
		target = null

func toggle_camera(focus: bool = false) : 
	$Camera2D.enabled = focus


### basic_slash.gd ###
extends Skill
class_name BasicSlash

var damage_mult := 2
var max_cooldown := 2

func use_skill(from: CombatCharacter, skill_pos: Vector2i, map: CombatMap) -> bool:
	var skill_target = map.get_character(skill_pos)
	if not is_valid_target_type(from, skill_target) or HexHelper.distance(map.get_cell_coords(from.global_position), skill_pos) > get_skill_range():
		return false

	from.deal_damage(skill_target, damage_mult)
	from.attack(map.to_local(skill_target.global_position))
	cooldown = max_cooldown
	skill_finished.emit()

	return true

func score_action(from: CombatCharacter, potential_targets: Array[CombatCharacter], _target_cell: Vector2i, _map: CombatMap) -> float:
	if potential_targets.is_empty(): return 0.0 # Cannot score without a target
	var target = potential_targets[0] # Basic slash is single target

	var score = AIScoringWeights.WEIGHT_BASE_MELEE # Base score for a possible action
	var potential_damage = from.get_damage() * damage_mult

	score += potential_damage * AIScoringWeights.WEIGHT_DAMAGE

	# Bonus for finishing blow
	if target.health <= potential_damage:
		score += AIScoringWeights.WEIGHT_KILL_BONUS
	else:
		# Bonus for damaging low health targets
		score += (1.0 - (target.health / target.max_health)) * potential_damage * AIScoringWeights.WEIGHT_DAMAGE_PER_HP

	# Penalty for hitting heavily shielded targets
	score -= target.shield * AIScoringWeights.WEIGHT_SHIELD_ENEMY

	return score

func generate_targets(caster: CombatCharacter, map: CombatMap) -> Array[TargetInfo]:
	var targets: Array[TargetInfo] = []
	var caster_pos = map.get_cell_coords(caster.global_position)
	var potential_cells = HexHelper.hex_reachable(caster_pos, get_skill_range(), map.can_walk)

	for cell in potential_cells:
		if cell != caster_pos: # Can't target self cell
			var target_char = map.get_character(cell)
			if target_char and is_valid_target_type(caster, target_char):
				targets.append(TargetInfo.new(
					TargetInfo.TargetType.CHARACTER,
					target_char,
					cell,
					[target_char] # Affected target is just the primary target
				))
	return targets
	
func get_skill_name() -> String:
	return "Basic Slash"

func get_skill_description() -> String:
	return "A basic attack that deals 10 damage to a nearby enemy. \n" + \
		"Cooldown: " + str(max_cooldown) + " turns.\n" + \
		"Range: " + str(get_skill_range()) + " cells.\n"

func get_skill_icon() -> Texture:
	return load("res://assets/ui/skills/basic_slash.png")

func get_skill_range() -> int:
	return 1

func target_allies() -> bool:
	return false

func target_enemies() -> bool:
	return true

func target_self() -> bool:
	return false
	
func is_melee() -> bool:
	return true

### firespark.gd ###
extends Skill
class_name Firespark

var damage_mult : int = 1
var max_cooldown : int = 3

const firespark_scene = preload("res://scenes/projectile_effect.tscn")
var caster: CombatCharacter
var target: CombatCharacter
var curr_firespark: ProjectileEffect
var curr_highlighted_cells: Array[Vector2i] = []

func use_skill(from: CombatCharacter, skill_pos: Vector2i, map: CombatMap) -> bool:
	var skill_target = map.get_character(skill_pos)
	if not is_valid_target_type(from, skill_target) or HexHelper.distance(map.get_cell_coords(from.global_position), skill_pos) > get_skill_range():
		return false

	caster = from
	target = skill_target

	curr_firespark = firespark_scene.instantiate()
	from.get_parent().add_child(curr_firespark)
	curr_firespark.scale = Vector2(1.5, 1.5) 
	curr_firespark.speed = 1500.0
	curr_firespark.position = from.position
	curr_firespark.set_target_position(target.position)
	curr_firespark.target_reached.connect(_on_reached_target)

	cooldown = max_cooldown
	return true

func score_action(from: CombatCharacter, potential_targets: Array[CombatCharacter], target_cell: Vector2i, map: CombatMap) -> float:
	if potential_targets.is_empty(): return 0.0
	var curr_target = potential_targets[0]

	var score = AIScoringWeights.WEIGHT_BASE_RANGED # Ranged attacks are generally safer/valuable
	var potential_damage = from.get_damage() * damage_mult
	score += potential_damage * AIScoringWeights.WEIGHT_DAMAGE

	if curr_target.health <= potential_damage:
		score += AIScoringWeights.WEIGHT_KILL_BONUS
	else:
		score += (1.0 - (curr_target.health / curr_target.max_health)) * potential_damage * AIScoringWeights.WEIGHT_DAMAGE_PER_HP

	score -= curr_target.shield * AIScoringWeights.WEIGHT_SHIELD_ENEMY

	# Bonus for range - less valuable if target is already close?
	var dist = HexHelper.distance(map.get_cell_coords(from.global_position), target_cell)
	if dist > 1:
		score += dist * AIScoringWeights.WEIGHT_SKILL_DISTANCE # Slight preference for using range

	return score

func generate_targets(from: CombatCharacter, map: CombatMap) -> Array[TargetInfo]:
	var targets: Array[TargetInfo] = []
	var caster_pos = map.get_cell_coords(from.global_position)
	var potential_cells = HexHelper.hex_reachable(caster_pos, get_skill_range(), map.can_walk)

	for cell in potential_cells:
		if cell != caster_pos:
			var target_char = map.get_character(cell)
			if target_char and is_valid_target_type(from, target_char):
				targets.append(TargetInfo.new(
					TargetInfo.TargetType.CHARACTER,
					target_char,
					cell,
					[target_char]
				))
	return targets
	
func get_skill_name() -> String:
	return "Firespark"

func get_skill_description() -> String:
	return "A basic fire attack that deals " + str(damage_mult) + " damage to a nearby enemy. \n" + \
		"Cooldown: " + str(max_cooldown) + " turns.\n" + \
		"Range: " + str(get_skill_range()) + " cells.\n"

func get_skill_icon() -> Texture:
	return load("res://assets/ui/skills/firespark.png")

func get_skill_range() -> int:
	return 4

func target_allies() -> bool:
	return false

func target_enemies() -> bool:
	return true

func target_self() -> bool:
	return false
	
func is_melee() -> bool:
	return false

func _on_reached_target(): 
	target.take_damage(damage_mult * caster.get_damage())
	curr_firespark.queue_free()
	skill_finished.emit()

func highlight_targets(_from: CombatCharacter, _map: CombatMap) -> Array[Vector2i]:
	return []

func highlight_mouse_pos(from: CombatCharacter, mouse_pos: Vector2i, map: CombatMap) -> Array[Vector2i]:
	curr_highlighted_cells = HexHelper.fov(map.get_cell_coords(from.global_position), mouse_pos, map.can_walk) 
	for cell in curr_highlighted_cells: 
		if HexHelper.distance(map.get_cell_coords(from.global_position), cell) > get_skill_range():
			curr_highlighted_cells.erase(cell)
			continue
		var cell_char = map.get_character(cell)
		if cell_char and cell_char is AICombatCharacter:
			map.set_cell(0, cell, 22, map.get_cell_atlas_coords(0, cell), 5)
		else :
			map.set_cell(0, cell, 22, map.get_cell_atlas_coords(0, cell), 3)
		

	return curr_highlighted_cells


### melee_skill.gd ###
extends Skill
class_name MeleeSkill

var curr_highlighted_cells: Array[Vector2i] = []

func get_skill_range() -> int:
	return 1
	
func is_melee() -> bool:
	return true

func highlight_targets(from: CombatCharacter, map: CombatMap) -> Array[Vector2i]:
	var can_attack = func(hex: Vector2i): return map.can_walk(hex) && map.get_character(hex) and map.get_character(hex) is AICombatCharacter
	curr_highlighted_cells = HexHelper.hex_reachable(map.get_cell_coords(from.global_position), get_skill_range(), can_attack)

	for cell in curr_highlighted_cells:
		map.set_cell(0, cell, 22, map.get_cell_atlas_coords(0, cell), 3)
		var character = map.get_character(cell)
		if character and character is AICombatCharacter:
			map.set_cell(0, cell, 22, map.get_cell_atlas_coords(0, cell), 4)

	return curr_highlighted_cells

func highlight_mouse_pos(_from: CombatCharacter, mouse_pos: Vector2i, map: CombatMap) -> Array[Vector2i]:
	for cell in curr_highlighted_cells:
		map.set_cell(0, cell, 22, map.get_cell_atlas_coords(0, cell), 3)

		var cell_character = map.get_character(cell)
		if cell_character and cell_character is AICombatCharacter:
			map.set_cell(0, cell, 22, map.get_cell_atlas_coords(0, cell), 4)
			if mouse_pos == cell:
				map.set_cell(0, cell, 22, map.get_cell_atlas_coords(0, cell), 5)
			
	return curr_highlighted_cells



### skill.gd ###
class_name Skill

var cooldown: int
signal skill_finished()

## Skill functions

##
## Decrease the cooldown of the skill by 1
##
func decrease_cooldown():
	if cooldown > 0:
		cooldown -= 1

##
## Make _from use the skill on _target. This function should be overriden by the child class
##
## [code] _from [/code]: The CombatCharacter that is using the skill
## [code] _target [/code]: The CombatCharacter that is being targeted by the skill
## [code] return [/code]: Whether the skill was successfully used
##
func use_skill(_from: CombatCharacter, _skill_pos: Vector2i, _map: CombatMap) -> bool :
	assert(false, "function not implemented")
	return false

##
## Get the name of the skill
##
func get_skill_name() -> String:
	assert(false, "function not implemented")
	return ""

##
## Get the description of the skill
##
func get_skill_description() -> String:
	assert(false, "function not implemented")
	return ""

##
## Get the icon of the skill
##
func get_skill_icon() -> Texture:
	assert(false, "function not implemented")
	return null

##
## Get the range of the skill
##
func get_skill_range() -> int:
	assert(false, "function not implemented")
	return -1

##
## Get whether the skill targets allies, enemies, or self
##
func target_allies() -> bool:
	assert(false, "function not implemented")
	return false

func target_enemies() -> bool:
	assert(false, "function not implemented")
	return false

func target_self() -> bool:
	assert(false, "function not implemented")
	return false

##
## Checks if 'target' is a valid type (enemy/ally) for 'skill' cast by 'from'.
## Does NOT check range or if target is null.
##
func is_valid_target_type(from: CombatCharacter, target: CombatCharacter) -> bool:
	if not from or not target: return false 

	if target_enemies():
		if (from is PlayerCombatCharacter and target is AICombatCharacter) or \
		   (from is AICombatCharacter and target is PlayerCombatCharacter):
			return true

	if target_allies():
		if target != from and ( \
		   (from is PlayerCombatCharacter and target is PlayerCombatCharacter) or \
		   (from is AICombatCharacter and target is AICombatCharacter) ):
			return true

	if target_self():
		if target == from:
			return true
			
	return false

func score_action(_from: CombatCharacter, _potential_targets: Array[CombatCharacter], _target_cell: Vector2i, _map: CombatMap) -> float:
	# Base implementation - should be overridden by subclasses
	# Returns a low score if not overridden, indicating low priority or error
	printerr("score_action not implemented for skill: ", get_skill_name())
	return 0.1

##
## Generates all possible valid initiation targets/locations for this skill
## from the perspective of the 'caster' on the current 'map'.
## Returns an Array of TargetInfo objects.
##
func generate_targets(_caster: CombatCharacter, _map: CombatMap) -> Array[TargetInfo]:
	printerr("generate_targets() not implemented for skill: ", get_skill_name())
	return []

##
## Get the remaining cooldown of the skill
##
func get_cooldown() -> int:
	return cooldown

func highlight_targets(_from: CombatCharacter, _map: CombatMap) -> Array:
	assert(false, "function not implemented")
	return []

func highlight_mouse_pos(_from: CombatCharacter, _mouse_pos: Vector2i, _map: CombatMap) -> Array:
	assert(false, "function not implemented")
	return []

##
## Get whether the skill is a melee skill
##
func is_melee() -> bool:
	assert(false, "function not implemented")
	return false

static func _get_characters_in_aoe(center_cell: Vector2i, radius: int, map: CombatMap) -> Array[CombatCharacter]:
	var characters_hit: Array[CombatCharacter] = []
	if radius < 0: return characters_hit # Safety check
	var impact_cells = HexHelper.hex_reachable(center_cell, radius, map.can_walk)
	for cell in impact_cells:
		var char_in_impact = map.get_character(cell)
		if char_in_impact:
			characters_hit.append(char_in_impact)
	return characters_hit


### sprint.gd ###
extends Skill
class_name Sprint

var damage := 0
var max_cooldown := 2
var curr_highlighted_cells: Array[Vector2i] = []

func use_skill(from: CombatCharacter, skill_pos: Vector2i, map: CombatMap) -> bool:
	if map.can_walk(skill_pos) and !map.cell_occupied(skill_pos) and HexHelper.distance(map.get_cell_coords(from.global_position), skill_pos) <= get_skill_range():
		from.move_to(map.map_to_local(skill_pos))
		cooldown = max_cooldown
		return true

	return false
	
func get_skill_name() -> String:
	return "Sprint"

func get_skill_description() -> String:
	return "Move quickly to a nearby empty space."

func get_skill_icon() -> Texture:
	return load("res://assets/ui/skills/sprint.png")

func get_skill_range() -> int:
	return 2

func target_allies() -> bool:
	return false

func target_enemies() -> bool:
	return false

func target_self() -> bool:
	return false
	
func is_melee() -> bool:
	return true

func highlight_targets(from: CombatCharacter, map: CombatMap) -> Array[Vector2i]:
	var can_sprint_to = func(hex: Vector2i): return map.can_walk(hex) and !map.cell_occupied(hex)
	curr_highlighted_cells = HexHelper.hex_reachable(map.get_cell_coords(from.global_position), get_skill_range(), can_sprint_to)
	curr_highlighted_cells.erase(map.get_cell_coords(from.global_position))
	for cell in curr_highlighted_cells:
		map.set_cell(0, cell, 22, map.get_cell_atlas_coords(0, cell), 1)

	return curr_highlighted_cells

func highlight_mouse_pos(_from: CombatCharacter, mouse_pos: Vector2i, map: CombatMap) -> Array[Vector2i]:
	for cell in curr_highlighted_cells:
		map.set_cell(0, cell, 22, map.get_cell_atlas_coords(0, cell), 1)
		if mouse_pos == cell:
			map.set_cell(0, cell, 22, map.get_cell_atlas_coords(0, cell), 2)
			
	return curr_highlighted_cells


### target_info.gd ###
# target_info.gd (or within skill.gd)
class_name TargetInfo

enum TargetType {
	CHARACTER,          # Targets a specific character (e.g., Basic Slash, Firespark)
	CELL,               # Targets an empty cell (e.g., Sprint)
	AOE_LOCATION,       # Targets a cell as the center of an AoE (e.g., Meteor)
	SELF_CAST,          # Targets only the caster (e.g., Defensive Stance, Molten Blade)
	SELF_AOE_ACTIVATION # Activates an AoE centered on the caster (e.g., Whirlwind, Soul Harvest)
}

var type: TargetType
var primary_target: CombatCharacter        # The main char target/caster (null for CELL, AOE_LOCATION)
var target_cell: Vector2i            # The cell being targeted or the center of the AoE
var affected_targets: Array[CombatCharacter] # Pre-calculated list of characters hit by this specific action

func _init(p_type: TargetType, p_target: CombatCharacter, p_cell: Vector2i, p_affected: Array[CombatCharacter]):
	type = p_type
	primary_target = p_target
	target_cell = p_cell
	affected_targets = p_affected

func _to_string() -> String: # Optional: for debugging
	return "TargetInfo(Type: %s, Cell: %s, Primary: %s, Affected: %s)" % [TargetType.keys()[type], str(target_cell), primary_target.character.character_name if primary_target else "None", str(affected_targets.size())]

### arcane_shield.gd ###
extends Skill
class_name ArcaneShield

var duration := 2
var max_cooldown := 3
var curr_highlighted_cells: Array[Vector2i] = []

func use_skill(from: CombatCharacter, skill_pos: Vector2i, map: CombatMap) -> bool:
	var skill_target = map.get_character(skill_pos)
	var caster_pos = map.get_cell_coords(from.global_position)

	if not is_valid_target_type(from, skill_target) or HexHelper.distance(caster_pos, skill_pos) > get_skill_range():
		return false

	skill_target.gain_status("defensive", duration + 1 if skill_target == from else duration)

	cooldown = max_cooldown
	skill_finished.emit()
	return true

func score_action(_from: CombatCharacter, potential_targets: Array[CombatCharacter], _target_cell: Vector2i, map: CombatMap) -> float:
	if potential_targets.is_empty(): return 0.0
	var target = potential_targets[0] # Single target buff

	var score = AIScoringWeights.WEIGHT_BUFF_POSITIVE # Base value of defensive buff

	var health_percent = target.health / target.max_health

	# More valuable on lower health targets
	score += (1.0 - health_percent) * AIScoringWeights.WEIGHT_HEAL_LOW_HP_BONUS * 0.5 # Use heal bonus weight but toned down

	# More valuable if target is likely to be attacked (e.g., is close to enemies)
	var nearby_enemies = 0
	var target_pos = map.get_cell_coords(target.global_position)
	for p in map.get_alive_party_members(): 
		if HexHelper.distance(target_pos, map.get_cell_coords(p.global_position)) <= 2:
			nearby_enemies+=1
	score += nearby_enemies * 5.0

	# Bonus if target currently has 'vulnerable' status
	if target.char_statuses["vulnerable"] > 0:
		score += AIScoringWeights.WEIGHT_SETUP_BONUS

	return score

func generate_targets(caster: CombatCharacter, map: CombatMap) -> Array[TargetInfo]:
	var targets: Array[TargetInfo] = []
	var caster_pos = map.get_cell_coords(caster.global_position)
	var potential_cells = HexHelper.hex_reachable(caster_pos, get_skill_range(), func (_hex): return true).filter(map.can_walk)

	for cell in potential_cells:
		var target_char = map.get_character(cell)
		# Check if the character is self OR a valid ally target
		if target_char and is_valid_target_type(caster, target_char):
			targets.append(TargetInfo.new(
				TargetInfo.TargetType.CHARACTER, # Targeting a specific character (self or ally)
				target_char,
				cell,
				[target_char] # The buff affects the targeted character
			))
	return targets


func get_skill_name() -> String:
	return "Arcane Shield"

func get_skill_description() -> String:
	return "Create a magical shield around an ally or yourself that reduces incoming damage by 50% for " + str(duration) + " turn. \n" + \
		"Cooldown: " + str(max_cooldown) + " turns.\n" + \
		"Range: " + str(get_skill_range()) + " cells."

func get_skill_icon() -> Texture:
	return load("res://assets/ui/skills/arcane_shield.png") 

func get_skill_range() -> int:
	return 2

func target_allies() -> bool:
	return true

func target_enemies() -> bool:
	return false

func target_self() -> bool:
	return true

func is_melee() -> bool:
	return false

func highlight_targets(from: CombatCharacter, map: CombatMap) -> Array[Vector2i]:
	var caster_pos = map.get_cell_coords(from.global_position)
	var can_target = func(hex: Vector2i): return map.can_walk(hex)
	curr_highlighted_cells = HexHelper.hex_reachable(caster_pos, get_skill_range(), can_target)

	var valid_targets: Array[Vector2i] = []
	for cell in curr_highlighted_cells:
		map.set_cell(0, cell, 22, map.get_cell_atlas_coords(0, cell), 6)
		var character = map.get_character(cell)
		if cell == caster_pos or (character and character is PlayerCombatCharacter):
			map.set_cell(0, cell, 22, map.get_cell_atlas_coords(0, cell), 7)
			valid_targets.append(cell)
		elif character and character is AICombatCharacter:
			map.set_cell(0, cell, 22, map.get_cell_atlas_coords(0, cell), 0) 

	curr_highlighted_cells = valid_targets
	return curr_highlighted_cells

func highlight_mouse_pos(from: CombatCharacter, mouse_pos: Vector2i, map: CombatMap) -> Array[Vector2i]:
	var caster_pos = map.get_cell_coords(from.global_position)
	# Re-highlight potential range first
	var potential_cells = HexHelper.hex_reachable(caster_pos, get_skill_range(), func(hex: Vector2i): return map.can_walk(hex))
	for cell in potential_cells:
		map.set_cell(0, cell, 22, map.get_cell_atlas_coords(0, cell), 6)

	# Highlight actual targets and hover effect
	for cell in curr_highlighted_cells: # Iterate only over valid targets
		var character = map.get_character(cell)
		var is_self = (cell == caster_pos)
		var is_ally = character and character is PlayerCombatCharacter

		if is_self or is_ally:
			map.set_cell(0, cell, 22, map.get_cell_atlas_coords(0, cell), 7)
			if mouse_pos == cell:
				map.set_cell(0, cell, 22, map.get_cell_atlas_coords(0, cell), 8)

	return curr_highlighted_cells


### blink.gd ###
# blink.gd
extends Skill
class_name Blink

var max_cooldown: int = 5
var blink_range: int = 3
var next_spell_damage_bonus: int = 10 # +10 damage

func use_skill(caster: CombatCharacter, target_cell: Vector2i, map: CombatMap) -> bool:
	var caster_pos = map.get_cell_coords(caster.global_position)

	if HexHelper.distance(caster_pos, target_cell) > blink_range or \
	   not map.can_walk(target_cell) or map.cell_occupied(target_cell):
		return false # Invalid target cell
	caster.position = map.map_to_local(target_cell) # Actual instant position update
	caster.gain_status("imbue", 2, next_spell_damage_bonus)

	cooldown = max_cooldown
	skill_finished.emit()
	return true

func score_action(caster: CombatCharacter, _affected_targets: Array[CombatCharacter], target_cell: Vector2i, map: CombatMap) -> float:
	var score = AIScoringWeights.WEIGHT_BASE_MOBILITY

	# Score based on tactical advantage of the new position
	var caster_current_pos = map.get_cell_coords(caster.global_position)
	var enemies = [] # Get enemy list (e.g., map.get_alive_enemies_of(caster))
	for chara in map.characters: # Simplified enemy finding
		if chara is PlayerCombatCharacter : enemies.append(chara)

	# 1. Safety: Increase score if moving away from more enemies than moving towards
	var enemies_near_current = 0
	var enemies_near_target_cell = 0
	for enemy in enemies:
		var enemy_pos = map.get_cell_coords(enemy.global_position)
		if HexHelper.distance(caster_current_pos, enemy_pos) <= 2: enemies_near_current += 1
		if HexHelper.distance(target_cell, enemy_pos) <= 2: enemies_near_target_cell += 1
	
	if enemies_near_target_cell < enemies_near_current:
		score += (enemies_near_current - enemies_near_target_cell) * AIScoringWeights.WEIGHT_POSITIONING_SAFETY

	# 2. Offensive Positioning: Increase score if moving towards more enemies in range
	var targets_in_range_from_new_pos = 0
	var ranged = 4
	for enemy in enemies:
		if HexHelper.distance(target_cell, map.get_cell_coords(enemy.global_position)) > 1 and \
		   HexHelper.distance(target_cell, map.get_cell_coords(enemy.global_position)) <= ranged:
			targets_in_range_from_new_pos +=1
	score += targets_in_range_from_new_pos * 3.0

	# 3. Value the spell damage bonus
	# Estimate value: if there's a good target, the bonus is valuable.
	if not enemies.is_empty():
		score += (caster.get_damage() + next_spell_damage_bonus) * AIScoringWeights.WEIGHT_DAMAGE * 0.5 # Half weight for potential damage

	# Don't blink if already in a very safe/good spot and no offensive gain
	if enemies_near_current == 0 and targets_in_range_from_new_pos == 0 :
		score *= 0.1

	return score

func generate_targets(caster: CombatCharacter, map: CombatMap) -> Array[TargetInfo]:
	var targets: Array[TargetInfo] = []
	var caster_pos = map.get_cell_coords(caster.global_position)
	var potential_blink_cells = HexHelper.hex_reachable(caster_pos, blink_range, func (_hex): return true) \
		.filter(func(cell): return map.can_walk(cell) and cell != caster_pos and not map.cell_occupied(cell))
	print(potential_blink_cells)
	for cell in potential_blink_cells:
		targets.append(TargetInfo.new(
			TargetInfo.TargetType.CELL,
			null,
			cell,
			[] # No characters directly affected by targeting the cell
		))
	return targets

func get_skill_name() -> String: return "Blink"
func get_skill_description() -> String:
	return "Instantly teleport to an empty cell (Range: %d). Next turn, your base damage is increased by %d." % [blink_range, next_spell_damage_bonus] + \
		   "\nCooldown: %d turns." % max_cooldown
func get_skill_icon() -> Texture: return load("res://assets/ui/skills/blink.png") # Placeholder
func get_skill_range() -> int: return blink_range

func target_allies() -> bool: return false
func target_enemies() -> bool: return false
func target_self() -> bool: return false # Targets a cell

func is_melee() -> bool: return false

func highlight_targets(from: CombatCharacter, map: CombatMap) -> Array[Vector2i]:
	var caster_pos = map.get_cell_coords(from.global_position)
	var curr_highlighted_cells = HexHelper.hex_reachable(caster_pos, blink_range, map.can_walk)

	for cell in curr_highlighted_cells:
		if cell != caster_pos and not map.cell_occupied(cell):
			map.set_cell(0, cell, 22, map.get_cell_atlas_coords(0, cell), 1)

	return curr_highlighted_cells

func highlight_mouse_pos(from: CombatCharacter, mouse_pos: Vector2i, map: CombatMap) -> Array[Vector2i]:
	map.reset_map()
	var caster_pos = map.get_cell_coords(from.global_position)
	var curr_highlighted_cells = HexHelper.hex_reachable(caster_pos, blink_range, map.can_walk)

	for cell in curr_highlighted_cells:
		if cell != caster_pos and not map.cell_occupied(cell):
			map.set_cell(0, cell, 22, map.get_cell_atlas_coords(0, cell), 1) # Highlight valid cells

	# If mouse is over a valid target cell, highlight it
	if mouse_pos in curr_highlighted_cells:
		map.set_cell(0, mouse_pos, 22, map.get_cell_atlas_coords(0, mouse_pos), 2) # Highlight hovered target cell
	return curr_highlighted_cells


### firespark.gd ###
extends Skill
class_name FiresparkMage

var damage_mult : float = 1.0
var max_cooldown : int = 1

const firespark_scene = preload("res://scenes/projectile_effect.tscn")
var caster: CombatCharacter
var target: CombatCharacter
var curr_firespark: ProjectileEffect
var curr_highlighted_cells: Array[Vector2i] = []

func use_skill(from: CombatCharacter, skill_pos: Vector2i, map: CombatMap) -> bool:
	var skill_target = map.get_character(skill_pos)
	if not is_valid_target_type(from, skill_target) or HexHelper.distance(map.get_cell_coords(from.global_position), skill_pos) > get_skill_range():
		return false

	caster = from
	target = skill_target

	curr_firespark = firespark_scene.instantiate()
	from.get_parent().add_child(curr_firespark)
	curr_firespark.position = from.position
	curr_firespark.scale = Vector2(1.5, 1.5)
	curr_firespark.speed = 1500.0
	curr_firespark.set_target_position(target.position)
	curr_firespark.target_reached.connect(_on_reached_target)

	cooldown = max_cooldown
	return true

func score_action(from: CombatCharacter, potential_targets: Array[CombatCharacter], target_cell: Vector2i, map: CombatMap) -> float:
	if potential_targets.is_empty(): return 0.0
	var curr_target = potential_targets[0]

	var score = AIScoringWeights.WEIGHT_BASE_RANGED # Ranged attacks are generally safer/valuable
	var potential_damage = from.get_damage() * damage_mult
	score += potential_damage * AIScoringWeights.WEIGHT_DAMAGE

	if curr_target.health <= potential_damage:
		score += AIScoringWeights.WEIGHT_KILL_BONUS
	else:
		score += (1.0 - (curr_target.health / curr_target.max_health)) * potential_damage * AIScoringWeights.WEIGHT_DAMAGE_PER_HP

	score -= curr_target.shield * AIScoringWeights.WEIGHT_SHIELD_ENEMY

	# Bonus for range - less valuable if target is already close?
	var dist = HexHelper.distance(map.get_cell_coords(from.global_position), target_cell)
	if dist > 1:
		score += dist * AIScoringWeights.WEIGHT_SKILL_DISTANCE # Slight preference for using range

	return score

func generate_targets(from: CombatCharacter, map: CombatMap) -> Array[TargetInfo]:
	var targets: Array[TargetInfo] = []
	var caster_pos = map.get_cell_coords(from.global_position)
	var potential_cells = HexHelper.hex_reachable(caster_pos, get_skill_range(), map.can_walk)

	for cell in potential_cells:
		if cell != caster_pos:
			var target_char = map.get_character(cell)
			if target_char and is_valid_target_type(from, target_char):
				targets.append(TargetInfo.new(
					TargetInfo.TargetType.CHARACTER,
					target_char,
					cell,
					[target_char]
				))
	return targets

	
func get_skill_name() -> String:
	return "Firespark"

func get_skill_description() -> String:
	return "A basic fire attack that deals " + str(damage_mult) + " times your base damage to an enemy.\n" + \
		"Cooldown: " + str(max_cooldown) + " turns.\n" + \
		"Range: " + str(get_skill_range()) + " cells.\n" 

func get_skill_icon() -> Texture:
	return load("res://assets/ui/skills/firespark.png")

func get_skill_range() -> int:
	return 4

func target_allies() -> bool:
	return false

func target_enemies() -> bool:
	return true

func target_self() -> bool:
	return false
	
func is_melee() -> bool:
	return false

func _on_reached_target(): 
	caster.deal_damage(target, damage_mult)
	curr_firespark.queue_free()
	skill_finished.emit()

func highlight_targets(_from: CombatCharacter, _map: CombatMap) -> Array[Vector2i]:
	return []

func highlight_mouse_pos(from: CombatCharacter, mouse_pos: Vector2i, map: CombatMap) -> Array[Vector2i]:
	curr_highlighted_cells = HexHelper.fov(map.get_cell_coords(from.global_position), mouse_pos, map.can_walk) 
	for cell in curr_highlighted_cells: 
		if HexHelper.distance(map.get_cell_coords(from.global_position), cell) > get_skill_range():
			curr_highlighted_cells.erase(cell)
			continue
		var cell_char = map.get_character(cell)
		if cell_char and cell_char is AICombatCharacter:
			map.set_cell(0, cell, 22, map.get_cell_atlas_coords(0, cell), 5)
		else :
			map.set_cell(0, cell, 22, map.get_cell_atlas_coords(0, cell), 3)
		

	return curr_highlighted_cells


### frostbolt.gd ###
extends Skill
class_name Frostbolt
#TODO add root

var damage_mult := 2
var root_duration := 1
var max_cooldown := 3

const frostbolt_scene = preload("res://scenes/projectile_effect.tscn") # ASSUMPTION: You have a scene for the visual effect
var caster: CombatCharacter
var target: CombatCharacter
var curr_frostbolt: Node2D
var curr_highlighted_cells: Array[Vector2i] = []

func use_skill(from: CombatCharacter, skill_pos: Vector2i, map: CombatMap) -> bool:
	var skill_target = map.get_character(skill_pos)
	if not is_valid_target_type(from, skill_target) or HexHelper.distance(map.get_cell_coords(from.global_position), skill_pos) > get_skill_range():
		return false

	caster = from
	target = skill_target

	curr_frostbolt = frostbolt_scene.instantiate()
	from.get_parent().add_child(curr_frostbolt)
	curr_frostbolt.position = from.position
	curr_frostbolt.scale = Vector2(2.5, 2.5)
	curr_frostbolt.speed = 800.0
	curr_frostbolt.set_target_position(target.position)
	curr_frostbolt.target_reached.connect(_on_reached_target)

	cooldown = max_cooldown
	return true

func score_action(from: CombatCharacter, potential_targets: Array[CombatCharacter], target_cell: Vector2i, map: CombatMap) -> float:
	if potential_targets.is_empty(): return 0.0
	var potential_target = potential_targets[0]

	var score = AIScoringWeights.WEIGHT_BASE_RANGED
	var potential_damage = from.get_damage() * damage_mult
	score += potential_damage * AIScoringWeights.WEIGHT_DAMAGE

	if potential_target.health <= potential_damage:
		score += AIScoringWeights.WEIGHT_KILL_BONUS
	else:
		score += (1.0 - (potential_target.health / potential_target.max_health)) * potential_damage * AIScoringWeights.WEIGHT_DAMAGE_PER_HP

	# Significant bonus for the root/stun effect
	score += AIScoringWeights.WEIGHT_DISABLE_TURN * root_duration

	score -= potential_target.shield * AIScoringWeights.WEIGHT_SHIELD_ENEMY # 
	var dist = HexHelper.distance(map.get_cell_coords(from.global_position), target_cell)
	if dist > 1: score += dist * AIScoringWeights.WEIGHT_SKILL_DISTANCE

	return score

func generate_targets(from: CombatCharacter, map: CombatMap) -> Array[TargetInfo]:
	var targets: Array[TargetInfo] = []
	var caster_pos = map.get_cell_coords(from.global_position)
	var potential_cells = HexHelper.hex_reachable(caster_pos, get_skill_range(), map.can_walk)

	for cell in potential_cells:
		if cell != caster_pos:
			var target_char = map.get_character(cell)
			if target_char and is_valid_target_type(from, target_char):
				targets.append(TargetInfo.new(
					TargetInfo.TargetType.CHARACTER, target_char, cell, [target_char]
				))
	return targets



func _on_reached_target():
	caster.deal_damage(target, damage_mult)
	target.gain_status("rooted", root_duration)
	curr_frostbolt.queue_free()
	skill_finished.emit()

func get_skill_name() -> String:
	return "Frostbolt"

func get_skill_description() -> String:
	return "Deal " + str(damage_mult) + " times your base damage and root an enemy for " + str(root_duration) + " turn.\n" + \
		"Cooldown: " + str(max_cooldown) + " turns.\n" + \
		"Range: " + str(get_skill_range()) + " cells.\n"

func get_skill_icon() -> Texture:
	return load("res://assets/ui/skills/frostbolt.png") 

func get_skill_range() -> int:
	return 4

func target_allies() -> bool:
	return false

func target_enemies() -> bool:
	return true

func target_self() -> bool:
	return false

func is_melee() -> bool:
	return false

func highlight_targets(_from: CombatCharacter, _map: CombatMap) -> Array[Vector2i]:
	return []

func highlight_mouse_pos(from: CombatCharacter, mouse_pos: Vector2i, map: CombatMap) -> Array[Vector2i]:
	curr_highlighted_cells = HexHelper.fov(map.get_cell_coords(from.global_position), mouse_pos, map.can_walk) 
	for cell in curr_highlighted_cells: 
		if HexHelper.distance(map.get_cell_coords(from.global_position), cell) > get_skill_range():
			curr_highlighted_cells.erase(cell)
			continue
		var cell_char = map.get_character(cell)
		if cell_char and cell_char is AICombatCharacter:
			map.set_cell(0, cell, 22, map.get_cell_atlas_coords(0, cell), 5)
		else :
			map.set_cell(0, cell, 22, map.get_cell_atlas_coords(0, cell), 3)
		

	return curr_highlighted_cells



### thunderstrike.gd ###
extends Skill
class_name Thunderstrike

var damage_mult := 3
var stun_duration := 1
var max_cooldown := 5

const thunderstrike_scene = preload("res://scenes/impact_effect.tscn")
var caster: CombatCharacter
var target: CombatCharacter
var curr_thunderstrike: ImpactEffect
var curr_highlighted_cells: Array[Vector2i] = []


func use_skill(from: CombatCharacter, skill_pos: Vector2i, map: CombatMap) -> bool:
	var skill_target = map.get_character(skill_pos)
	if not is_valid_target_type(from, skill_target) or HexHelper.distance(map.get_cell_coords(from.global_position), skill_pos) > get_skill_range():
		return false

	caster = from
	target = skill_target

	curr_thunderstrike = thunderstrike_scene.instantiate()
	curr_thunderstrike.position = target.position
	target.get_parent().add_child(curr_thunderstrike)
	curr_thunderstrike.scale = Vector2(1.5, 1.5)
	curr_thunderstrike.set_impact_type("thunderstrike")

	curr_thunderstrike.animated_sprite.animation_looped.connect(_apply_effect)

	cooldown = max_cooldown
	return true

func score_action(from: CombatCharacter, potential_targets: Array[CombatCharacter], target_cell: Vector2i, map: CombatMap) -> float:
	if potential_targets.is_empty(): return 0.0
	var potential_target = potential_targets[0]

	var score = 10.0
	var potential_damage = from.get_damage() * damage_mult
	score += potential_damage * AIScoringWeights.WEIGHT_DAMAGE

	if potential_target.health <= potential_damage:
		score += AIScoringWeights.WEIGHT_KILL_BONUS
	else:
		score += (1.0 - (potential_target.health / potential_target.max_health)) * potential_damage * AIScoringWeights.WEIGHT_DAMAGE_PER_HP

	# Significant bonus for the stun effect
	score += AIScoringWeights.WEIGHT_DISABLE_TURN * stun_duration

	score -= potential_target.shield * 0.1
	var dist = HexHelper.distance(map.get_cell_coords(from.global_position), target_cell)
	if dist > 1: score += dist * 1.0

	return score

func generate_targets(from: CombatCharacter, map: CombatMap) -> Array[TargetInfo]:
	# Identical logic to Firespark/Frostbolt
	var targets: Array[TargetInfo] = []
	var caster_pos = map.get_cell_coords(from.global_position)
	var potential_cells = HexHelper.hex_reachable(caster_pos, get_skill_range(), map.can_walk)

	for cell in potential_cells:
		if cell != caster_pos:
			var target_char = map.get_character(cell)
			if target_char and is_valid_target_type(from, target_char):
				targets.append(TargetInfo.new(
					TargetInfo.TargetType.CHARACTER, target_char, cell, [target_char]
				))
	return targets

func _apply_effect():
	if is_instance_valid(target):
		caster.deal_damage(target, damage_mult)
		target.gain_status("stunned", stun_duration)

	skill_finished.emit()
	curr_thunderstrike.queue_free()

func get_skill_name() -> String:
	return "Thunderstrike"

func get_skill_description() -> String:
	return "Deal " + str(damage_mult) + " times your base damage to a single enemy and stun them for " + str(stun_duration) + " turn.\n" + \
		"Cooldown: " + str(max_cooldown) + " turns.\n" + \
		"Range: " + str(get_skill_range()) + " cells."

func get_skill_icon() -> Texture:
	return load("res://assets/ui/skills/thunderstrike.png") 

func get_skill_range() -> int:
	return 3

func target_allies() -> bool:
	return false

func target_enemies() -> bool:
	return true

func target_self() -> bool:
	return false

func is_melee() -> bool:
	return false

func highlight_targets(_from: CombatCharacter, _map: CombatMap) -> Array[Vector2i]:
	return []

func highlight_mouse_pos(from: CombatCharacter, mouse_pos: Vector2i, map: CombatMap) -> Array[Vector2i]:
	# Identical highlighting logic to FiresparkMage/Frostbolt
	curr_highlighted_cells = HexHelper.fov(map.get_cell_coords(from.global_position), mouse_pos, map.can_walk) 
	for cell in curr_highlighted_cells: 
		if HexHelper.distance(map.get_cell_coords(from.global_position), cell) > get_skill_range():
			curr_highlighted_cells.erase(cell)
			continue
		var cell_char = map.get_character(cell)
		if cell_char and cell_char is AICombatCharacter:
			map.set_cell(0, cell, 22, map.get_cell_atlas_coords(0, cell), 5)
		else :
			map.set_cell(0, cell, 22, map.get_cell_atlas_coords(0, cell), 3)
		

	return curr_highlighted_cells


### lightning_storm.gd ###
extends Skill
class_name LightningStorm

var damage_mult := 4
var num_targets := 3
var stun_chance := 0.4
var stun_duration := 1
var max_cooldown := 6
var curr_highlighted_cells: Array[Vector2i] = []


const thunderstrike_scene = preload("res://scenes/impact_effect.tscn") 
var caster: CombatCharacter
var curr_storms: Dictionary = {} 



func use_skill(from: CombatCharacter, skill_pos: Vector2i, map: CombatMap) -> bool:
	var caster_pos = map.get_cell_coords(from.global_position)
	var aoe_cells = HexHelper.hex_reachable(caster_pos, get_skill_range(), func(_hex): return true).filter(map.can_walk)

	if not skill_pos in aoe_cells:
		return false # Skill position is not in the AoE radius

	# Find potential targets in radius
	var potential_targets: Array[CombatCharacter] = []
	for cell in aoe_cells:
		var character = map.get_character(cell)
		if is_valid_target_type(from, character):
			potential_targets.append(character)


	if potential_targets.is_empty():
		return false # No enemies in range

	# Select targets randomly
	potential_targets.shuffle()
	var actual_targets = potential_targets.slice(0, min(num_targets, potential_targets.size()))

	caster = from

	for target in actual_targets:
		var curr_storm = thunderstrike_scene.instantiate()
		curr_storm.position = target.position
		target.get_parent().add_child(curr_storm)
		curr_storm.scale = Vector2(2.5, 2.5)
		curr_storm.set_impact_type("lightning_storm")
		curr_storm.animated_sprite.animation_looped.connect(_apply_effect.bind(target))
		curr_storms[target] = curr_storm 

	cooldown = max_cooldown
	return true

func score_action(from: CombatCharacter, potential_targets: Array[CombatCharacter], _target_cell: Vector2i, _map: CombatMap) -> float:

	var score = AIScoringWeights.WEIGHT_BASE_RANGED
	# Find ALL potential enemies in range

	if potential_targets.is_empty():
		return 0.0 # No enemies in range

	var three_combinations: Array = []
	if potential_targets.size() <= 3:
		three_combinations = [potential_targets]

	else :
		three_combinations = []
		for i in range(potential_targets.size() - 2):
			for j in range(i + 1, potential_targets.size()):
				for k in range(j + 1, potential_targets.size()):
					three_combinations.append([potential_targets[i], potential_targets[j], potential_targets[k]])


	var potential_damage_per_target = from.get_damage() * damage_mult

	var combi_score = 0.0
	
	for combination in three_combinations:
		var total_damage = potential_damage_per_target * combination.size()
		combi_score += total_damage * AIScoringWeights.WEIGHT_DAMAGE * AIScoringWeights.WEIGHT_AOE_TARGET_ENEMY

		for target in combination:
			if target.health <= potential_damage_per_target:
				combi_score += AIScoringWeights.WEIGHT_KILL_BONUS
			else:
				combi_score += (1.0 - (target.health / target.max_health)) * potential_damage_per_target * AIScoringWeights.WEIGHT_DAMAGE_PER_HP
		
			combi_score += AIScoringWeights.WEIGHT_DISABLE_TURN * stun_duration * stun_chance * combination.size()

			combi_score -= target.shield * AIScoringWeights.WEIGHT_SHIELD_ENEMY #

	score += combi_score / (three_combinations.size() * 1.0) # Average score for all combinations
	

	return score

func generate_targets(from: CombatCharacter, map: CombatMap) -> Array[TargetInfo]:
	var caster_pos = map.get_cell_coords(from.global_position)
	var potential_enemies: Array[CombatCharacter] = []
	var aoe_cells = HexHelper.hex_reachable(caster_pos, get_skill_range(), map.can_walk)

	for cell in aoe_cells:
		var target_char = map.get_character(cell)
		if target_char and is_valid_target_type(from, target_char): # Check if it's an enemy
			potential_enemies.append(target_char)

	if not potential_enemies.is_empty():
		return [TargetInfo.new(
			TargetInfo.TargetType.SELF_AOE_ACTIVATION,
			from,
			caster_pos,
			potential_enemies # List of potential targets
		)]
	else:
		return []



func _apply_effect(target):
	if is_instance_valid(target):
		caster.deal_damage(target, damage_mult)
		if randf() < stun_chance:
			target.gain_status("stunned", stun_duration)

	if curr_storms.has(target):
		var curr_storm = curr_storms[target]
		if is_instance_valid(curr_storm):
			curr_storm.queue_free()
			curr_storms.erase(target)
			
	skill_finished.emit()

func get_skill_name() -> String:
	return "Lightning Storm"

func get_skill_description() -> String:
	return "Deal " + str(damage_mult) + " times your base damage to " + str(num_targets) + " random enemies, with a " + str(int(stun_chance * 100)) + "% chance to stun them.\n" + \
		"Cooldown: " + str(max_cooldown) + " turns.\n" + \
		"Range: " + str(get_skill_range()) + " cells.\n"

func get_skill_icon() -> Texture:
	return load("res://assets/ui/skills/lightning_storm.png") 

func get_skill_range() -> int:
	# This is the radius of effect
	return 3

func target_allies() -> bool:
	return false

func target_enemies() -> bool:
	return true

func target_self() -> bool:
	return false # Activated by targeting self / area around self

func is_melee() -> bool:
	# Consistent with Whirlwind/Inquisition (AoE centered on self)
	return true

func highlight_targets(from: CombatCharacter, map: CombatMap) -> Array[Vector2i]:
	var caster_pos = map.get_cell_coords(from.global_position)
	curr_highlighted_cells = HexHelper.hex_reachable(caster_pos, get_skill_range(), func (_hex): return true).filter(func (cell): return map.can_walk((cell)))

	for cell in curr_highlighted_cells:
		map.set_cell(0, cell, 22, map.get_cell_atlas_coords(0, cell), 1) # Highlight area tile
		var character = map.get_character(cell)
		if character and character is AICombatCharacter:
			map.set_cell(0, cell, 22, map.get_cell_atlas_coords(0, cell), 3) # Mark enemy in area
		elif character and character is PlayerCombatCharacter:
			map.set_cell(0, cell, 22, map.get_cell_atlas_coords(0, cell), 0)

	return curr_highlighted_cells

func highlight_mouse_pos(_from: CombatCharacter, mouse_pos: Vector2i, map: CombatMap) -> Array[Vector2i]:
	var highlight_color = 1
	if mouse_pos in curr_highlighted_cells:
		highlight_color = 2

	for cell in curr_highlighted_cells:
		map.set_cell(0, cell, 22, map.get_cell_atlas_coords(0, cell), highlight_color)
		var character = map.get_character(cell)

		if character:
			var char_highlight = 0
			var char_hover_highlight = 0
			if character is AICombatCharacter:
				char_highlight = 3; char_hover_highlight = 5

			if mouse_pos in curr_highlighted_cells:
				map.set_cell(0, cell, 22, map.get_cell_atlas_coords(0, cell), char_hover_highlight)
			else: # Mouse outside AoE, just show characters normally within AoE
				map.set_cell(0, cell, 22, map.get_cell_atlas_coords(0, cell), char_highlight)

	return curr_highlighted_cells

### meteor.gd ###
extends Skill
class_name Meteor

var total_damage_mult := 12
var aoe_radius := 1
var max_cooldown := 5

const meteor_scene = preload("res://scenes/impact_effect.tscn")
var curr_meteor: ImpactEffect 
var targets: Array[CombatCharacter] = []
var caster: CombatCharacter
var curr_highlighted_cells: Array[Vector2i] = []


func use_skill(from: CombatCharacter, skill_pos: Vector2i, map: CombatMap) -> bool:
	caster = from
	targets = []
	var caster_pos = map.get_cell_coords(from.global_position)
	if HexHelper.distance(caster_pos, skill_pos) > get_skill_range():
		return false

	# Find all characters in the AoE centered on skill_pos
	var impact_cells = HexHelper.hex_reachable(skill_pos, aoe_radius, func(_hex): return true)
	for cell in impact_cells:
		var character = map.get_character(cell)
		if character:
			targets.append(character)

	if targets.is_empty():
		return false

	# Play visual effect at skill_pos
	curr_meteor = meteor_scene.instantiate()
	map.add_child(curr_meteor) 
	curr_meteor.position = map.map_to_local(skill_pos)
	curr_meteor.scale = Vector2(6, 6)
	curr_meteor.set_impact_type("thunderstrike")
	curr_meteor.animated_sprite.animation_looped.connect(_apply_effect)

	cooldown = max_cooldown
	return true

func score_action(from: CombatCharacter, potential_targets: Array[CombatCharacter], _target_cell: Vector2i, _map: CombatMap) -> float:
	# potential_targets here are ALL characters in the AoE of target_cell
	if potential_targets.is_empty(): return 0.0

	var score = AIScoringWeights.WEIGHT_BASE_RANGED
	var damage_per_target = (from.get_damage() * total_damage_mult) / potential_targets.size()

	var enemy_targets = 0
	var total_enemy_damage_score = 0.0
	var total_ally_damage_penalty = 0.0

	for target in potential_targets:
		if target is PlayerCombatCharacter: # Is Enemy?
			enemy_targets += 1
			var enemy_score = damage_per_target * AIScoringWeights.WEIGHT_DAMAGE
			if target.health <= damage_per_target:
				enemy_score += AIScoringWeights.WEIGHT_KILL_BONUS
			else:
				enemy_score += (1.0 - (target.health / target.max_health)) * damage_per_target * AIScoringWeights.WEIGHT_DAMAGE_PER_HP
			total_enemy_damage_score += enemy_score
		else :
			# Apply penalty for hitting allies
			total_ally_damage_penalty += AIScoringWeights.WEIGHT_AOE_TARGET_ALLY_DAMAGE_PENALTY * (damage_per_target / target.max_health) # Penalty scaled by % max hp damage

	if enemy_targets == 0: return 0.0 # No enemies in AoE

	score += total_enemy_damage_score * AIScoringWeights.WEIGHT_AOE_TARGET_ENEMY
	score += total_ally_damage_penalty # Penalty is negative

	return max(0.0, score) 

func generate_targets(from: CombatCharacter, map: CombatMap) -> Array[TargetInfo]:
	var potential_targets: Array[TargetInfo] = []
	var caster_pos = map.get_cell_coords(from.global_position)
	# Find all valid center points within skill range
	var potential_center_cells = HexHelper.hex_reachable(caster_pos, get_skill_range(), func (_hex): return true).filter(map.can_walk)

	for center_cell in potential_center_cells:
		# For each center, calculate who would be hit
		var impact_cells = HexHelper.hex_reachable(center_cell, aoe_radius, func(_hex): return true)
		var characters_hit: Array[CombatCharacter] = []
		for cell in impact_cells:
			var character = map.get_character(cell)
			if is_valid_target_type(from, character):
				characters_hit.append(character)

		# Only create a TargetInfo if this location actually hits someone
		if not characters_hit.is_empty():
			potential_targets.append(TargetInfo.new(
				TargetInfo.TargetType.AOE_LOCATION,
				null,          # No single primary target
				center_cell,   # The center of the blast
				characters_hit # All characters hit by aiming here
			))
	return potential_targets


func _apply_effect(): 
	var damage_mult = total_damage_mult / (len(targets)*1.0)
	for target in targets : 
		caster.deal_damage(target, damage_mult)
	curr_meteor.queue_free()
	skill_finished.emit()

func get_skill_name() -> String:
	return "Meteor"

func get_skill_description() -> String:
	return "Deal " + str(total_damage_mult) + " times your base damage divided between all characters in a " + str(aoe_radius) + "-cell radius around the target location.\n" + \
		"Cooldown: " + str(max_cooldown) + " turns.\n" + \
		"Range: " + str(get_skill_range()) + " cells.\n"

func get_skill_icon() -> Texture:
	return load("res://assets/ui/skills/meteor.png") 

func get_skill_range() -> int:
	return 4

func target_allies() -> bool:
	return true # Can hit allies in blast

func target_enemies() -> bool:
	return true # Can hit enemies in blast

func target_self() -> bool:
	return true # Can hit self if targeted nearby

func is_melee() -> bool:
	return false

func highlight_targets(from: CombatCharacter, map: CombatMap) -> Array[Vector2i]:
	var caster_pos = map.get_cell_coords(from.global_position)
	curr_highlighted_cells = HexHelper.hex_reachable(caster_pos, get_skill_range(), func(_hex: Vector2i): return true).filter(func (cell): return map.can_walk((cell)))

	for cell in curr_highlighted_cells:
		map.set_cell(0, cell, 22, map.get_cell_atlas_coords(0, cell), 3)

	return curr_highlighted_cells

func highlight_mouse_pos(_from: CombatCharacter, mouse_pos: Vector2i, map: CombatMap) -> Array[Vector2i]:
	map.reset_map()
	for cell in curr_highlighted_cells:
		map.set_cell(0, cell, 22, map.get_cell_atlas_coords(0, cell), 3)

	# If mouse is over a valid center point, highlight the AoE
	if mouse_pos in curr_highlighted_cells:
		map.set_cell(0, mouse_pos, 22, map.get_cell_atlas_coords(0, mouse_pos), 4) # Hovered target cell
		var curr_aoe_highlight = HexHelper.hex_reachable(mouse_pos, aoe_radius, func(hex): return map.can_walk(hex))

		for cell in curr_aoe_highlight:
			var character = map.get_character(cell)
			if character:
				map.set_cell(0, cell, 22, map.get_cell_atlas_coords(0, cell), 5)
			else:
				map.set_cell(0, cell, 22, map.get_cell_atlas_coords(0, cell), 4)

	return curr_highlighted_cells # Return the valid center points

### arcane_slash.gd ###
extends MeleeSkill # Inherits range 1, is_melee, basic highlighting
class_name ArcaneSlash

var damage_mult := 3
var shield_gain_percent := 0.33 # Gain third of damage_mult dealt
var max_cooldown := 3

func use_skill(from: CombatCharacter, skill_pos: Vector2i, map: CombatMap) -> bool:
	var skill_target = map.get_character(skill_pos)
	var caster_pos = map.get_cell_coords(from.global_position)
	if not is_valid_target_type(from, skill_target) or HexHelper.distance(caster_pos, skill_pos) > get_skill_range():
		return false 

	var damage_dealt = from.deal_damage(skill_target, damage_mult)
	from.gain_shield_flat(damage_dealt * shield_gain_percent)
	from.attack(map.to_local(skill_target.global_position))


	cooldown = max_cooldown
	skill_finished.emit()
	return true

func score_action(from: CombatCharacter, potential_targets: Array[CombatCharacter], _target_cell: Vector2i, _map: CombatMap) -> float:
	if potential_targets.is_empty(): return 0.0
	var target = potential_targets[0]

	var score = AIScoringWeights.WEIGHT_BASE_MELEE
	var potential_damage = from.get_damage() * damage_mult
	score += potential_damage * AIScoringWeights.WEIGHT_DAMAGE
	score -= target.shield * AIScoringWeights.WEIGHT_SHIELD_ENEMY

	if target.health <= potential_damage:
		score += AIScoringWeights.WEIGHT_KILL_BONUS
	else:
		score += (1.0 - (target.health / target.max_health)) * potential_damage * AIScoringWeights.WEIGHT_DAMAGE_PER_HP

	# Score the shield gain
	var shield_gain = potential_damage * shield_gain_percent / 100.0
	var shield_value = shield_gain * AIScoringWeights.WEIGHT_SHIELD
	shield_value *= (1.0 + (1.0 - from.health / from.max_health) * 0.5)
	score += shield_value

	return score

func generate_targets(caster: CombatCharacter, map: CombatMap) -> Array[TargetInfo]:
	# Standard melee targeting
	var targets: Array[TargetInfo] = []
	var caster_pos = map.get_cell_coords(caster.global_position)
	var potential_cells = HexHelper.hex_reachable(caster_pos, get_skill_range(), map.can_walk)

	for cell in potential_cells:
		if cell != caster_pos:
			var target_char = map.get_character(cell)
			if target_char and is_valid_target_type(caster, target_char):
				targets.append(TargetInfo.new(
					TargetInfo.TargetType.CHARACTER, target_char, cell, [target_char]
				))
	return targets


func get_skill_name() -> String:
	return "Arcane Slash"

func get_skill_description() -> String:
	return "Deal " + str(damage_mult) + " times your base damage to an enemy, gain " + str(shield_gain_percent) + "% of damage dealt as shield.\n" + \
		"Cooldown: " + str(max_cooldown) + " turns.\n" + \
		"Range: " + str(get_skill_range()) + " cells.\n"

func get_skill_icon() -> Texture:
	return load("res://assets/ui/skills/arcane_slash.png")

func target_allies() -> bool:
	return false

func target_enemies() -> bool:
	return true

func target_self() -> bool:
	return false


### molten_blade.gd ###
extends Skill
class_name MoltenBlade

var bonus_damage = 10
var duration := 3
var max_cooldown := 4
var curr_highlighted_cells: Array[Vector2i] = []

func use_skill(from: CombatCharacter, skill_pos: Vector2i, map: CombatMap) -> bool:
	var target_char = map.get_character(skill_pos)
	if not is_valid_target_type(from, target_char) :
		return false

	from.gain_status("imbue", duration+1, bonus_damage)

	cooldown = max_cooldown
	skill_finished.emit()
	return true

func score_action(from: CombatCharacter, _potential_targets: Array[CombatCharacter], _target_cell: Vector2i, map: CombatMap) -> float:
	# Self buff - Score based on potential future damage increase
	var score = AIScoringWeights.WEIGHT_BUFF_POSITIVE # Base value for a buff

	# More valuable if caster is likely to attack multiple times soon
	# Hard to predict, use a base value + bonus if enemies are close
	var caster_pos = map.get_cell_coords(from.global_position)
	for p in map.get_alive_party_members(): # Assuming AI vs Player
		var dist = HexHelper.distance(caster_pos, map.get_cell_coords(p.global_position))
		score += AIScoringWeights.WEIGHT_SKILL_DISTANCE * 2.0/dist # Distance penalty

	# less valuable if low health
	score += AIScoringWeights.WEIGHT_SKILL_LOW_HEALTH * (1 - from.health / from.max_health) # Health penalty

	return score

func generate_targets(caster: CombatCharacter, map: CombatMap) -> Array[TargetInfo]:
	# Self-cast only
	var caster_pos = map.get_cell_coords(caster.global_position)
	if is_valid_target_type(caster, caster): # Should always be true for target_self=true
		return [TargetInfo.new(
			TargetInfo.TargetType.SELF_CAST,
			caster,
			caster_pos,
			[caster] # Affects the caster
		)]
	else:
		return []


func get_skill_name() -> String:
	return "Molten Blade"

func get_skill_description() -> String:
	return "Imbue your weapon with fire, dealing " + str(bonus_damage) + " additional base damage for " + str(duration) + " turns.\n" + \
		"Cooldown: " + str(max_cooldown) + " turns.\n" + \
		"Range: yourself.\n"

func get_skill_icon() -> Texture:
	return load("res://assets/ui/skills/molten_blade.png") 

func get_skill_range() -> int:
	return 0 # Self cast

func target_allies() -> bool:
	return false

func target_enemies() -> bool:
	return false

func target_self() -> bool:
	return true

func is_melee() -> bool:
	# Consistent with other self-buffs (Defensive Stance, Frenzy)
	return true

func highlight_targets(from: CombatCharacter, map: CombatMap) -> Array[Vector2i]:
	# Highlight self only, similar to Defensive Stance
	var cell = map.get_cell_coords(from.global_position)
	curr_highlighted_cells = [cell]
	map.set_cell(0, cell, 22, map.get_cell_atlas_coords(0, cell), 7) # Use self-target color
	return curr_highlighted_cells

func highlight_mouse_pos(_from: CombatCharacter, mouse_pos: Vector2i, map: CombatMap) -> Array[Vector2i]:
	# Highlight self when hovered, similar to Defensive Stance
	for cell in curr_highlighted_cells: # Should only be self cell
		map.set_cell(0, cell, 22, map.get_cell_atlas_coords(0, cell), 7) # Default self color
		if mouse_pos == cell:
			map.set_cell(0, cell, 22, map.get_cell_atlas_coords(0, cell), 8) # Hovered self color
	return curr_highlighted_cells

### dark_pact.gd ###
extends Skill
class_name DarkPact

var damage_mult := 3
var health_cost_percent := 0.15
var max_cooldown := 1

const dark_pact_projectile = preload("res://scenes/projectile_effect.tscn")
var curr_projectile: ProjectileEffect
var caster: CombatCharacter
var target: CombatCharacter
var curr_highlighted_cells: Array[Vector2i] = []

func use_skill(from: CombatCharacter, skill_pos: Vector2i, map: CombatMap) -> bool:
	var skill_target = map.get_character(skill_pos)
	if not is_valid_target_type(from, skill_target) or HexHelper.distance(map.get_cell_coords(from.global_position), skill_pos) > get_skill_range():
		return false

	caster = from
	target = skill_target

	# Sacrifice health first
	var health_cost = from.max_health * health_cost_percent
	from.spend_health(health_cost) 

	curr_projectile = dark_pact_projectile.instantiate()
	from.get_parent().add_child(curr_projectile)
	curr_projectile.position = from.position
	curr_projectile.scale = Vector2(1.5, 1.5)
	curr_projectile.speed = 1000.0
	curr_projectile.set_target_position(target.position)
	curr_projectile.target_reached.connect(_on_reached_target, CONNECT_ONE_SHOT)

	cooldown = max_cooldown
	return true

func score_action(from: CombatCharacter, potential_targets: Array[CombatCharacter], _target_cell: Vector2i, _map: CombatMap) -> float:
	if potential_targets.is_empty(): return 0.0
	var potential_target = potential_targets[0]

	var score = AIScoringWeights.WEIGHT_BASE_RANGED
	var potential_damage = from.get_damage() * damage_mult
	score += potential_damage * AIScoringWeights.WEIGHT_DAMAGE

	if potential_target.health <= potential_damage:
		score += AIScoringWeights.WEIGHT_KILL_BONUS
	else:
		score += (1.0 - (potential_target.health / potential_target.max_health)) * potential_damage * AIScoringWeights.WEIGHT_DAMAGE_PER_HP

	# Penalty for health cost
	var health_cost = from.max_health * health_cost_percent
	score += health_cost_percent * 100.0 * AIScoringWeights.WEIGHT_HEALTH_COST_PENALTY

	# Heavily penalize if the health cost would kill the caster
	if from.health <= health_cost:
		score = 0.0 # Never suicide with this skill

	# Reduce score significantly if caster health is already low
	if from.health < from.max_health * 0.3:
		score *= 0.25

	score -= potential_target.shield * AIScoringWeights.WEIGHT_SHIELD_ENEMY

	return max(0.0, score) # Ensure score isn't negative

func generate_targets(from: CombatCharacter, map: CombatMap) -> Array[TargetInfo]:
	var targets: Array[TargetInfo] = []
	var caster_pos = map.get_cell_coords(from.global_position)
	var potential_cells = HexHelper.hex_reachable(caster_pos, get_skill_range(), func (_hex): return true).filter(map.can_walk)

	for cell in potential_cells:
		var target_char = map.get_character(cell)
		if is_valid_target_type(from, target_char):
			targets.append(TargetInfo.new(
				TargetInfo.TargetType.CHARACTER, target_char, cell, [target_char]
			))
	return targets

func _on_reached_target():
	if is_instance_valid(target):
		_apply_effect()
	if is_instance_valid(curr_projectile):
		curr_projectile.queue_free()
	skill_finished.emit()

func _apply_effect():
	if is_instance_valid(target):
		caster.deal_damage(target, damage_mult)

func get_skill_name() -> String:
	return "Dark Pact"

func get_skill_description() -> String:
	return "Sacrifice " + str(int(health_cost_percent * 100)) + "% of your max health to deal " + str(damage_mult) + " times your base damage to an enemy.\n" + \
		"Cooldown: " + str(max_cooldown) + " turns.\n" + \
		"Range: " + str(get_skill_range()) + " cells.\n"

func get_skill_icon() -> Texture:
	return load("res://assets/ui/skills/dark_pact.png") 

func get_skill_range() -> int:
	return 3

func target_allies() -> bool:
	return false

func target_enemies() -> bool:
	return true

func target_self() -> bool:
	return false

func is_melee() -> bool:
	return false

func highlight_targets(_from: CombatCharacter, _map: CombatMap) -> Array[Vector2i]:
	# Identical highlighting logic to FiresparkMage/Frostbolt
	return []

func highlight_mouse_pos(from: CombatCharacter, mouse_pos: Vector2i, map: CombatMap) -> Array[Vector2i]:
	curr_highlighted_cells = HexHelper.fov(map.get_cell_coords(from.global_position), mouse_pos, map.can_walk) 
	for cell in curr_highlighted_cells: 
		if HexHelper.distance(map.get_cell_coords(from.global_position), cell) > get_skill_range():
			curr_highlighted_cells.erase(cell)
			continue
		var cell_char = map.get_character(cell)
		if cell_char and cell_char is AICombatCharacter:
			map.set_cell(0, cell, 22, map.get_cell_atlas_coords(0, cell), 5)
		else :
			map.set_cell(0, cell, 22, map.get_cell_atlas_coords(0, cell), 3)
		

	return curr_highlighted_cells

### drain_life.gd ###
extends Skill
class_name DrainLife

var damage_mult := 2
var max_cooldown := 4

const drain_life_effect = preload("res://scenes/projectile_effect.tscn") # ASSUMPTION: Beam/effect visual
var caster: CombatCharacter
var target: CombatCharacter
var curr_effect: ProjectileEffect
var curr_highlighted_cells: Array[Vector2i] = []

func use_skill(from: CombatCharacter, skill_pos: Vector2i, map: CombatMap) -> bool:
	var skill_target = map.get_character(skill_pos)
	if not is_valid_target_type(from, skill_target) or HexHelper.distance(map.get_cell_coords(from.global_position), skill_pos) > get_skill_range():
		return false

	caster = from
	target = skill_target

	curr_effect = drain_life_effect.instantiate()
	from.get_parent().add_child(curr_effect)
	curr_effect.position = from.position
	curr_effect.scale = Vector2(1.5, 1.5)
	curr_effect.speed = 1000.0
	curr_effect.set_target_position(target.position)
	curr_effect.target_reached.connect(_on_reached_target, CONNECT_ONE_SHOT)

	cooldown = max_cooldown
	skill_finished.emit()
	return true

func score_action(from: CombatCharacter, potential_targets: Array[CombatCharacter], _target_cell: Vector2i, _map: CombatMap) -> float:
	if potential_targets.is_empty(): return 0.0
	var potential_target = potential_targets[0]

	var score = AIScoringWeights.WEIGHT_BASE_RANGED
	var potential_damage = from.get_damage() * damage_mult
	var potential_heal = potential_damage # Heal amount equals damage dealt

	# Score damage component
	var damage_score = potential_damage * AIScoringWeights.WEIGHT_DAMAGE
	if potential_target.health <= potential_damage:
		damage_score += AIScoringWeights.WEIGHT_KILL_BONUS
	else:
		damage_score += (1.0 - (potential_target.health / potential_target.max_health)) * potential_damage * AIScoringWeights.WEIGHT_DAMAGE_PER_HP
	damage_score -= potential_target.shield * 0.1

	# Score heal component
	var heal_score = potential_heal * AIScoringWeights.WEIGHT_HEAL
	# Value heal more if caster is low health
	var caster_health_percent = from.health / from.max_health
	heal_score += (1.0 - caster_health_percent) * potential_heal * AIScoringWeights.WEIGHT_HEAL_LOW_HP_BONUS

	# If targeting an ally, damage score is negative!
	if potential_target is AICombatCharacter : 
		damage_score = (1 - (potential_target.health / potential_target.max_health)) * AIScoringWeights.WEIGHT_AOE_TARGET_ALLY_DAMAGE_PENALTY # Use heavy penalty

	score += damage_score + heal_score
	return max(0.0, score)

func generate_targets(from: CombatCharacter, map: CombatMap) -> Array[TargetInfo]:
	# Ranged single target, can hit allies or enemies
	var targets: Array[TargetInfo] = []
	var caster_pos = map.get_cell_coords(from.global_position)
	var potential_cells = HexHelper.hex_reachable(caster_pos, get_skill_range(), map.can_walk)

	for cell in potential_cells:
		var target_char = map.get_character(cell)
		if is_valid_target_type(from, target_char):
			targets.append(TargetInfo.new(
				TargetInfo.TargetType.CHARACTER, target_char, cell, [target_char]
			))
	return targets


func _on_reached_target():
	if is_instance_valid(target):
		_apply_effect()
	if is_instance_valid(curr_effect):
		curr_effect.queue_free()

func _apply_effect():
	if is_instance_valid(target) and is_instance_valid(caster):
		caster.deal_damage(target, damage_mult)
		caster.heal(damage_mult * caster.get_damage())

func get_skill_name() -> String:
	return "Drain Life"

func get_skill_description() -> String:
	return "Steal " + str(damage_mult) + " times your base damage in health from a character.\n" + \
		"Cooldown: " + str(max_cooldown) + " turns.\n" + \
		"Range: " + str(get_skill_range()) + " cells.\n"

func get_skill_icon() -> Texture:
	return load("res://assets/ui/skills/drain_life.png") 

func get_skill_range() -> int:
	return 3

func target_allies() -> bool:
	return true

func target_enemies() -> bool:
	return true

func target_self() -> bool:
	return false

func is_melee() -> bool:
	return false

func highlight_targets(_from: CombatCharacter, _map: CombatMap) -> Array[Vector2i]:
	# Identical highlighting logic to FiresparkMage/Frostbolt
	return []

func highlight_mouse_pos(from: CombatCharacter, mouse_pos: Vector2i, map: CombatMap) -> Array[Vector2i]:
	curr_highlighted_cells = HexHelper.fov(map.get_cell_coords(from.global_position), mouse_pos, map.can_walk) 
	for cell in curr_highlighted_cells: 
		if HexHelper.distance(map.get_cell_coords(from.global_position), cell) > get_skill_range():
			curr_highlighted_cells.erase(cell)
			continue
		var cell_char = map.get_character(cell)
		if cell_char and cell_char is CombatCharacter:
			map.set_cell(0, cell, 22, map.get_cell_atlas_coords(0, cell), 5)
		else :
			map.set_cell(0, cell, 22, map.get_cell_atlas_coords(0, cell), 3)
		

	return curr_highlighted_cells


### bone_armor.gd ###
extends Skill
class_name BoneArmor

var shield_amount_percentage := 0.25
var retaliate_damage := 20
var duration := 3
var max_cooldown := 5
var curr_highlighted_cells: Array[Vector2i] = []

func use_skill(from: CombatCharacter, skill_pos: Vector2i, map: CombatMap) -> bool:
	var target = map.get_character(skill_pos)
	if not is_valid_target_type(from, target):
		return false

	from.gain_shield(shield_amount_percentage)
	from.gain_status("thorns", duration+1, retaliate_damage)

	cooldown = max_cooldown
	skill_finished.emit()
	return true

func score_action(caster: CombatCharacter, _potential_targets: Array[CombatCharacter], _target_cell: Vector2i, map: CombatMap) -> float:
	# Self buff: Shield + Thorns
	var score = AIScoringWeights.WEIGHT_BUFF_POSITIVE * 1.2 # Base for strong defensive buff

	# Score shield
	var shield_value = shield_amount_percentage * AIScoringWeights.WEIGHT_SHIELD
	shield_value *= (1.0 + (1.0 - caster.health / caster.max_health) * 0.5) # More valuable when low hp
	score += shield_value

	# Score thorns - more valuable if enemies are likely to attack caster
	var enemies_nearby = 0
	var caster_pos = map.get_cell_coords(caster.global_position)
	for p in map.get_alive_party_members():
		# Check if enemy is melee and adjacent
		if HexHelper.distance(caster_pos, map.get_cell_coords(p.global_position)) == 1: # Add check for melee capability if possible
			enemies_nearby += 1
	score += enemies_nearby * retaliate_damage * 0.3 * duration # Approx value of thorns damage

	return score

func generate_targets(caster: CombatCharacter, map: CombatMap) -> Array[TargetInfo]:
	# Self-cast only
	var caster_pos = map.get_cell_coords(caster.global_position)
	if is_valid_target_type(caster, caster):
		return [TargetInfo.new(
			TargetInfo.TargetType.SELF_CAST, caster, caster_pos, [caster]
		)]
	else:
		return []


func get_skill_name() -> String:
	return "Bone Armor"

func get_skill_description() -> String:
	return "Create a shield that absorbs " + str(shield_amount_percentage) + "%% of your max HP and deals " + str(retaliate_damage) + " damage to any enemy that attacks you for " + str(duration) + " turns.\n" + \
		"Cooldown: " + str(max_cooldown) + " turns.\n" + \
		"Range: yourself.\n"

func get_skill_icon() -> Texture:
	return load("res://assets/ui/skills/bone_armor.png")

func get_skill_range() -> int:
	return 0

func target_allies() -> bool:
	return false

func target_enemies() -> bool:
	return false

func target_self() -> bool:
	return true

func is_melee() -> bool:
	return true

func highlight_targets(from: CombatCharacter, map: CombatMap) -> Array[Vector2i]:
	var cell = map.get_cell_coords(from.global_position)
	curr_highlighted_cells = [cell]
	map.set_cell(0, cell, 22, map.get_cell_atlas_coords(0, cell), 7)
	return curr_highlighted_cells

func highlight_mouse_pos(_from: CombatCharacter, mouse_pos: Vector2i, map: CombatMap) -> Array[Vector2i]:
	for cell in curr_highlighted_cells:
		map.set_cell(0, cell, 22, map.get_cell_atlas_coords(0, cell), 7)
		if mouse_pos == cell:
			map.set_cell(0, cell, 22, map.get_cell_atlas_coords(0, cell), 8)
	return curr_highlighted_cells


### soul_harvest.gd ###
extends Skill
class_name SoulHarvest

const harvest_effect = preload("res://scenes/impact_effect.tscn")
var damage_mult := 4
var max_cooldown := 3
var curr_highlighted_cells: Array[Vector2i] = []

var targets : Array[CombatCharacter] = []
var caster: CombatCharacter
var curr_effect: ImpactEffect

func use_skill(from: CombatCharacter, skill_pos: Vector2i, map: CombatMap) -> bool:
	var caster_pos = map.get_cell_coords(from.global_position) 
	var aoe_cells = HexHelper.hex_reachable(caster_pos, get_skill_range(), func(_hex): return true)

	if not aoe_cells.has(skill_pos):
		return false

	caster = from
	targets = []
	for cell in aoe_cells:
		var character = map.get_character(cell)
		if is_valid_target_type(from, character) :
			targets.append(character)

	if targets.is_empty():
		return false

	curr_effect = harvest_effect.instantiate()
	from.get_parent().add_child(curr_effect)
	curr_effect.position = from.position
	curr_effect.scale = Vector2(6, 6)
	curr_effect.set_impact_type("thunderstrike")
	curr_effect.animated_sprite.animation_looped.connect(_on_reached_target, CONNECT_ONE_SHOT)

	cooldown = max_cooldown
	return true

func score_action(from: CombatCharacter, potential_targets: Array[CombatCharacter], _target_cell: Vector2i, _map: CombatMap) -> float:
	# AoE Damage around self
	# potential_targets should include all characters hit (excluding self)
	if potential_targets.is_empty(): return 0.0

	var score = AIScoringWeights.WEIGHT_BASE_RANGED # Base for AoE damage
	var potential_damage_per_target = from.get_damage() * damage_mult
	var total_enemy_damage_score = 0.0
	var total_ally_damage_penalty = 0.0
	var enemies_hit = 0

	for target in potential_targets:
		if target == from: continue # Should already be excluded by use_skill logic

		if target is PlayerCombatCharacter: # Is Enemy?
			enemies_hit += 1
			var enemy_score = potential_damage_per_target * AIScoringWeights.WEIGHT_DAMAGE
			if target.health <= potential_damage_per_target:
				enemy_score += AIScoringWeights.WEIGHT_KILL_BONUS
			else:
				enemy_score += (1.0 - (target.health / target.max_health)) * potential_damage_per_target * AIScoringWeights.WEIGHT_DAMAGE_PER_HP
			total_enemy_damage_score += enemy_score
		else: # Is Ally?
			total_ally_damage_penalty += AIScoringWeights.WEIGHT_AOE_TARGET_ALLY_DAMAGE_PENALTY * (potential_damage_per_target / target.max_health)

	if enemies_hit == 0: return 0.0 # No value if only hitting allies

	score += total_enemy_damage_score * AIScoringWeights.WEIGHT_AOE_TARGET_ENEMY
	score += total_ally_damage_penalty


	return max(0.0, score)

func generate_targets(from: CombatCharacter, map: CombatMap) -> Array[TargetInfo]:
	# Self-centered AoE, affects all characters except caster
	var caster_pos = map.get_cell_coords(from.global_position)
	var characters_hit = []

	for cell in HexHelper.hex_reachable(caster_pos, get_skill_range(), func(_hex): return true):
		var character = map.get_character(cell)
		if is_valid_target_type(from, character):
			characters_hit.append(character)


	if not characters_hit.is_empty():
		return [TargetInfo.new(
			TargetInfo.TargetType.SELF_AOE_ACTIVATION,
			from,
			caster_pos,
			characters_hit # All non-caster characters hit
		)]
	else:
		return []

func _on_reached_target():
	if is_instance_valid(curr_effect):
		curr_effect.queue_free()

	for target in targets:
		if is_instance_valid(target):
			caster.deal_damage(target, damage_mult)

	skill_finished.emit()

func get_skill_name() -> String:
	return "Soul Harvest"

func get_skill_description() -> String:
	return "Deal " + str(damage_mult) + " times your base damage to all characters in a " + str(get_skill_range()) + "-cell radius.\n" + \
		"Cooldown: " + str(max_cooldown) + " turns.\n" + \
		"Range: " + str(get_skill_range()) + " cells.\n"

func get_skill_icon() -> Texture:
	return load("res://assets/ui/skills/soul_harvest.png")

func get_skill_range() -> int:
	return 2

func target_allies() -> bool:
	return true

func target_enemies() -> bool:
	return true # Implicitly via area

func target_self() -> bool:
	return false

func is_melee() -> bool:
	# Consistent with Lightning Storm / Whirlwind
	return true

func highlight_targets(from: CombatCharacter, map: CombatMap) -> Array[Vector2i]:
	var caster_pos = map.get_cell_coords(from.global_position)
	curr_highlighted_cells = HexHelper.hex_reachable(caster_pos, get_skill_range(), func(_hex: Vector2i): return true).filter(func (cell): return map.can_walk((cell)))

	for cell in curr_highlighted_cells:
		map.set_cell(0, cell, 22, map.get_cell_atlas_coords(0, cell), 3)
		var character = map.get_character(cell)
		if character:
			map.set_cell(0, cell, 22, map.get_cell_atlas_coords(0, cell), 4)
		if cell == caster_pos:
			map.set_cell(0, cell, 22, map.get_cell_atlas_coords(0, cell), 0)

	return curr_highlighted_cells

func highlight_mouse_pos(from: CombatCharacter, mouse_pos: Vector2i, map: CombatMap) -> Array[Vector2i]:
	var highlight_color = 3
	if mouse_pos in curr_highlighted_cells:
		highlight_color = 4

	for cell in curr_highlighted_cells:
		map.set_cell(0, cell, 22, map.get_cell_atlas_coords(0, cell), highlight_color)
		var character = map.get_character(cell)
		var caster_pos = map.get_cell_coords(from.global_position)

		if character:
			var char_highlight = 4; var char_hover_highlight = 5
			if cell == caster_pos:
				char_highlight = 0; char_hover_highlight = 0

			if mouse_pos in curr_highlighted_cells:
				map.set_cell(0, cell, 22, map.get_cell_atlas_coords(0, cell), char_hover_highlight)
			else:
				map.set_cell(0, cell, 22, map.get_cell_atlas_coords(0, cell), char_highlight)

	return curr_highlighted_cells


### death_coil.gd ###
extends Skill
class_name DeathCoil

var damage_mult := 3
var heal_percent := 0.5
var max_cooldown := 2

const death_coil_projectile = preload("res://scenes/projectile_effect.tscn") 
var caster: CombatCharacter
var target: CombatCharacter
var curr_projectile: ProjectileEffect
var curr_highlighted_cells: Array[Vector2i] = []
var duration := 2 

func use_skill(from: CombatCharacter, skill_pos: Vector2i, map: CombatMap) -> bool:
	var skill_target = map.get_character(skill_pos)
	if not is_valid_target_type(from, skill_target) or HexHelper.distance(map.get_cell_coords(from.global_position), skill_pos) > get_skill_range():
		return false

	caster = from
	target = skill_target

	curr_projectile = death_coil_projectile.instantiate()
	from.get_parent().add_child(curr_projectile)
	curr_projectile.position = from.position
	curr_projectile.set_target_position(target.position)
	curr_projectile.target_reached.connect(_on_reached_target, CONNECT_ONE_SHOT)


	cooldown = max_cooldown
	return true

func score_action(from: CombatCharacter, potential_targets: Array[CombatCharacter], _target_cell: Vector2i, _map: CombatMap) -> float:
	if potential_targets.is_empty(): return 0.0
	var potential_target = potential_targets[0]

	var score = AIScoringWeights.WEIGHT_BASE_RANGED 
	var potential_damage = from.get_damage() * damage_mult
	var potential_heal = potential_damage * heal_percent

	# Score damage
	var damage_score = potential_damage * AIScoringWeights.WEIGHT_DAMAGE
	if potential_target.health <= potential_damage:
		damage_score += AIScoringWeights.WEIGHT_KILL_BONUS
	else:
		damage_score += (1.0 - (potential_target.health / potential_target.max_health)) * potential_damage * AIScoringWeights.WEIGHT_DAMAGE_PER_HP
	damage_score -= potential_target.shield * AIScoringWeights.WEIGHT_SHIELD_ENEMY

	# Score heal
	var heal_score = potential_heal * AIScoringWeights.WEIGHT_HEAL
	heal_score += (1.0 - (from.health / from.max_health)) * potential_heal * AIScoringWeights.WEIGHT_HEAL_LOW_HP_BONUS

	# Score debuff (Weak)
	var debuff_score = AIScoringWeights.WEIGHT_BUFF_NEGATIVE * duration
	if potential_target.char_statuses["strong"] > 0:
		debuff_score *= 1.2

	score += damage_score + heal_score + debuff_score
	return score

func generate_targets(from: CombatCharacter, map: CombatMap) -> Array[TargetInfo]:
	# Ranged single target enemy
	var targets: Array[TargetInfo] = []
	var caster_pos = map.get_cell_coords(from.global_position)
	var potential_cells = HexHelper.hex_reachable(caster_pos, get_skill_range(), func (_hex) : return true)

	for cell in potential_cells:
		var target_char = map.get_character(cell)
		if is_valid_target_type(from, target_char): # Checks target_enemies flag
			targets.append(TargetInfo.new(
				TargetInfo.TargetType.CHARACTER, target_char, cell, [target_char]
			))
	return targets


func _on_reached_target():
	if is_instance_valid(target) and is_instance_valid(caster):
		var damage = caster.deal_damage(target, damage_mult)
		caster.heal(damage * heal_percent)
		target.gain_status("weak", duration + 1)
	if is_instance_valid(curr_projectile):
		curr_projectile.queue_free()
	skill_finished.emit()


func get_skill_name() -> String:
	return "Death Coil"

func get_skill_description() -> String:
	return "Deal " + str(damage_mult) + " times your base damage to an enemy and heal yourself for " + str(int(heal_percent * 100)) + "% of the damage dealt. Reduces the target's damage by 33% for " + str(duration) + " turns.\n" + \
		"Cooldown: " + str(max_cooldown) + " turns.\n" + \
		"Range: " + str(get_skill_range()) + " cells.\n"

func get_skill_icon() -> Texture:
	return load("res://assets/ui/skills/death_coil.png") 

func get_skill_range() -> int:
	return 4

func target_allies() -> bool:
	return false

func target_enemies() -> bool:
	return true

func target_self() -> bool:
	return false

func is_melee() -> bool:
	return false

func highlight_targets(_from: CombatCharacter, _map: CombatMap) -> Array[Vector2i]:
	return []

func highlight_mouse_pos(from: CombatCharacter, mouse_pos: Vector2i, map: CombatMap) -> Array[Vector2i]:
	curr_highlighted_cells = HexHelper.fov(map.get_cell_coords(from.global_position), mouse_pos, map.can_walk) 
	for cell in curr_highlighted_cells: 
		if HexHelper.distance(map.get_cell_coords(from.global_position), cell) > get_skill_range():
			curr_highlighted_cells.erase(cell)
			continue
		var cell_char = map.get_character(cell)
		if cell_char and cell_char is CombatCharacter:
			map.set_cell(0, cell, 22, map.get_cell_atlas_coords(0, cell), 5)
		else :
			map.set_cell(0, cell, 22, map.get_cell_atlas_coords(0, cell), 3)
		

	return curr_highlighted_cells


### decay.gd ###
extends Skill
class_name Decay

var damage_percent := 10
var duration := 3
var max_cooldown := 1

const decay_projectile = preload("res://scenes/projectile_effect.tscn") # ASSUMPTION: Visual effect
var caster: CombatCharacter
var target: CombatCharacter
var curr_projectile: Node2D
var curr_highlighted_cells: Array[Vector2i] = []

func use_skill(from: CombatCharacter, skill_pos: Vector2i, map: CombatMap) -> bool:
	var skill_target = map.get_character(skill_pos)
	if not is_valid_target_type(from, skill_target) or HexHelper.distance(map.get_cell_coords(from.global_position), skill_pos) > get_skill_range():
		return false

	caster = from
	target = skill_target

	# Launch visual effect
	curr_projectile = decay_projectile.instantiate()
	from.get_parent().add_child(curr_projectile)
	curr_projectile.position = from.position
	curr_projectile.set_target_position(target.position)
	curr_projectile.target_reached.connect(_on_reached_target, CONNECT_ONE_SHOT)


	cooldown = max_cooldown
	# Don't emit finished yet
	return true

func score_action(_from: CombatCharacter, potential_targets: Array[CombatCharacter], _target_cell: Vector2i, _map: CombatMap) -> float:
	if potential_targets.is_empty(): return 0.0
	var potential_target = potential_targets[0]

	var score = AIScoringWeights.WEIGHT_BUFF_NEGATIVE * 0.8 # DoT is generally less immediate value than debuffs

	# Calculate total potential damage over duration
	var damage_per_turn = potential_target.max_health * damage_percent / 100.0
	var total_dot_damage = damage_per_turn * duration

	# Score based on total damage, but discount it compared to direct damage
	score += total_dot_damage * AIScoringWeights.WEIGHT_DAMAGE * 0.5

	# Bonus if target is high health (DoT %HP is better)
	score += (potential_target.health / potential_target.max_health) * 10.0

	# Bonus if target doesn't already have decay or has fewer stacks
	var current_decay_stacks = potential_target.char_statuses["decay"][0] # Duration acts as proxy for stacks here
	var current_decay_percent = potential_target.char_statuses["decay"][1]
	# Value applying the *first* stack more, or refreshing a long duration one
	if current_decay_stacks < duration:
		score += 3.0 * (duration - current_decay_stacks) 
	# Value adding to existing stacks, up to a point
	score += (damage_percent / max(10.0, current_decay_percent)) * 10.0 # Diminishing returns as % increases

	# Consider if target might die before DoT finishes? Hard to predict.

	return score

func generate_targets(from: CombatCharacter, map: CombatMap) -> Array[TargetInfo]:
	# Ranged single target enemy
	var targets: Array[TargetInfo] = []
	var caster_pos = map.get_cell_coords(from.global_position)
	var potential_cells = HexHelper.hex_reachable(caster_pos, get_skill_range(), map.can_walk)

	for cell in potential_cells:
		var target_char = map.get_character(cell)
		if is_valid_target_type(from, target_char):
			targets.append(TargetInfo.new(
				TargetInfo.TargetType.CHARACTER, target_char, cell, [target_char]
			))
	return targets

func _on_reached_target():
	if is_instance_valid(target):
		target.gain_status("decay", duration, damage_percent)
	if is_instance_valid(curr_projectile):
		curr_projectile.queue_free()
	skill_finished.emit()


func get_skill_name() -> String:
	return "Decay"

func get_skill_description() -> String:
	return "Inflict a decay effect on the enemy, causing them to lose " + str(int(damage_percent)) + "% of their max health at the end of their turn for " + str(duration) + " turns. \nStacks.\n" + \
		"Cooldown: " + str(max_cooldown) + " turns.\n" + \
		"Range: " + str(get_skill_range()) + " cells.\n" 

func get_skill_icon() -> Texture:
	return load("res://assets/ui/skills/decay.png")

func get_skill_range() -> int:
	return 4

func target_allies() -> bool:
	return false

func target_enemies() -> bool:
	return true

func target_self() -> bool:
	return false

func is_melee() -> bool:
	return false

func highlight_targets(_from: CombatCharacter, _map: CombatMap) -> Array[Vector2i]:
	return []

func highlight_mouse_pos(from: CombatCharacter, mouse_pos: Vector2i, map: CombatMap) -> Array[Vector2i]:
	curr_highlighted_cells = HexHelper.fov(map.get_cell_coords(from.global_position), mouse_pos, map.can_walk) 
	for cell in curr_highlighted_cells: 
		if HexHelper.distance(map.get_cell_coords(from.global_position), cell) > get_skill_range():
			curr_highlighted_cells.erase(cell)
			continue
		var cell_char = map.get_character(cell)
		if cell_char and cell_char is AICombatCharacter:
			map.set_cell(0, cell, 22, map.get_cell_atlas_coords(0, cell), 5)
		else :
			map.set_cell(0, cell, 22, map.get_cell_atlas_coords(0, cell), 3)
		

	return curr_highlighted_cells


### bounding_leap.gd ###
# bounding_leap.gd
extends Skill
class_name BoundingLeap

var damage_mult: float = 1 # Minor damage
var max_cooldown: int = 3
var leap_range: int = 3
var knockback_strength: int = 1 # Knockback distance
var aoe_radius_on_land: int = 1 # Affects adjacent cells

func use_skill(caster: CombatCharacter, target_cell: Vector2i, map: CombatMap) -> bool:
	var caster_pos = map.get_cell_coords(caster.global_position)

	# Check if target_cell is within leap_range and is walkable & not occupied by caster
	if HexHelper.distance(caster_pos, target_cell) > leap_range or \
	   not map.can_walk(target_cell) or map.cell_occupied(target_cell): 
			return false # Cannot land on cell occupied by another character.

	caster.move_to(map.map_to_local(target_cell))

	# --- Apply AoE Damage and Knockback on Landing ---
	var landing_aoe_cells = HexHelper.hex_reachable(target_cell, aoe_radius_on_land, func(_hex): return true)
	var affected_by_aoe: Array[CombatCharacter] = []

	for cell_in_aoe in landing_aoe_cells:
		if cell_in_aoe == target_cell: continue # Don't hit cell leaped onto, but adjacent

		var char_in_aoe = map.get_character(cell_in_aoe)
		if char_in_aoe and is_valid_target_type(caster, char_in_aoe): # Hits enemies
			affected_by_aoe.append(char_in_aoe)

	for enemy_hit in affected_by_aoe:
		caster.deal_damage(enemy_hit, damage_mult)

		# Determine knockback direction (away from landing spot)
		var direction = -1

		var enemy_cell = map.get_cell_coords(enemy_hit.global_position)
		for dir_idx in range(6):
			if HexHelper.hex_neighbor(target_cell, dir_idx) == enemy_cell:
				direction = dir_idx
				break
		if direction != -1:
			# Use knockback_damage = 0 if no damage on knockback itself from this skill
			enemy_hit.knockback(knockback_strength, direction, 0)

	cooldown = max_cooldown
	return true

func score_action(caster: CombatCharacter, affected_targets: Array[CombatCharacter], target_cell: Vector2i, map: CombatMap) -> float:
	var score = AIScoringWeights.WEIGHT_BASE_RANGED 

	# Score based on enemies hit by AoE
	var total_damage_dealt = 0.0
	for target in affected_targets: # affected_targets are those hit by the landing AoE
		if is_valid_target_type(caster, target): # Is an enemy
			var damage_to_this_target = caster.get_damage() * damage_mult
			total_damage_dealt += damage_to_this_target
			if target.health <= damage_to_this_target:
				score += AIScoringWeights.WEIGHT_KILL_BONUS # Half bonus as it's AoE
			score -= target.shield * AIScoringWeights.WEIGHT_SHIELD_ENEMY

	score += total_damage_dealt * AIScoringWeights.WEIGHT_DAMAGE

	# Score positioning advantage (e.g., moving closer to a primary target or to safety)
	var caster_current_pos = map.get_cell_coords(caster.global_position)
	# Example: Value getting closer to lowest HP enemy OR flanking
	var players = map.get_alive_party_members() # Assuming AI is targeting players
	if not players.is_empty():
		var primary_target = players[0] # Find lowest HP for example
		for p in players: if p.health < primary_target.health: primary_target = p

		var dist_before = HexHelper.distance(caster_current_pos, map.get_cell_coords(primary_target.global_position))
		var dist_after = HexHelper.distance(target_cell, map.get_cell_coords(primary_target.global_position))
		score += (dist_before - dist_after) * AIScoringWeights.WEIGHT_POSITIONING_CLOSER

	return score

func generate_targets(caster: CombatCharacter, map: CombatMap) -> Array[TargetInfo]:
	var targets: Array[TargetInfo] = []
	var caster_pos = map.get_cell_coords(caster.global_position)
	var potential_landing_cells = HexHelper.hex_reachable(caster_pos, leap_range, map.can_walk)

	for landing_cell in potential_landing_cells:
		if landing_cell == caster_pos or map.cell_occupied(landing_cell):
			continue

		# Determine who would be hit by the AoE if landing here
		var affected_by_aoe_on_land: Array[CombatCharacter] = []
		var landing_aoe_cells = HexHelper.hex_reachable(landing_cell, aoe_radius_on_land, func(_h):return true)
		for cell_in_aoe in landing_aoe_cells:
			if cell_in_aoe == landing_cell: continue # AoE is adjacent to landing
			var char_in_aoe = map.get_character(cell_in_aoe)
			if is_valid_target_type(caster, char_in_aoe):
				affected_by_aoe_on_land.append(char_in_aoe)

		# Add this leap destination if it provides an offensive opportunity or is just a valid move
		targets.append(TargetInfo.new(
			TargetInfo.TargetType.CELL, # Primary target is the landing cell
			null,
			landing_cell,
			affected_by_aoe_on_land # Characters hit by the landing shockwave
		))
	return targets

func get_skill_name() -> String: return "Bounding Leap"
func get_skill_description() -> String:
	return "Leap to a cell in a %d-cell radius. Enemies adjacent to your landing spot take %.2fx base damage and are knockbacked." % [leap_range, damage_mult] + \
		   "\nCooldown: %d turns." % max_cooldown
func get_skill_icon() -> Texture: return load("res://assets/ui/skills/bounding_leap.png") # Placeholder
func get_skill_range() -> int: return leap_range # This is range to the landing cell

func target_allies() -> bool: return false
func target_enemies() -> bool: return true # The AoE part targets enemies
func target_self() -> bool: return false # Targets a cell

func is_melee() -> bool: return false # It's a movement/AoE initiation

func highlight_targets(from: CombatCharacter, map: CombatMap) -> Array[Vector2i]:
	var caster_pos = map.get_cell_coords(from.global_position)
	var curr_highlighted_cells = HexHelper.hex_reachable(caster_pos, leap_range, func(_hex: Vector2i): return true).filter(func (cell): return map.can_walk((cell)))

	for cell in curr_highlighted_cells:
		if map.cell_occupied(cell):
			continue 
		map.set_cell(0, cell, 22, map.get_cell_atlas_coords(0, cell), 1)

	return curr_highlighted_cells

func highlight_mouse_pos(from: CombatCharacter, mouse_pos: Vector2i, map: CombatMap) -> Array[Vector2i]:
	map.reset_map()

	var caster_pos = map.get_cell_coords(from.global_position)
	var curr_highlighted_cells = HexHelper.hex_reachable(caster_pos, leap_range, func(_hex: Vector2i): return true).filter(func (cell): return map.can_walk((cell)))
	for cell in curr_highlighted_cells:
		if map.cell_occupied(cell):
			continue 
		map.set_cell(0, cell, 22, map.get_cell_atlas_coords(0, cell), 1)

	# If mouse is over a valid center point, highlight the AoE
	if mouse_pos in curr_highlighted_cells and not map.cell_occupied(mouse_pos):
		map.set_cell(0, mouse_pos, 22, map.get_cell_atlas_coords(0, mouse_pos), 2) # Hovered target cell
		var curr_aoe_highlight = HexHelper.hex_reachable(mouse_pos, aoe_radius_on_land, func(hex): return map.can_walk(hex))

		for cell in curr_aoe_highlight:
			var character = map.get_character(cell)
			if is_valid_target_type(from, character):
				map.set_cell(0, cell, 22, map.get_cell_atlas_coords(0, cell), 5)

	return curr_highlighted_cells # Return the valid center points

### charge.gd ###
extends Skill
class_name Charge

var damage_mult := 3
var max_cooldown := 3
var curr_highlighted_cells: Array[Vector2i] = []

func use_skill(from: CombatCharacter, skill_pos: Vector2i, map: CombatMap) -> bool:
	var skill_target = map.get_character(skill_pos)
	if not is_valid_target_type(from, skill_target):
		return false

	from.attack(map.to_local(skill_target.global_position))
	from.deal_damage(skill_target, damage_mult)
	cooldown = max_cooldown
	return true

func score_action(caster: CombatCharacter, potential_targets: Array[CombatCharacter], target_cell: Vector2i, map: CombatMap) -> float:
	if potential_targets.is_empty(): return 0.0
	var target = potential_targets[0]

	var score = AIScoringWeights.WEIGHT_BASE_RANGED
	var potential_damage = caster.get_damage() * damage_mult

	score += potential_damage * AIScoringWeights.WEIGHT_DAMAGE

	if target.health <= potential_damage:
		score += AIScoringWeights.WEIGHT_KILL_BONUS
	else:
		score += (1.0 - (target.health / target.max_health)) * potential_damage * AIScoringWeights.WEIGHT_DAMAGE_PER_HP

	# Score the movement aspect (getting into melee)
	var current_pos = map.get_cell_coords(caster.global_position)
	var dist = HexHelper.distance(current_pos, target_cell)
	if dist > 1: # Only value the move if actually moving
		score += dist * AIScoringWeights.WEIGHT_POSITIONING_CLOSER * 0.5 # Less valuable than pure move as damage is main point

	return score

func generate_targets(caster: CombatCharacter, map: CombatMap) -> Array[TargetInfo]:
	# Targets enemies along columns up to range
	var targets: Array[TargetInfo] = []
	var caster_pos = map.get_cell_coords(caster.global_position)

	for i in range(6): # Check all 6 directions
		var current_cell = HexHelper.hex_neighbor(caster_pos, i)
		if not map.can_walk(current_cell) or map.cell_occupied(current_cell):
			continue # Skip this column if blocked

		for j in range(get_skill_range()+1):
			current_cell = HexHelper.hex_neighbor(current_cell, i)
			if not map.can_walk(current_cell):
				break # Stop checking this column if blocked

			if map.cell_occupied(current_cell) :
				var target_char = map.get_character(current_cell)
				if is_valid_target_type(caster, target_char):
					targets.append(TargetInfo.new(
						TargetInfo.TargetType.CHARACTER, target_char, current_cell, [target_char]
					))
				break
	return targets	

	
func get_skill_name() -> String:
	return "Charge"

func get_skill_description() -> String:
	return "Charge a target from up to three tiles away, dealing " + str(damage_mult) + " times your base damage.\n" + \
		"Can only target enemies not adjacent to you, in a straight line.\n" + \
		"Cooldown: " + str(max_cooldown) + " turns\n" + \
		"Range: " + str(get_skill_range()) + " cells.\n"

func get_skill_icon() -> Texture:
	return load("res://assets/ui/skills/basic_slash.png")

func get_skill_range() -> int:
	return 3

func target_allies() -> bool:
	return false

func target_enemies() -> bool:
	return true

func target_self() -> bool:
	return false
	
func is_melee() -> bool:
	return false

func highlight_targets(from: CombatCharacter, map: CombatMap) -> Array[Vector2i]:
	curr_highlighted_cells = map.highlight_columns(map.get_cell_coords(from.global_position), get_skill_range())
	return curr_highlighted_cells

func highlight_mouse_pos(from: CombatCharacter, _mouse_pos: Vector2i, map: CombatMap) -> Array[Vector2i]:
	return highlight_targets(from, map)

### defensive_stance.gd ###
extends Skill
class_name DefensiveStance

var max_cooldown := 5
var curr_highlighted_cells: Array[Vector2i] = []
var duration := 5

func use_skill(from: CombatCharacter, skill_pos: Vector2i, map: CombatMap) -> bool:
	var skill_target = map.get_character(skill_pos)
	if is_valid_target_type(from, skill_target):
		from.gain_status("defensive", duration+1)
		cooldown = max_cooldown
		skill_finished.emit()
		return true

	return false

func score_action(from: CombatCharacter, _potential_targets: Array[CombatCharacter], _target_cell: Vector2i, map: CombatMap) -> float:
	# Self buff
	var score = AIScoringWeights.WEIGHT_BUFF_POSITIVE

	var health_percent = from.health / from.max_health
	score += (1.0 - health_percent) * AIScoringWeights.WEIGHT_HEAL_LOW_HP_BONUS * 0.6 # Value more when low HP

	# Value more if likely to be attacked
	var enemies_nearby = 0
	var caster_pos = map.get_cell_coords(from.global_position)
	for p in map.get_alive_party_members():
		if HexHelper.distance(caster_pos, map.get_cell_coords(p.global_position)) <= 3:
			enemies_nearby += 1
	score += enemies_nearby * 6.0

	if from.char_statuses["vulnerable"] > 0:
		score += AIScoringWeights.WEIGHT_SETUP_BONUS # Removes vulnerable

	if from.char_statuses["defensive"] > 0:
		score *= 0.3 # Less value if already defensive

	return score

func generate_targets(caster: CombatCharacter, map: CombatMap) -> Array[TargetInfo]:
	var caster_pos = map.get_cell_coords(caster.global_position)
	if is_valid_target_type(caster, caster):
		return [TargetInfo.new(
			TargetInfo.TargetType.SELF_CAST, caster, caster_pos, [caster]
		)]
	else:
		return []

	
func get_skill_name() -> String:
	return "Defensive Stance"

func get_skill_description() -> String:
	return "Reduce damage taken by 50% for " + str(duration) + " turns.\n" + \
		"Cooldown: " + str(max_cooldown) + " turns.\n" + \
		"Range: yourself.\n"

func get_skill_icon() -> Texture:
	return load("res://assets/ui/skills/defensive_stance.png")

func get_skill_range() -> int:
	return 0

func target_allies() -> bool:
	return false

func target_enemies() -> bool:
	return false

func target_self() -> bool:
	return true
	
func is_melee() -> bool:
	return true

func highlight_targets(from: CombatCharacter, map: CombatMap) -> Array[Vector2i]:
	var cell = map.get_cell_coords(from.global_position)
	curr_highlighted_cells = [cell]
	map.set_cell(0, cell, 22, map.get_cell_atlas_coords(0, cell), 7)

	return curr_highlighted_cells

func highlight_mouse_pos(_from: CombatCharacter, mouse_pos: Vector2i, map: CombatMap) -> Array[Vector2i]:
	for cell in curr_highlighted_cells:
		map.set_cell(0, cell, 22, map.get_cell_atlas_coords(0, cell), 7)
		if mouse_pos == cell:
			map.set_cell(0, cell, 22, map.get_cell_atlas_coords(0, cell), 8)
			
	return curr_highlighted_cells


### frenzy.gd ###
extends Skill
class_name Frenzy

var damage := 0
var max_cooldown := 5
var curr_highlighted_cells: Array[Vector2i] = []
var duration := 3

func use_skill(from: CombatCharacter, skill_pos: Vector2i, map: CombatMap) -> bool:
	var skill_target = map.get_character(skill_pos)
	if is_valid_target_type(from, skill_target) :
		from.gain_status("vulnerable", duration+1)
		from.gain_status("strong", duration+1)
		cooldown = max_cooldown
		skill_finished.emit()
		return true

	return false

func score_action(caster: CombatCharacter, _potential_targets: Array[CombatCharacter], _target_cell: Vector2i, map: CombatMap) -> float:
	# Self buff (Strong + Vulnerable)
	var score = AIScoringWeights.WEIGHT_BUFF_POSITIVE # Base value, offset by risk

	# Calculate potential damage increase value
	var enemies_nearby = 0
	var caster_pos = map.get_cell_coords(caster.global_position)
	for p in map.get_alive_party_members():
		if HexHelper.distance(caster_pos, map.get_cell_coords(p.global_position)) <= caster.move_range + 1:
			enemies_nearby += 1
	# Rough estimate: Value based on potential extra damage over duration vs nearby enemies
	var potential_extra_damage = caster.get_damage() * 1.5 # Damage increase per attack
	score += enemies_nearby * potential_extra_damage * min(duration, 2) # Estimate 2 attacks over duration

	# Penalize for Vulnerable status
	score -= AIScoringWeights.WEIGHT_BUFF_NEGATIVE * 0.5  # Vulnerable is very risky
	# Penalize more if low health or already defensive (overrides defensive)
	if caster.health < caster.max_health * 0.6:
		score -= 20.0
	if caster.char_statuses["defensive"] > 0:
		score -= 10.0 # Losing defensive stance is bad

	# Less valuable if already strong
	if caster.char_statuses["strong"] > 0:
		score *= 0.3

	return max(0.0, score)

func generate_targets(caster: CombatCharacter, map: CombatMap) -> Array[TargetInfo]:
	var caster_pos = map.get_cell_coords(caster.global_position)
	if is_valid_target_type(caster, caster):
		return [TargetInfo.new(
			TargetInfo.TargetType.SELF_CAST, caster, caster_pos, [caster]
		)]
	else:
		return []
	
func get_skill_name() -> String:
	return "Frenzy"

func get_skill_description() -> String:
	return "Increase attack damage by 50% and receive 50% more damage for " + str(duration) + ".\n" + \
		"Cooldown: " + str(max_cooldown) + " turns.\n" + \
		"Range: yourself.\n"

func get_skill_icon() -> Texture:
	return load("res://assets/ui/skills/frenzy.png")

func get_skill_range() -> int:
	return 0

func target_allies() -> bool:
	return false

func target_enemies() -> bool:
	return false

func target_self() -> bool:
	return true
	
func is_melee() -> bool:
	return true

func highlight_targets(from: CombatCharacter, map: CombatMap) -> Array[Vector2i]:
	var cell = map.get_cell_coords(from.global_position)
	curr_highlighted_cells = [cell]
	map.set_cell(0, cell, 22, map.get_cell_atlas_coords(0, cell), 7)

	return curr_highlighted_cells

func highlight_mouse_pos(_from: CombatCharacter, mouse_pos: Vector2i, map: CombatMap) -> Array[Vector2i]:
	for cell in curr_highlighted_cells:
		map.set_cell(0, cell, 22, map.get_cell_atlas_coords(0, cell), 7)
		if mouse_pos == cell:
			map.set_cell(0, cell, 22, map.get_cell_atlas_coords(0, cell), 8)
			
	return curr_highlighted_cells


### rage_slam.gd ###
extends MeleeSkill
class_name RageSlam

var damage_mult := 4
var max_cooldown := 4
var targets_number := 3

func use_skill(from: CombatCharacter, skill_pos: Vector2i, map: CombatMap) -> bool:
	if skill_pos in curr_highlighted_cells:
		var damage = damage_mult * from.get_damage()
		var char_list = []
		for cell in curr_highlighted_cells :
			var character: CombatCharacter = map.get_character(cell)
			if character:
				char_list.append(character)

		char_list.shuffle()
		char_list = char_list.slice(0, targets_number)
		for character in char_list:
			from.deal_damage(character, damage)


		cooldown = max_cooldown
		skill_finished.emit()
		return true

	return false

func score_action(caster: CombatCharacter, potential_targets: Array[CombatCharacter], _target_cell: Vector2i, _map: CombatMap) -> float:
	# AoE Melee - Hits up to 3 random adjacent characters
	# Score based on expected hits on enemies vs allies
	var score = AIScoringWeights.WEIGHT_BASE_MELEE
	var potential_damage = caster.get_damage() * damage_mult

	if potential_targets.size() == 0:
		return 0.0

	var combinations = []
	if potential_targets.size() <= targets_number:
		combinations.append(potential_targets)
	else:
		for i in range(potential_targets.size() - targets_number + 1):
			for j in range(i + 1, potential_targets.size()):
				for k in range(j + 1, potential_targets.size()):
					combinations.append([potential_targets[i], potential_targets[j], potential_targets[k]])



	var expected_ally_hits = 0.0
	var enemy_damage_score = 0.0
	for combination in combinations:
		for target in combination:
			if target and target is PlayerCombatCharacter:
				enemy_damage_score += potential_damage * AIScoringWeights.WEIGHT_DAMAGE
				if target.health < potential_damage :
					enemy_damage_score += AIScoringWeights.WEIGHT_KILL_BONUS
				else :
					enemy_damage_score += potential_damage * (1 - target.health / target.max_health) * AIScoringWeights.WEIGHT_DAMAGE_PER_HP # Scale damage based on target health
			elif target and target.is_ally(caster):
				expected_ally_hits += 1

	# Penalize expected damage to allies
	enemy_damage_score /= combinations.size() # Average score
	var ally_penalty = expected_ally_hits * AIScoringWeights.WEIGHT_AOE_TARGET_ALLY_DAMAGE_PENALTY / 10 / combinations.size() # Scale penalty

	score += enemy_damage_score + ally_penalty
	return max(0.0, score)

func generate_targets(caster: CombatCharacter, map: CombatMap) -> Array[TargetInfo]:
	var caster_pos = map.get_cell_coords(caster.global_position)
	var adjacent_chars: Array[CombatCharacter] = []
	var potential_cells = HexHelper.hex_reachable(caster_pos, get_skill_range(), map.can_walk)

	for cell in potential_cells:
			var target_char = map.get_character(cell)
			if is_valid_target_type(caster, target_char):
				adjacent_chars.append(target_char)

	if not adjacent_chars.is_empty():
		return [TargetInfo.new(
			TargetInfo.TargetType.SELF_AOE_ACTIVATION, # Activation type
			caster,
			caster_pos,
			adjacent_chars # List of *all* adjacent characters (random selection later)
		)]
	return []

	
func get_skill_name() -> String:
	return "Rage Slam"

func get_skill_description() -> String:
	return "Deal " + str(damage_mult) + " times your base damage to up to " + str(targets_number) + " random adjacent characters.\n" + \
		"Cooldown: " + str(max_cooldown) + " turns.\n" + \
		"Range: " + str(get_skill_range()) + " cells.\n"

func get_skill_icon() -> Texture:
	return load("res://assets/ui/skills/rage_slam.png")

func get_skill_range() -> int:
	return 1

func target_allies() -> bool:
	return false

func target_enemies() -> bool:
	return true

func target_self() -> bool:
	return false
	
func is_melee() -> bool:
	return true

func highlight_targets(from: CombatCharacter, map: CombatMap) -> Array[Vector2i]:
	var can_attack = func(hex: Vector2i): return map.can_walk(hex)
	curr_highlighted_cells = HexHelper.hex_reachable(map.get_cell_coords(from.global_position), get_skill_range(), can_attack)
	curr_highlighted_cells.erase(map.get_cell_coords(from.global_position))
	for cell in curr_highlighted_cells:
		map.set_cell(0, cell, 22, map.get_cell_atlas_coords(0, cell), 3)
		if map.get_character(cell):
			map.set_cell(0, cell, 22, map.get_cell_atlas_coords(0, cell), 4)


	return curr_highlighted_cells

func highlight_mouse_pos(_from: CombatCharacter, mouse_pos: Vector2i, map: CombatMap) -> Array[Vector2i]:
	for cell in curr_highlighted_cells:
		map.set_cell(0, cell, 22, map.get_cell_atlas_coords(0, cell), 3)

		if map.get_character(cell):
			if mouse_pos in curr_highlighted_cells :
				map.set_cell(0, cell, 22, map.get_cell_atlas_coords(0, cell), 5)
			else : 
				map.set_cell(0, cell, 22, map.get_cell_atlas_coords(0, cell), 4)
			
	return curr_highlighted_cells



### blood_fury.gd ###
extends Skill
class_name BloodFury

var damage := 0
var max_cooldown := 6
var duration := 3
var leech_strength = 33
var curr_highlighted_cells: Array[Vector2i] = []

func use_skill(from: CombatCharacter, skill_pos: Vector2i, _map: CombatMap) -> bool:
	var skill_target = _map.get_character(skill_pos)
	if is_valid_target_type(from, skill_target) :
		from.gain_status("leech", duration, leech_strength+1)
		cooldown = max_cooldown
		skill_finished.emit()
		return true

	return false

func score_action(caster: CombatCharacter, _potential_targets: Array[CombatCharacter], _target_cell: Vector2i, map: CombatMap) -> float:
	# Self buff - leech
	var score = AIScoringWeights.WEIGHT_BUFF_POSITIVE * 1.1 # Good sustain buff

	# Value more if caster is lower health
	score += (1.0 - caster.health / caster.max_health) * AIScoringWeights.WEIGHT_HEAL_LOW_HP_BONUS

	# Value more if likely to deal damage soon
	var enemies_nearby = 0
	var caster_pos = map.get_cell_coords(caster.global_position)
	for p in map.get_alive_party_members():
		if HexHelper.distance(caster_pos, map.get_cell_coords(p.global_position)) <= caster.move_range + 1:
			enemies_nearby += 1
	score += enemies_nearby * 4.0

	if caster.char_statuses["leech"].size() > 0:
		score *= 0.8

	return score

func generate_targets(caster: CombatCharacter, map: CombatMap) -> Array[TargetInfo]:
	# Self-cast only
	var caster_pos = map.get_cell_coords(caster.global_position)
	if is_valid_target_type(caster, caster):
		return [TargetInfo.new(
			TargetInfo.TargetType.SELF_CAST, caster, caster_pos, [caster]
		)]
	else:
		return []

	
func get_skill_name() -> String:
	return "Blood Fury"

func get_skill_description() -> String:
	return "For the next " + str(duration) + " turns, heal for " + str(leech_strength) + "% of the damage dealt.\n" + \
		"Cooldown: " + str(max_cooldown) + " turns.\n" + \
		"Range: yourself.\n"

func get_skill_icon() -> Texture:
	return load("res://assets/ui/skills/blood_fury.png")

func get_skill_range() -> int:
	return 0

func target_allies() -> bool:
	return false

func target_enemies() -> bool:
	return false

func target_self() -> bool:
	return true
	
func is_melee() -> bool:
	return true

func highlight_targets(from: CombatCharacter, map: CombatMap) -> Array[Vector2i]:
	var cell = map.get_cell_coords(from.global_position)
	curr_highlighted_cells = [cell]
	map.set_cell(0, cell, 22, map.get_cell_atlas_coords(0, cell), 7)

	return curr_highlighted_cells

func highlight_mouse_pos(_from: CombatCharacter, mouse_pos: Vector2i, map: CombatMap) -> Array[Vector2i]:
	for cell in curr_highlighted_cells:
		map.set_cell(0, cell, 22, map.get_cell_atlas_coords(0, cell), 7)
		if mouse_pos == cell:
			map.set_cell(0, cell, 22, map.get_cell_atlas_coords(0, cell), 8)
			
	return curr_highlighted_cells


### raging_blow.gd ###
extends MeleeSkill
class_name RagingBlow

var damage_mult := 5
var max_cooldown := 4

func use_skill(from: CombatCharacter, skill_pos: Vector2i, map: CombatMap) -> bool:
	var target = map.get_character(skill_pos)
	if is_valid_target_type(from, target) and HexHelper.distance(map.get_cell_coords(from.global_position), skill_pos) <= get_skill_range():
		var actual_damage_mult = damage_mult
		if target.health < target.max_health * 3/10:
			actual_damage_mult *= 2
		from.deal_damage(target, actual_damage_mult)
		from.attack(map.to_local(target.global_position))
		cooldown = max_cooldown
		return true

	return false

func score_action(caster: CombatCharacter, potential_targets: Array[CombatCharacter], _target_cell: Vector2i, _map: CombatMap) -> float:
	if potential_targets.is_empty(): return 0.0
	var target = potential_targets[0]

	var score = AIScoringWeights.WEIGHT_BASE_MELEE # High potential damage melee attack
	var actual_damage_mult = damage_mult
	# Check execute condition
	if target.health < target.max_health * 0.3:
		actual_damage_mult *= 2
		score += 25.0 # Bonus for meeting execute condition

	var potential_damage = caster.get_damage() * actual_damage_mult
	score += potential_damage * AIScoringWeights.WEIGHT_DAMAGE

	if target.health <= potential_damage:
		score += AIScoringWeights.WEIGHT_KILL_BONUS
	else:
		# Less bonus for low health here as execute is the main factor
		score += (1.0 - (target.health / target.max_health)) * potential_damage * AIScoringWeights.WEIGHT_DAMAGE_PER_HP * 0.5

	score -= target.shield * AIScoringWeights.WEIGHT_SHIELD_ENEMY
	return score

func generate_targets(caster: CombatCharacter, map: CombatMap) -> Array[TargetInfo]:
	var targets: Array[TargetInfo] = []
	var caster_pos = map.get_cell_coords(caster.global_position)
	var potential_cells = HexHelper.hex_reachable(caster_pos, get_skill_range(), map.can_walk)

	for cell in potential_cells:
		if cell != caster_pos:
			var target_char = map.get_character(cell)
			if target_char and is_valid_target_type(caster, target_char):
				targets.append(TargetInfo.new(
					TargetInfo.TargetType.CHARACTER, target_char, cell, [target_char]
				))
	return targets

	
func get_skill_name() -> String:
	return "Raging Blow"

func get_skill_description() -> String:
	return "Deal " + str(damage_mult) + " times your basic damage to an enemy. It the enemy health is below 30%, deal double damage.\n" + \
		"Cooldown: " + str(max_cooldown) + " turns.\n" + \
		"Range: " + str(get_skill_range()) + " cells.\n"

func get_skill_icon() -> Texture:
	return load("res://assets/ui/skills/raging_blow.png")

func get_skill_range() -> int:
	return 1

func target_allies() -> bool:
	return false

func target_enemies() -> bool:
	return true

func target_self() -> bool:
	return false
	
func is_melee() -> bool:
	return true



### war_cry.gd ###
extends Skill
class_name WarCry

var damage := 0
var max_cooldown := 4
var duration := 2
var curr_highlighted_cells: Array[Vector2i] = []

func use_skill(from: CombatCharacter, skill_pos: Vector2i, map: CombatMap) -> bool:
	var caster_pos = map.get_cell_coords(from.global_position)
	var aoe_cells = HexHelper.hex_reachable(caster_pos, get_skill_range(), func(_hex): return true).filter(map.can_walk)
	if skill_pos in aoe_cells:
		for cell in curr_highlighted_cells :
			var character: CombatCharacter = map.get_character(cell)
			if is_valid_target_type(from, character): # Is Ally?
				character.gain_status("strong", duration+1 if character == from else duration)
		cooldown = max_cooldown
		skill_finished.emit()
		return true

	return false

func score_action(caster: CombatCharacter, _potential_targets: Array[CombatCharacter], _target_cell: Vector2i, map: CombatMap) -> float:
	var score = AIScoringWeights.WEIGHT_BUFF_POSITIVE 

	var allies_affected: Array[CombatCharacter] = []
	var caster_pos = map.get_cell_coords(caster.global_position)
	var aoe_cells = HexHelper.hex_reachable(caster_pos, get_skill_range(), func(_hex): return true)

	for cell in aoe_cells:
		var character = map.get_character(cell)
		if is_valid_target_type(caster, character): # Is Ally?
			allies_affected.append(character)

	if allies_affected.is_empty(): return 0.0 # No value if no allies benefit

	# Score based on number of allies buffed and their potential damage output
	var buff_value_per_ally = AIScoringWeights.WEIGHT_BUFF_POSITIVE * duration * 0.3 # Estimate value of Strong
	score += allies_affected.size() * buff_value_per_ally * AIScoringWeights.WEIGHT_AOE_TARGET_ALLY_BUFF

	# Bonus if allies are near enemies
	var enemies_near_allies = 0
	for ally in allies_affected:
		var ally_pos = map.get_cell_coords(ally.global_position)
		for p in map.get_alive_party_members(): # Assuming AI vs Player
			if HexHelper.distance(ally_pos, map.get_cell_coords(p.global_position)) <= 2:
				enemies_near_allies += 1
				break # Count each ally only once
	score += enemies_near_allies * 5.0

	return score

func generate_targets(caster: CombatCharacter, map: CombatMap) -> Array[TargetInfo]:
	# Self-activation, affects allies in radius
	var caster_pos = map.get_cell_coords(caster.global_position)
	var allies_affected: Array[CombatCharacter] = []
	var aoe_cells = HexHelper.hex_reachable(caster_pos, get_skill_range(), func(_hex): return true)

	for cell in aoe_cells:
		var target_char = map.get_character(cell)
		if is_valid_target_type(caster, target_char): 
			allies_affected.append(target_char)

	if not allies_affected.is_empty():
		return [TargetInfo.new(
			TargetInfo.TargetType.SELF_AOE_ACTIVATION,
			caster,
			caster_pos,
			allies_affected
		)]
	else:
		return []

	
func get_skill_name() -> String:
	return "War Cry"

func get_skill_description() -> String:
	return "All allies in a " + str(get_skill_range()) + "-cell radius deal 50% more damage for " + str(duration) + " turns.\n" + \
		"Cooldown: " + str(max_cooldown) + " turns.\n" + \
		"Range: " + str(get_skill_range()) + " cells.\n"

func get_skill_icon() -> Texture:
	return load("res://assets/ui/skills/war_cry.png")

func get_skill_range() -> int:
	return 3

func target_allies() -> bool:
	return true

func target_enemies() -> bool:
	return false

func target_self() -> bool:
	return false
	
func is_melee() -> bool:
	return true

func highlight_targets(from: CombatCharacter, map: CombatMap) -> Array[Vector2i]:
	var can_attack = func(hex: Vector2i): return map.can_walk(hex)
	curr_highlighted_cells = HexHelper.hex_reachable(map.get_cell_coords(from.global_position), get_skill_range(), can_attack)
	curr_highlighted_cells.erase(map.get_cell_coords(from.global_position))

	for cell in curr_highlighted_cells:
		map.set_cell(0, cell, 22, map.get_cell_atlas_coords(0, cell), 6)
		var cell_char = map.get_character(cell)
		if cell_char and cell_char is PlayerCombatCharacter:
			map.set_cell(0, cell, 22, map.get_cell_atlas_coords(0, cell), 7)
		if cell_char and cell_char is AICombatCharacter:
			map.set_cell(0, cell, 22, map.get_cell_atlas_coords(0, cell), 0)
			curr_highlighted_cells.erase(cell)
	return curr_highlighted_cells

func highlight_mouse_pos(_from: CombatCharacter, mouse_pos: Vector2i, map: CombatMap) -> Array[Vector2i]:
	for cell in curr_highlighted_cells:
		map.set_cell(0, cell, 22, map.get_cell_atlas_coords(0, cell), 6)
		if mouse_pos in curr_highlighted_cells:
			map.set_cell(0, cell, 22, map.get_cell_atlas_coords(0, cell), 8)
			
	return curr_highlighted_cells


### whirlwind.gd ###
extends Skill
class_name Whirlwind

var damage_mult := 5
var max_cooldown := 3

var curr_highlighted_cells: Array[Vector2i] = []

func use_skill(from: CombatCharacter, skill_pos: Vector2i, map: CombatMap) -> bool:
	var cells = HexHelper.hex_reachable(map.get_cell_coords(from.global_position), get_skill_range(), map.can_walk)
	if skill_pos in cells:
		for cell in cells:
			var target: CombatCharacter = map.get_character(cell)
			if is_valid_target_type(from, target):
				from.deal_damage(target, damage_mult)
		cooldown = max_cooldown
		skill_finished.emit()
		return true

	return false

func score_action(caster: CombatCharacter, potential_targets: Array[CombatCharacter], _target_cell: Vector2i, _map: CombatMap) -> float:
	# AoE Melee Damage (Adjacent Enemies)
	# potential_targets should be adjacent enemies hit
	if potential_targets.is_empty(): return 0.0

	var score = AIScoringWeights.WEIGHT_BASE_MELEE # Base for melee AoE
	var potential_damage_per_target = caster.get_damage() * damage_mult
	var total_enemy_damage_score = 0.0

	for target in potential_targets:
		var enemy_score = potential_damage_per_target * AIScoringWeights.WEIGHT_DAMAGE
		if target.health <= potential_damage_per_target:
			enemy_score += AIScoringWeights.WEIGHT_KILL_BONUS
		else:
			enemy_score += (1.0 - (target.health / target.max_health)) * potential_damage_per_target * AIScoringWeights.WEIGHT_DAMAGE_PER_HP
		total_enemy_damage_score += enemy_score

	score += total_enemy_damage_score * AIScoringWeights.WEIGHT_AOE_TARGET_ENEMY

	return score

func generate_targets(caster: CombatCharacter, map: CombatMap) -> Array[TargetInfo]:
	# Self-activation, affects adjacent enemies
	var caster_pos = map.get_cell_coords(caster.global_position)
	var enemies_affected: Array[CombatCharacter] = []
	var aoe_cells = HexHelper.hex_reachable(caster_pos, get_skill_range(), map.can_walk)

	for cell in aoe_cells:
		var target_char = map.get_character(cell)
		if is_valid_target_type(caster, target_char): # Checks target_enemies
			enemies_affected.append(target_char)

	if not enemies_affected.is_empty():
		return [TargetInfo.new(
			TargetInfo.TargetType.SELF_AOE_ACTIVATION,
			caster,
			caster_pos,
			enemies_affected
		)]
	else:
		return []

	
func get_skill_name() -> String:
	return "Whirlwind"

func get_skill_description() -> String:
	return "Deal " + str(damage_mult) + " times your base damage to all adjacent enemies.\n" + \
		"Cooldown: " + str(max_cooldown) + " turns.\n" + \
		"Range: " + str(get_skill_range()) + " cells.\n"

func get_skill_icon() -> Texture:
	return load("res://assets/ui/skills/whirlwind.png")

func get_skill_range() -> int:
	return 1

func target_allies() -> bool:
	return false

func target_enemies() -> bool:
	return true

func target_self() -> bool:
	return false
	
func is_melee() -> bool:
	return true

func highlight_targets(from: CombatCharacter, map: CombatMap) -> Array[Vector2i]:
	var can_attack = func(hex: Vector2i): return map.can_walk(hex)
	curr_highlighted_cells = HexHelper.hex_reachable(map.get_cell_coords(from.global_position), get_skill_range(), can_attack)
	curr_highlighted_cells.erase(map.get_cell_coords(from.global_position))

	for cell in curr_highlighted_cells:
		map.set_cell(0, cell, 22, map.get_cell_atlas_coords(0, cell), 1)
		var character = map.get_character(cell)
		if character and character is AICombatCharacter:
			map.set_cell(0, cell, 22, map.get_cell_atlas_coords(0, cell), 3)
		if character and character is PlayerCombatCharacter:
			map.set_cell(0, cell, 22, map.get_cell_atlas_coords(0, cell), 6)

	return curr_highlighted_cells

func highlight_mouse_pos(_from: CombatCharacter, mouse_pos: Vector2i, map: CombatMap) -> Array[Vector2i]:
	for cell in curr_highlighted_cells:
		map.set_cell(0, cell, 22, map.get_cell_atlas_coords(0, cell), 1)
		if mouse_pos in curr_highlighted_cells:
			map.set_cell(0, cell, 22, map.get_cell_atlas_coords(0, cell), 2)

		var cell_character = map.get_character(cell)
		if cell_character :
			if cell_character is AICombatCharacter:
				if mouse_pos in curr_highlighted_cells:
					map.set_cell(0, cell, 22, map.get_cell_atlas_coords(0, cell), 5)
				else:
					map.set_cell(0, cell, 22, map.get_cell_atlas_coords(0, cell), 3)
			if cell_character is PlayerCombatCharacter:
				if mouse_pos in curr_highlighted_cells:
					map.set_cell(0, cell, 22, map.get_cell_atlas_coords(0, cell), 8)
				else:
					map.set_cell(0, cell, 22, map.get_cell_atlas_coords(0, cell), 6)

			
	return curr_highlighted_cells



### guardians_aura.gd ###
extends Skill
class_name GuardiansAura

var max_cooldown := 5
var duration := 2
var curr_highlighted_cells: Array[Vector2i] = []

func use_skill(from: CombatCharacter, skill_pos: Vector2i, map: CombatMap) -> bool:
	var cells = HexHelper.hex_reachable(map.get_cell_coords(from.global_position), get_skill_range(), func (_hex) : return true).filter(map.can_walk)
	if skill_pos in cells:
		for cell in cells :
			var character: CombatCharacter = map.get_character(cell)
			if is_valid_target_type(from, character):
				character.gain_status("defensive", duration+1 if character == from else duration)
		cooldown = max_cooldown
		skill_finished.emit()
		return true

	return false

func score_action(_caster: CombatCharacter, potential_targets: Array[CombatCharacter], _target_cell: Vector2i, map: CombatMap) -> float:
	# AoE Ally Buff (Defensive)
	var score = AIScoringWeights.WEIGHT_BUFF_POSITIVE

	if potential_targets.is_empty(): return 0.0

	var buff_value_per_ally = AIScoringWeights.WEIGHT_BUFF_POSITIVE * duration * 0.7
	score += potential_targets.size() * buff_value_per_ally * AIScoringWeights.WEIGHT_AOE_TARGET_ALLY_BUFF

	# Value more if allies are low health or near enemies
	var low_hp_allies = 0
	var enemies_near_allies = 0
	for ally in potential_targets:
		if ally.health < ally.max_health * 0.6:
			low_hp_allies += 1
		var ally_pos = map.get_cell_coords(ally.global_position)
		for p in map.get_alive_party_members():
			if HexHelper.distance(ally_pos, map.get_cell_coords(p.global_position)) <= 2:
				enemies_near_allies += 1
				break
	score += low_hp_allies * 8.0
	score += enemies_near_allies * 4.0

	return score

func generate_targets(from: CombatCharacter, map: CombatMap) -> Array[TargetInfo]:
	# Self-activation, affects adjacent allies + self
	var caster_pos = map.get_cell_coords(from.global_position)
	var allies_affected: Array[CombatCharacter] = []
	var aoe_cells = HexHelper.hex_reachable(map.get_cell_coords(from.global_position), get_skill_range(), func (_hex) : return true).filter(map.can_walk)

	for cell in aoe_cells:
		var target_char = map.get_character(cell)
		if is_valid_target_type(from, target_char):
			allies_affected.append(target_char)

	if not allies_affected.is_empty():
		return [TargetInfo.new(
			TargetInfo.TargetType.SELF_AOE_ACTIVATION,
			from,
			caster_pos,
			allies_affected
		)]
	else:
		return []

	
func get_skill_name() -> String:
	return "Guardian's Aura"

func get_skill_description() -> String:
	return "You and all adjacent allies take 50% less damage for " + str(duration) + " turns.\n" + \
		"Cooldown: " + str(max_cooldown) + " turns.\n" + \
		"Range: " + str(get_skill_range()) + " cells.\n"

func get_skill_icon() -> Texture:
	return load("res://assets/ui/skills/guardians_aura.png")

func get_skill_range() -> int:
	return 1

func target_allies() -> bool:
	return true

func target_enemies() -> bool:
	return false

func target_self() -> bool:
	return true
	
func is_melee() -> bool:
	return true

func highlight_targets(from: CombatCharacter, map: CombatMap) -> Array[Vector2i]:
	curr_highlighted_cells = HexHelper.hex_reachable(map.get_cell_coords(from.global_position), get_skill_range(), map.can_walk)
	curr_highlighted_cells.erase(map.get_cell_coords(from.global_position))

	for cell in curr_highlighted_cells:
		map.set_cell(0, cell, 22, map.get_cell_atlas_coords(0, cell), 6)
		var cell_char = map.get_character(cell)
		if cell_char and cell_char is PlayerCombatCharacter:
			map.set_cell(0, cell, 22, map.get_cell_atlas_coords(0, cell), 7)
		if cell_char and cell_char is AICombatCharacter:
			map.set_cell(0, cell, 22, map.get_cell_atlas_coords(0, cell), 0)
			curr_highlighted_cells.erase(cell)
	return curr_highlighted_cells

func highlight_mouse_pos(_from: CombatCharacter, mouse_pos: Vector2i, map: CombatMap) -> Array[Vector2i]:
	for cell in curr_highlighted_cells:
		map.set_cell(0, cell, 22, map.get_cell_atlas_coords(0, cell), 6)
		if mouse_pos in curr_highlighted_cells:
			map.set_cell(0, cell, 22, map.get_cell_atlas_coords(0, cell), 8)
		elif map.get_character(cell):
			map.set_cell(0, cell, 22, map.get_cell_atlas_coords(0, cell), 7)
			
	return curr_highlighted_cells


### shield_bash.gd ###
extends MeleeSkill
class_name ShieldBash

var damage_mult := 2
var max_cooldown := 3
var duration := 2

func use_skill(from: CombatCharacter, skill_pos: Vector2i, map: CombatMap) -> bool:
	var target = map.get_character(skill_pos)
	if is_valid_target_type(from, target) and HexHelper.distance(map.get_cell_coords(from.global_position), skill_pos) <= get_skill_range():
		target.gain_status("weak", duration)
		from.deal_damage(target, damage_mult)
		from.attack(map.to_local(target.global_position))
		cooldown = max_cooldown
		skill_finished.emit()
		return true

	return false

func score_action(caster: CombatCharacter, potential_targets: Array[CombatCharacter], _target_cell: Vector2i, _map: CombatMap) -> float:
	if potential_targets.is_empty(): return 0.0
	var target = potential_targets[0]

	var score = AIScoringWeights.WEIGHT_BASE_MELEE # Melee Damage + Debuff
	var potential_damage = caster.get_damage() * damage_mult

	# Score damage
	var damage_score = potential_damage * AIScoringWeights.WEIGHT_DAMAGE
	if target.health <= potential_damage:
		damage_score += AIScoringWeights.WEIGHT_KILL_BONUS
	else:
		damage_score += (1.0 - (target.health / target.max_health)) * potential_damage * AIScoringWeights.WEIGHT_DAMAGE_PER_HP
	damage_score -= target.shield * AIScoringWeights.WEIGHT_SHIELD_ENEMY

	# Score debuff (Weak)
	var debuff_score = AIScoringWeights.WEIGHT_BUFF_NEGATIVE * duration
	if target.char_statuses["weak"] > 0:
		debuff_score *= 0.8 
	if target.char_statuses["strong"] > 0:
		debuff_score *= 1.5

	score += damage_score + debuff_score
	return score

func generate_targets(caster: CombatCharacter, map: CombatMap) -> Array[TargetInfo]:
	# Standard melee targeting
	var targets: Array[TargetInfo] = []
	var caster_pos = map.get_cell_coords(caster.global_position)
	var potential_cells = HexHelper.hex_reachable(caster_pos, get_skill_range(), map.can_walk)

	for cell in potential_cells:
		var target_char = map.get_character(cell)
		if is_valid_target_type(caster, target_char):
			targets.append(TargetInfo.new(
				TargetInfo.TargetType.CHARACTER, target_char, cell, [target_char]
			))
	return targets

	
func get_skill_name() -> String:
	return "Shield Bash"

func get_skill_description() -> String:
	return "Deal " + str(damage_mult) + " times your base damage and reduce the enemy’s damage by 33% for " + str(duration) + " turns.\n" + \
		"Cooldown: " + str(max_cooldown) + " turns.\n" + \
		"Range: " + str(get_skill_range()) + " cells.\n"

func get_skill_icon() -> Texture:
	return load("res://assets/ui/skills/shield_bash.png")

func get_skill_range() -> int:
	return 1

func target_allies() -> bool:
	return false

func target_enemies() -> bool:
	return true

func target_self() -> bool:
	return false
	
func is_melee() -> bool:
	return true



### inquisition.gd ###
extends Skill
class_name Inquisition

var damage_mult := 3
var max_cooldown := 5

var curr_highlighted_cells: Array[Vector2i] = []

func use_skill(from: CombatCharacter, skill_pos: Vector2i, map: CombatMap) -> bool:
	var cells = HexHelper.hex_reachable(map.get_cell_coords(from.global_position), get_skill_range(), map.can_walk)
	if skill_pos in cells:
		var damage = damage_mult * from.get_damage()
		for cell in cells :
			var character: CombatCharacter = map.get_character(cell)
			if character:
				if from is PlayerCombatCharacter :
					if character is PlayerCombatCharacter :
						character.heal(damage)
					if character is AICombatCharacter :
						from.deal_damage(character, damage_mult)
				if from is AICombatCharacter :
					if character is PlayerCombatCharacter :
						from.deal_damage(character, damage_mult)
					if from is AICombatCharacter :
						character.heal(damage)
		cooldown = max_cooldown
		skill_finished.emit()
		return true

	return false

func score_action(caster: CombatCharacter, potential_targets: Array[CombatCharacter], _target_cell: Vector2i, _map: CombatMap) -> float:
	# AoE Damage (Enemies) + Heal (Allies)
	var score = AIScoringWeights.WEIGHT_BASE_MELEE

	var potential_damage = caster.get_damage() * damage_mult
	var potential_heal = potential_damage # Heal amount equals damage dealt

	var total_enemy_damage_score = 0.0
	var total_ally_heal_score = 0.0
	var enemies_hit = 0
	var allies_healed = 0

	for target in potential_targets:
		if target is PlayerCombatCharacter: # Is Enemy?
			enemies_hit += 1
			var enemy_score = potential_damage * AIScoringWeights.WEIGHT_DAMAGE
			if target.health <= potential_damage:
				enemy_score += AIScoringWeights.WEIGHT_KILL_BONUS
			else:
				enemy_score += (1.0 - (target.health / target.max_health)) * potential_damage * AIScoringWeights.WEIGHT_DAMAGE_PER_HP
			total_enemy_damage_score += enemy_score
		else: # Is Ally?
			allies_healed += 1
			var heal_score = min(potential_heal, target.max_health - target.health) * AIScoringWeights.WEIGHT_HEAL
			heal_score += (1.0 - (target.health / target.max_health)) * potential_heal * AIScoringWeights.WEIGHT_HEAL_LOW_HP_BONUS
			total_ally_heal_score += heal_score

	if enemies_hit == 0 and allies_healed == 0: return 0.0 # No effect

	score += total_enemy_damage_score * AIScoringWeights.WEIGHT_AOE_TARGET_ENEMY
	score += total_ally_heal_score * AIScoringWeights.WEIGHT_AOE_TARGET_ALLY_HEAL

	return max(0.0, score)

func generate_targets(caster: CombatCharacter, map: CombatMap) -> Array[TargetInfo]:
	# Self-activation, affects allies (heal) and enemies (damage) in radius
	var caster_pos = map.get_cell_coords(caster.global_position)
	var characters_affected: Array[CombatCharacter] = []
	var aoe_cells = HexHelper.hex_reachable(caster_pos, get_skill_range(), func (_hex) : return true).filter(map.can_walk)

	for cell in aoe_cells:
		var target_char = map.get_character(cell)
		if is_valid_target_type(caster, target_char): # Affects others
			characters_affected.append(target_char)


	if characters_affected.size() > 0: # Only generate if it hits *someone* relevant
		return [TargetInfo.new(
			TargetInfo.TargetType.SELF_AOE_ACTIVATION,
			caster,
			caster_pos,
			characters_affected # Contains both allies and enemies
		)]
	else:
		return []


	
func get_skill_name() -> String:
	return "Inquisition"

func get_skill_description() -> String:
	return "Deal " + str(damage_mult) + " times your base damage to all enemies and heal all allies within a " + str(get_skill_range()) +"-cell radius for as much.\n" + \
		"Cooldown: " + str(max_cooldown) + " turns.\n" + \
		"Range: " + str(get_skill_range()) + " cells.\n"

func get_skill_icon() -> Texture:
	return load("res://assets/ui/skills/inquisition.png")

func get_skill_range() -> int:
	return 2

func target_allies() -> bool:
	return true

func target_enemies() -> bool:
	return true

func target_self() -> bool:
	return false
	
func is_melee() -> bool:
	return true

func highlight_targets(from: CombatCharacter, map: CombatMap) -> Array[Vector2i]:
	curr_highlighted_cells = HexHelper.hex_reachable(map.get_cell_coords(from.global_position), get_skill_range(), map.can_walk)
	curr_highlighted_cells.erase(map.get_cell_coords(from.global_position))

	for cell in curr_highlighted_cells:
		map.set_cell(0, cell, 22, map.get_cell_atlas_coords(0, cell), 1)
		var character = map.get_character(cell)
		if character and character is AICombatCharacter:
			map.set_cell(0, cell, 22, map.get_cell_atlas_coords(0, cell), 3)
		if character and character is PlayerCombatCharacter:
			map.set_cell(0, cell, 22, map.get_cell_atlas_coords(0, cell), 6)

	return curr_highlighted_cells

func highlight_mouse_pos(_from: CombatCharacter, mouse_pos: Vector2i, map: CombatMap) -> Array[Vector2i]:
	for cell in curr_highlighted_cells:
		map.set_cell(0, cell, 22, map.get_cell_atlas_coords(0, cell), 1)
		if mouse_pos in curr_highlighted_cells:
			map.set_cell(0, cell, 22, map.get_cell_atlas_coords(0, cell), 2)

		var cell_character = map.get_character(cell)
		if cell_character :
			if cell_character is AICombatCharacter:
				if mouse_pos in curr_highlighted_cells:
					map.set_cell(0, cell, 22, map.get_cell_atlas_coords(0, cell), 5)
				else:
					map.set_cell(0, cell, 22, map.get_cell_atlas_coords(0, cell), 3)
			if cell_character is PlayerCombatCharacter:
				if mouse_pos in curr_highlighted_cells:
					map.set_cell(0, cell, 22, map.get_cell_atlas_coords(0, cell), 8)
				else:
					map.set_cell(0, cell, 22, map.get_cell_atlas_coords(0, cell), 6)

			
	return curr_highlighted_cells



### zealous_charge.gd ###
extends Skill
class_name ZealousCharge

var damage_mult := 3
var knockback_distance := 1
var knockback_damage_mult := 1
var stunned_duration := 1
var max_cooldown := 3
var curr_highlighted_cells: Array[Vector2i] = []

func use_skill(from: CombatCharacter, skill_pos: Vector2i, map: CombatMap) -> bool:
	var skill_target = map.get_character(skill_pos)
	if not is_valid_target_type(from, skill_target) or HexHelper.distance(map.get_cell_coords(from.global_position), skill_pos) <= get_skill_range():
		return false

	from.attack(map.to_local(skill_target.global_position))
	from.deal_damage(skill_target, damage_mult)
	skill_target.gain_status("stunned", stunned_duration)
	skill_target.knockback(knockback_distance, _get_knockback_dir(from, skill_target, map), knockback_damage_mult * from.get_damage())
	cooldown = max_cooldown
	return true

func score_action(from: CombatCharacter, potential_targets: Array[CombatCharacter], target_cell: Vector2i, map: CombatMap) -> float:
	if potential_targets.is_empty(): return 0.0
	var potential_target = potential_targets[0]

	var score = AIScoringWeights.WEIGHT_BASE_RANGED # Movement + Damage + Stun + Knockback
	var potential_damage = from.get_damage() * damage_mult

	# Score damage
	var damage_score = potential_damage * AIScoringWeights.WEIGHT_DAMAGE
	if potential_target.health <= potential_damage:
		damage_score += AIScoringWeights.WEIGHT_KILL_BONUS
	else:
		damage_score += (1.0 - (potential_target.health / potential_target.max_health)) * potential_damage * AIScoringWeights.WEIGHT_DAMAGE_PER_HP
	damage_score -= potential_target.shield * 0.1

	# Score stun
	var stun_score = AIScoringWeights.WEIGHT_DISABLE_TURN

	# Score knockback - value based on potential collision or moving target away
	var knockback_score = 5.0 # Base value for displacement
	var knock_dir = _get_knockback_dir(from, potential_target, map)
	if knock_dir != -1:
		var final_kb_pos = target_cell
		var collision = false
		var collision_damage = 0.0
		for i in range(knockback_distance):
			var next_pos = HexHelper.hex_neighbor(final_kb_pos, knock_dir)
			if not map.can_walk(next_pos) or map.cell_occupied(next_pos):
				collision = true
				# Add potential collision damage score
				collision_damage = from.get_damage() * knockback_damage_mult
				knockback_score += collision_damage * AIScoringWeights.WEIGHT_DAMAGE * 0.8 # Collision damage is bonus
				break
			final_kb_pos = next_pos
		if collision:
			knockback_score += 10.0 # Bonus for causing collision

	# Score movement aspect (less than pure Charge as CC is primary)
	score += HexHelper.distance(map.get_cell_coords(from.global_position), target_cell) * AIScoringWeights.WEIGHT_POSITIONING_CLOSER * 0.3

	score += damage_score + stun_score + knockback_score
	return score

func generate_targets(caster: CombatCharacter, map: CombatMap) -> Array[TargetInfo]:
	var targets: Array[TargetInfo] = []
	var caster_pos = map.get_cell_coords(caster.global_position)

	for i in range(6): # Check all 6 directions
		var current_cell = caster_pos
		for j in range(1, get_skill_range() + 1): # Check cells along the path
			current_cell = HexHelper.hex_neighbor(current_cell, i)
			if not map.can_walk(current_cell):
				break 

			# If we reached the target distance
			var target_char = map.get_character(current_cell)
			if is_valid_target_type(caster, target_char):
				# Found a valid target at the correct distance
				targets.append(TargetInfo.new(
					TargetInfo.TargetType.CHARACTER, target_char, current_cell, [target_char]
				))
				# Stop checking this column after reaching the target distance
				break
		# Loop continues to next direction if path wasn't clear or no target at dist
	return targets

	
func get_skill_name() -> String:
	return "Zealous Charge"

func get_skill_description() -> String:
	return "Charge a target from " + str(get_skill_range()) + " tiles away, dealing " + str(damage_mult) + " times your base damage, stunning them for one turn and knocking them back one tile.\n" + \
		"Can only target enemies not adjacent to you, in a straight line.\n" + \
		"Cooldown: " + str(max_cooldown) + " turns.\n" + \
		"Range: " + str(get_skill_range()) + " cells.\n"

func get_skill_icon() -> Texture:
	return load("res://assets/ui/skills/zealous_charge.png")

func get_skill_range() -> int:
	return 3

func target_allies() -> bool:
	return false

func target_enemies() -> bool:
	return true

func target_self() -> bool:
	return false
	
func is_melee() -> bool:
	return false

func highlight_targets(from: CombatCharacter, map: CombatMap) -> Array[Vector2i]:
	curr_highlighted_cells = map.highlight_columns(map.get_cell_coords(from.global_position), get_skill_range())
	return curr_highlighted_cells

func highlight_mouse_pos(from: CombatCharacter, _mouse_pos: Vector2i, map: CombatMap) -> Array[Vector2i]:
	return highlight_targets(from, map)

func _get_knockback_dir(from: CombatCharacter, target: CombatCharacter, map: CombatMap) -> int:
	var cube_coords_from = HexHelper.axial_to_cube(HexHelper.oddr_to_axial(map.get_cell_coords(from.global_position)))
	var cube_coords_target = HexHelper.axial_to_cube(HexHelper.oddr_to_axial(map.get_cell_coords(target.global_position)))

	if cube_coords_from.x == cube_coords_target.x:
		if cube_coords_from.y < cube_coords_target.y:
			return 5
		else:
			return 2
	if cube_coords_from.y == cube_coords_target.y:
		if cube_coords_from.x < cube_coords_target.x:
			return 0
		else:
			return 3
	if cube_coords_from.z == cube_coords_target.z:
		if cube_coords_from.x < cube_coords_target.x:
			return 1
		else:
			return 4

	return -1

### divine_shield.gd ###
extends Skill
class_name DivineShield

var damage := 0
var max_cooldown := 4
var shield_amount := 0.2
var curr_highlighted_cells: Array[Vector2i] = []

func use_skill(from: CombatCharacter, skill_pos: Vector2i, map: CombatMap) -> bool:
	var cells = HexHelper.hex_reachable(map.get_cell_coords(from.global_position), get_skill_range(), func (_hex): return true).filter(map.can_walk)
	if skill_pos in cells:
		for cell in cells :
			var character: CombatCharacter = map.get_character(cell)
			if is_valid_target_type(from, character):
				character.gain_shield(from.max_health * shield_amount)
		cooldown = max_cooldown
		skill_finished.emit()
		return true

	return false

func score_action(from: CombatCharacter, potential_targets: Array[CombatCharacter], _target_cell: Vector2i, map: CombatMap) -> float:
	# AoE Ally Buff (Shield)
	var score = AIScoringWeights.WEIGHT_BUFF_POSITIVE


	if potential_targets.is_empty(): return 0.0

	var shield_gain = from.max_health * shield_amount # Calculate flat shield amount
	var shield_value_per_ally = shield_gain * AIScoringWeights.WEIGHT_SHIELD
	var total_shield_score = 0.0

	for ally in potential_targets:
		var current_shield_value = shield_value_per_ally
		# More value if ally is lower health
		current_shield_value *= (1.0 + (1.0 - ally.health / ally.max_health) * 0.6)
		total_shield_score += current_shield_value

	score += total_shield_score * AIScoringWeights.WEIGHT_AOE_TARGET_ALLY_BUFF

	# Value more if allies are low health or near enemies
	var low_hp_allies = 0
	var enemies_near_allies = 0
	for ally in potential_targets:
		if ally.health < ally.max_health * 0.6: # Higher threshold for shield value
			low_hp_allies += 1
		var ally_pos = map.get_cell_coords(ally.global_position)
		for p in map.get_alive_party_members():
			if HexHelper.distance(ally_pos, map.get_cell_coords(p.global_position)) <= 2:
				enemies_near_allies += 1
				break
	score += low_hp_allies * 6.0
	score += enemies_near_allies * 3.0

	return score

func generate_targets(from: CombatCharacter, map: CombatMap) -> Array[TargetInfo]:
	# Self-activation, affects adjacent allies + self
	var caster_pos = map.get_cell_coords(from.global_position)
	var allies_affected: Array[CombatCharacter] = []
	var aoe_cells = HexHelper.hex_reachable(caster_pos, get_skill_range(), func(_hex) : return true).filter(map.can_walk)

	for cell in aoe_cells:
		var target_char = map.get_character(cell)
		if is_valid_target_type(from, target_char): # is_valid_target_type checks target_self and target_allies flags
			allies_affected.append(target_char)

	# Only generate if there's someone to shield (including self)
	if not allies_affected.is_empty():
		return [TargetInfo.new(
			TargetInfo.TargetType.SELF_AOE_ACTIVATION,
			from,
			caster_pos,
			allies_affected
		)]
	else:
		return []
	
func get_skill_name() -> String:
	return "Divine Shield"

func get_skill_description() -> String:
	return "Create shields around all adjacent allies and yourself that absorb " + str(shield_amount * 100) + "% of your max HP.\n" + \
		"Cooldown: " + str(max_cooldown) + " turns.\n" + \
		"Range: " + str(get_skill_range()) + " cells.\n"

func get_skill_icon() -> Texture:
	return load("res://assets/ui/skills/divine_shield.png")

func get_skill_range() -> int:
	return 1

func target_allies() -> bool:
	return true

func target_enemies() -> bool:
	return false

func target_self() -> bool:
	return true
	
func is_melee() -> bool:
	return true

func highlight_targets(from: CombatCharacter, map: CombatMap) -> Array[Vector2i]:
	curr_highlighted_cells = HexHelper.hex_reachable(map.get_cell_coords(from.global_position), get_skill_range(), map.can_walk)

	for cell in curr_highlighted_cells:
		map.set_cell(0, cell, 22, map.get_cell_atlas_coords(0, cell), 6)
		var cell_char = map.get_character(cell)
		if cell_char and cell_char is PlayerCombatCharacter:
			map.set_cell(0, cell, 22, map.get_cell_atlas_coords(0, cell), 7)
		if cell_char and cell_char is AICombatCharacter:
			map.set_cell(0, cell, 22, map.get_cell_atlas_coords(0, cell), 0)
			curr_highlighted_cells.erase(cell)
	return curr_highlighted_cells

func highlight_mouse_pos(_from: CombatCharacter, mouse_pos: Vector2i, map: CombatMap) -> Array[Vector2i]:
	for cell in curr_highlighted_cells:
		map.set_cell(0, cell, 22, map.get_cell_atlas_coords(0, cell), 6)
		if mouse_pos in curr_highlighted_cells:
			map.set_cell(0, cell, 22, map.get_cell_atlas_coords(0, cell), 8)
		elif map.get_character(cell):
			map.set_cell(0, cell, 22, map.get_cell_atlas_coords(0, cell), 7)
			
	return curr_highlighted_cells


### holy_strike.gd ###
extends MeleeSkill
class_name HolyStrike

var damage_mult := 4
var max_cooldown := 4
var heal_percentage := 0.25

func use_skill(from: CombatCharacter, skill_pos: Vector2i, map: CombatMap) -> bool:
	var target = map.get_character(skill_pos)
	if is_valid_target_type(from, target) and HexHelper.distance(map.get_cell_coords(from.global_position), skill_pos) <= get_skill_range():
		var damage = from.get_damage() * damage_mult
		from.deal_damage(target, damage_mult)
		from.heal(damage * heal_percentage)
		from.attack(map.to_local(target.global_position))
		cooldown = max_cooldown
		return true

	return false

func score_action(caster: CombatCharacter, potential_targets: Array[CombatCharacter], _target_cell: Vector2i, _map: CombatMap) -> float:
	if potential_targets.is_empty(): return 0.0
	var target = potential_targets[0]

	var score = AIScoringWeights.WEIGHT_BASE_MELEE # Melee Damage + Self Heal
	var potential_damage = caster.get_damage() * damage_mult
	var potential_heal = potential_damage * heal_percentage # Heal is 25% of damage

	# Score damage
	var damage_score = potential_damage * AIScoringWeights.WEIGHT_DAMAGE
	if target.health <= potential_damage:
		damage_score += AIScoringWeights.WEIGHT_KILL_BONUS
	else:
		damage_score += (1.0 - (target.health / target.max_health)) * potential_damage * AIScoringWeights.WEIGHT_DAMAGE_PER_HP
	damage_score -= target.shield * 0.1

	# Score heal
	var heal_score = potential_heal * AIScoringWeights.WEIGHT_HEAL
	heal_score += (1.0 - (caster.health / caster.max_health)) * potential_heal * AIScoringWeights.WEIGHT_HEAL_LOW_HP_BONUS

	score += damage_score + heal_score
	return score

func generate_targets(from: CombatCharacter, map: CombatMap) -> Array[TargetInfo]:
	# Standard melee targeting
	var targets: Array[TargetInfo] = []
	var caster_pos = map.get_cell_coords(from.global_position)
	var potential_cells = HexHelper.hex_reachable(caster_pos, get_skill_range(), func (_hex): return true).filter(map.can_walk)

	for cell in potential_cells:
		var target_char = map.get_character(cell)
		if is_valid_target_type(from, target_char):
			targets.append(TargetInfo.new(
				TargetInfo.TargetType.CHARACTER, target_char, cell, [target_char]
			))
	return targets
	
func get_skill_name() -> String:
	return "Holy Strike"

func get_skill_description() -> String:
	return "Deal " + str(damage_mult) + " times your basic damage to an enemy and heal yourself for 25% of the damage dealt.\n" + \
		"Cooldown: " + str(max_cooldown) + " turns.\n" + \
		"Range: " + str(get_skill_range()) + " cells.\n"

func get_skill_icon() -> Texture:
	return load("res://assets/ui/skills/holy_strike.png")

func get_skill_range() -> int:
	return 1

func target_allies() -> bool:
	return false

func target_enemies() -> bool:
	return true

func target_self() -> bool:
	return false
	
func is_melee() -> bool:
	return true



### arena_class_selection.gd ###
# ArenaClassSelection.gd
extends Control

signal class_selected(selected_class: Character.CLASSES)

@onready var title_label: Label = $background/CenterContainer/content_vbox/title_label_bg/title_label
@onready var warrior_button: TextureButton = $background/CenterContainer/content_vbox/class_options_hbox/warrior_button
@onready var mage_button: TextureButton = $background/CenterContainer/content_vbox/class_options_hbox/mage_button
@onready var confirm_button: TextureButton = $background/CenterContainer/content_vbox/proceed_button

var chosen_class: Character.CLASSES = Character.CLASSES.None # Default to None or first class
var selected_button: TextureButton = null

func _ready():
	warrior_button.pressed.connect(_on_class_button_pressed.bind(Character.CLASSES.Warrior, warrior_button))
	mage_button.pressed.connect(_on_class_button_pressed.bind(Character.CLASSES.Mage, mage_button))
	# rogue_button.pressed.connect(_on_class_button_pressed.bind(Character.CLASSES.Rogue, rogue_button))
	confirm_button.pressed.connect(_on_confirm_button_pressed)

	# Start with no class selected and confirm button disabled
	confirm_button.disabled = true
	_highlight_selected_button(null) # Clear any initial highlight

func _on_class_button_pressed(class_enum_value: Character.CLASSES, button_node: TextureButton):
	chosen_class = class_enum_value
	selected_button = button_node

	_highlight_selected_button(button_node)
	confirm_button.disabled = false # Enable confirm button

func _highlight_selected_button(button_to_highlight: TextureButton):
	# Reset previous highlights (simple modulation example)
	warrior_button.modulate = Color.WHITE
	warrior_button.disabled = false
	mage_button.modulate = Color.WHITE
	mage_button.disabled = false
	# rogue_button.modulate = Color.WHITE

	if button_to_highlight:
		button_to_highlight.modulate = Color.DIM_GRAY # Highlight the selected button
		button_to_highlight.disabled = true

func _on_confirm_button_pressed():
	if chosen_class != Character.CLASSES.None:
		class_selected.emit(chosen_class)
		hide() # Hide the selection screen
	else:
		# Should not happen if button is disabled, but a good check
		printerr("No class selected to confirm!")

# Call this to show the screen
func prompt_class_selection():
	show()
	confirm_button.disabled = true
	chosen_class = Character.CLASSES.None
	_highlight_selected_button(null)
	# Optionally grab focus on the first class button
	if warrior_button: warrior_button.grab_focus()

### arena_progression_screen.gd ###
# ArenaProgressionScreen.gd
extends Control # Or PanelContainer

signal view_skills_pressed
signal next_wave_pressed

@onready var title_label: Label = $background/borders/header/title_label
@onready var display: TextureRect = $background/character_result_display
@onready var display_class_button: TextureButton = $background/character_result_display/hbox/skill_button
@onready var view_skills_button: TextureButton = $background/character_result_display/hbox/skill_button
@onready var next_wave_button: TextureButton = $background/proceed_button


func setup(character_before: PartyMember, character_after: PartyMember, xp_gained: int):
	title_label.text = "Wave %d Cleared!" % character_after.character_level # Or pass wave num

	display.update_display(character_before, character_after, xp_gained)
	display_class_button.texture_normal = load("res://assets/ui/classes_icons/" + character_after.get_char_class().to_lower() + ".png")


	# Show/hide skill button based on available points
	view_skills_button.visible = (character_after.skill_points > 0)
	view_skills_button.disabled = not view_skills_button.visible

func _ready():
	view_skills_button.pressed.connect(func (): view_skills_pressed.emit())
	view_skills_button.pressed.connect(AudioManager.play_sfx.bind(AudioManager.UI_BUTTON_CLICK))

	next_wave_button.pressed.connect(func (): next_wave_pressed.emit())
	next_wave_button.pressed.connect(AudioManager.play_sfx.bind(AudioManager.UI_BUTTON_CLICK))
	hide() 

### character_display.gd ###
@tool
extends TextureRect
class_name Character_Display

@onready var infos_label = $infos
@onready var avatar_portrait = $avatar_background/avatar_portrait
@onready var delete_button = $delete_button
@onready var xp_bar = $infos/xp_bar
@onready var class_badge: TextureButton = $class_badge
@onready var class_badge_icon: TextureRect = $class_badge/class_icon

signal character_changed
signal fire_character
signal show_skill_tree

@export var show_delete_button: bool = true:
	set(value): 
		if delete_button :
			delete_button.visible = value
			delete_button.disabled = not value
		show_delete_button = value
@export var character_name: String = "Halfai":
	set(value):
		character_name = value
		update_values()
@export var character_class: String = "Rogue":
	set(value):
		character_class = value
		update_values()
@export var character_level: int = 1:
	set(value):
		character_level = value
		update_values()
@export var character_xp: int = 0:
	set(value):
		character_xp = value
		update_values()
@export var character_portrait: int = 1:
	set(value):
		character_portrait = value
		update_values()

var party_member: PartyMember

func _ready() : 
	delete_button.pressed.connect(_on_delete_button_pressed)
	delete_button.pressed.connect(AudioManager.play_sfx.bind(AudioManager.UI_BUTTON_CLICK))

	class_badge.pressed.connect(_on_class_badge_pressed)
	class_badge.pressed.connect(AudioManager.play_sfx.bind(AudioManager.UI_BUTTON_CLICK))

func update_values():
	if Engine.is_editor_hint():
		if infos_label :
			var char_class = party_member.CLASSES.Warrior if character_class == "Warrior" else party_member.CLASSES.Rogue if character_class == "Rogue" else party_member.CLASSES.Mage
			party_member = PartyMember.new(character_name, char_class, character_portrait, character_level, 0)
			party_member.character_experience = character_xp

			_update_infos()

			character_changed.emit()


func update_character(_party_member: PartyMember):
	self.party_member = _party_member
	
	_update_infos()
	
func _on_delete_button_pressed(): 
	fire_character.emit()

func _on_class_badge_pressed():
	show_skill_tree.emit()

func _update_infos():
	infos_label.text = party_member.character_name + "\n Lvl : " + str(party_member.character_level) + "\n XP : " + str(party_member.character_experience) + "/" + str(party_member.next_level())

	xp_bar.value = party_member.character_experience
	xp_bar.max_value = party_member.next_level()

	avatar_portrait.texture = load(party_member.get_portrait_path())

	class_badge_icon.texture = load("res://assets/ui/classes_icons/" + party_member.get_char_class().to_lower() + ".png")



### character_result_display.gd ###
extends TextureRect

@onready var portrait: TextureRect = $hbox/portrait/avatar_portrait
@onready var name_label: Label = $hbox/info_vbox/name_label
@onready var xp_gain_label: Label = $hbox/info_vbox/xp_gain_label
@onready var xp_progress_label: Label = $hbox/info_vbox/xp_progress_label
@onready var skill_point_available_label: Label = $hbox/info_vbox/skill_points_available_label

func update_display(character_before: PartyMember, character_after: PartyMember, xp_gained: int):
	if not character_after: # Should always have the 'after' state
		printerr("CharacterResultDisplay requires character_after data!")
		queue_free() # Remove self if data is bad
		return

	name_label.text = character_after.character_name
	portrait.texture = load(character_after.get_portrait_path())
	xp_gain_label.text = "+%d XP" % xp_gained

	var leveled_up = false
	if character_before and character_after.character_level > character_before.character_level:
		leveled_up = true
		xp_gain_label.text += "(Level Up! (Lv. %d -> Lv. %d))" % [character_before.character_level, character_after.character_level]

	xp_progress_label.text = "XP: %d / %d" % [character_after.character_experience, character_after.next_level()]

	var skill_points_gained = 0
	var new_skill_point = ""
	if character_before and character_after.skill_points > character_before.skill_points:
		if leveled_up:
			skill_points_gained = character_after.skill_points - character_before.skill_points # Calculate diff
			# Assuming 1 point per level for now
			new_skill_point = "(+%d!)" % skill_points_gained


	skill_point_available_label.text = "Skill Points Available: %d" % character_after.skill_points + new_skill_point


### combat_character_tooltip.gd ###
class_name CombatCharacterTooltipUI
extends PanelContainer

@onready var info_label: Label = $VBoxContainer/info_label

@onready var base_skill_cooldown = $VBoxContainer/base_skill_button/skill_cooldown
@onready var base_skill_icon = $VBoxContainer/base_skill_button/skill_icon

@onready var skill_cooldowns = [
	$VBoxContainer/HBoxContainer/skill_button_1/skill_cooldown_1,
	$VBoxContainer/HBoxContainer/skill_button_2/skill_cooldown_2,
	$VBoxContainer/HBoxContainer/skill_button_3/skill_cooldown_3
]
@onready var skill_icons = [
	$VBoxContainer/HBoxContainer/skill_button_1/skill_icon_1,
	$VBoxContainer/HBoxContainer/skill_button_2/skill_icon_2,
	$VBoxContainer/HBoxContainer/skill_button_3/skill_icon_3
]
func update_content(character: CombatCharacter):
	if not character:
		hide()
		return

	info_label.text = "Name: " + character.character.character_name + "\n" + \
					"Class: " + character.character.get_char_class() + "\n" + \
					"Level: " + str(character.character.character_level) + "\n" + \
					"Base Damage: " + str(character.character.base_damage) + "\n" 

	base_skill_cooldown.text = str(character.character.base_skill.get_cooldown())
	if character.character.base_skill.get_cooldown() > 0:
		base_skill_cooldown.show()
	else:
		base_skill_cooldown.hide()
	base_skill_icon.texture = character.character.base_skill.get_skill_icon()

	for i in range(0, 3):
		if i < character.character.skill_list.size():
			var skill = character.character.skill_list[i]
			skill_cooldowns[i].text = str(skill.get_cooldown())
			if skill.get_cooldown() > 0:
				skill_cooldowns[i].show()
			else:
				skill_cooldowns[i].hide()
			skill_icons[i].texture = skill.get_skill_icon()
			skill_icons[i].show()
		else:
			skill_cooldowns[i].text = ""
			skill_icons[i].hide()

	# Adjust size after content update
	reset_size()
	await get_tree().process_frame # Wait a frame for size to update reliably
	custom_minimum_size = size

func _ready():
	hide() # Start hidden
	mouse_filter = MOUSE_FILTER_IGNORE # Tooltip shouldn't block mouse input

### combat_skill_ui.gd ###
extends TextureRect
class_name SkillBarUI

const skill_tooltip_scene: PackedScene = preload("res://scenes/skill_tooltip.tscn")
var skill_tooltip_instance: PanelContainer

@onready var button_base_skill = $base_skill_button
@onready var cooldown_base_skill = $base_skill_button/skill_cooldown
@onready var icon_base_skill = $base_skill_button/skill_icon

@onready var button_skills = [
	$skill_button_1,
	$skill_button_2,
	$skill_button_3
]
@onready var cooldown_skills = [
	$skill_button_1/skill_cooldown_1,
	$skill_button_2/skill_cooldown_2,
	$skill_button_3/skill_cooldown_3
]
@onready var icon_skills = [
	$skill_button_1/skill_icon_1,
	$skill_button_2/skill_icon_2,
	$skill_button_3/skill_icon_3
]

var targeting_skill: int = -1
var skill_list: Array[Skill] = []

signal choose_target(skill: Skill)

func _ready() -> void : 
	button_base_skill.pressed.connect(_choose_target.bind(0))
	button_base_skill.pressed.connect(AudioManager.play_sfx.bind(AudioManager.UI_BUTTON_CLICK))
	for i in range(3):
		button_skills[i].pressed.connect(_choose_target.bind(i+1))
		button_skills[i].pressed.connect(AudioManager.play_sfx.bind(AudioManager.UI_BUTTON_CLICK))

	if skill_tooltip_scene:
		skill_tooltip_instance = skill_tooltip_scene.instantiate()
		add_child(skill_tooltip_instance) 
		skill_tooltip_instance.top_level = true 
		skill_tooltip_instance.hide()
	else:
		printerr("Skill Tooltip Scene not assigned to SkillBarUI!")

	button_base_skill.mouse_entered.connect(_on_skill_button_mouse_entered.bind(0))
	button_base_skill.mouse_exited.connect(_on_skill_button_mouse_exited)
	for i in range(3):
		button_skills[i].mouse_entered.connect(_on_skill_button_mouse_entered.bind(i+1))
		button_skills[i].mouse_exited.connect(_on_skill_button_mouse_exited)



func update_ui(character: Character, enemy_turn: bool= false ) : 
	self.skill_list = [character.base_skill]
	for skill in character.skill_list : 
		self.skill_list.append(skill)

	var base_skill = character.base_skill
	if base_skill : 
		button_base_skill.modulate = Color(1, 1, 1)
		button_base_skill.show()
		button_base_skill.disabled = enemy_turn
		cooldown_base_skill.show()
		if base_skill.cooldown > 0 : 
			cooldown_base_skill.text = str(base_skill.get_cooldown())
		else : 
			cooldown_base_skill.text = ""
		icon_base_skill.show()
		icon_base_skill.texture = base_skill.get_skill_icon()
	else : 
		button_base_skill.modulate = Color(0.7, 0.7, 0.7)
		button_base_skill.disabled = true
		cooldown_base_skill.hide()
		icon_base_skill.hide()

	for i in range(0, 3) : 
		if i < skill_list.size() - 1 : 
			var skill = skill_list[i+1]
			button_skills[i].modulate = Color(1, 1, 1)
			button_skills[i].show()
			button_skills[i].disabled = enemy_turn
			cooldown_skills[i].show()
			if skill.cooldown > 0 : 
				cooldown_skills[i].text = str(skill.get_cooldown())
			else : 
				cooldown_skills[i].text = ""
			icon_skills[i].show()
			icon_skills[i].texture = skill.get_skill_icon()
		else : 
			button_skills[i].modulate = Color(0.7, 0.7, 0.7)
			button_skills[i].disabled = true
			cooldown_skills[i].hide()
			icon_skills[i].hide()

func reset_ui() : 
	for i in range(0, 3) : 
		button_skills[i].modulate = Color(0.7, 0.7, 0.7)
		button_skills[i].disabled = true
		cooldown_skills[i].hide()
		icon_skills[i].hide()
	button_base_skill.modulate = Color(0.7, 0.7, 0.7)
	button_base_skill.disabled = true
	cooldown_base_skill.hide()
	icon_base_skill.hide()

func _unhandled_input(event):
	if event.is_action_pressed("combat_base_skill") :
		_choose_target(0)
	if event.is_action_pressed("combat_skill_1") && skill_list.size() > 1 :
		_choose_target(1)
	if event.is_action_pressed("combat_skill_2") && skill_list.size() > 2 :
		_choose_target(2)
	if event.is_action_pressed("combat_skill_3") && skill_list.size() > 3 :
		_choose_target(3)

func _choose_target(index: int) : 
	if skill_list[index].get_cooldown() == 0 : 
		choose_target.emit(skill_list[index])

func _on_skill_button_mouse_entered(skill_index: int):
	if not skill_tooltip_instance: return # Tooltip doesn't exist
	if skill_index < 0 or skill_index >= skill_list.size(): return # Invalid index

	skill_tooltip_instance.reset_size()

	var skill: Skill = skill_list[skill_index]
	var button: TextureButton = button_base_skill if skill_index == 0 else button_skills[skill_index - 1]

	skill_tooltip_instance.update_content(skill)
	var cd_text = "CD: %d/%d" % [skill.cooldown, skill.max_cooldown]
	if skill_tooltip_instance.has_node("VBoxContainer/CooldownLabel"): # If you add a CD label
		skill_tooltip_instance.get_node("VBoxContainer/CooldownLabel").text = cd_text


	var tooltip_size = skill_tooltip_instance.size
	var viewport_rect = get_viewport_rect()
	var offset = Vector2(0, -10) # Position above the button

	# Calculate position (usually above the button)
	var target_pos = button.global_position + Vector2(button.size.x / 2 - tooltip_size.x / 2, -tooltip_size.y) + offset


	# Adjust if off-screen (simplified)
	if target_pos.x < 0: target_pos.x = 0
	if target_pos.x + tooltip_size.x > viewport_rect.size.x: target_pos.x = viewport_rect.size.x - tooltip_size.x
	if target_pos.y < 0: target_pos.y = button.global_position.y + button.size.y + offset.y # Put below if no space above

	skill_tooltip_instance.position = target_pos
	skill_tooltip_instance.show()

func _on_skill_button_mouse_exited():
	if skill_tooltip_instance:
		skill_tooltip_instance.hide()


### enemies_display.gd ###
@tool
extends Control
class_name EnemiesDisplay

@onready var portrait = $avatar_background/avatar_portrait
@onready var description = $enemy_description

signal enemy_group_changed

@export var enemy_name: String = "Mountain Drake":
	set(value):
		enemy_name = value
		update_values()
@export var enemy_class: String = "Rogue":
	set(value):
		enemy_class = value
		update_values()
@export var enemy_level: int = 1:
	set(value):
		enemy_level = value
		update_values()
@export var enemy_portrait: int = 1:
	set(value):
		enemy_portrait = value
		update_values()
@export var enemy_count: int = 2:
	set(value):
		enemy_count = value
		update_values()
		
var enemy_group: EnemyGroup
	
func update_values():
	if Engine.is_editor_hint():
		if description :
			description.text = str(enemy_count) + " " + enemy_name + "\n Lvl : " + str(enemy_level)
			var _class = Character.CLASSES.Warrior if self.enemy_class == "Warrior" else Character.CLASSES.Rogue if self.enemy_class == "Rogue" else Character.CLASSES.Mage if self.enemy_class == "Mage" else Character.CLASSES.None
			enemy_group = EnemyGroup.new(enemy_name, _class, enemy_portrait, enemy_count, enemy_level)
			portrait.texture = load(enemy_group.enemy.get_portrait_path())
			enemy_group_changed.emit()



func update_group(new_group: EnemyGroup):
	self.enemy_group = new_group
	description.text = str(new_group.enemies.size()) + " " + new_group.enemy.character_name + "\n Lvl : " + str(new_group.enemy.character_level)
	portrait.texture = load(enemy_group.enemy.get_portrait_path())


### event_ui.gd ###
extends Control
class_name EventUI

@onready var bg_card = $bg
@onready var card_name_label = $bg/event_name/name
@onready var card_illustration = $bg/event_visual
@onready var description_container = $bg/event_description/description_container
@onready var card_description_label = $bg/event_description/description_container/VBoxContainer/description_text
@onready var card_choice_buttons_control = $bg/event_description/description_container/VBoxContainer

var id: String
var event_name: String
var event_description: String
var possibilities: Array
var event_path: Array[String]

signal resolve_event(event_ccl)

const possibilities_height = 90
const possibilities_width = 256

func _ready():
	show_event("gall", "gall")

		
func show_event(curr_place: String, event_id: String, characters: Array[PartyMember] = [], random: bool = false) :
	if ResourceLoader.exists("res://assets/ui/events_ui/pictures/" + event_id + ".png") :
		card_illustration.texture = load("res://assets/ui/events_ui/pictures/" + event_id + ".png")
	var place_content = get_event_data(curr_place, random).data 


	var event_content = null
	for content in place_content.events:
		if content.id == event_id:
			event_content = content
			break
	self.id = event_id
	
	card_name_label.text = event_content.name
	
	card_description_label.text = process_text(event_content.description, characters)
	card_description_label.set_size(Vector2(550, 0))
	
	description_container.get_v_scroll_bar().ratio = 0
	for old_possibility in card_choice_buttons_control.get_children() :
		if old_possibility is Button: 
			old_possibility.queue_free()
	
	self.possibilities = event_content.possibilities
	
	for i in range(possibilities.size()) :
		if not possibilities[i].has("condition") or game_state.conditions(possibilities[i].condition) :
			var possibility_button: Button = Button.new()
			card_choice_buttons_control.add_child(possibility_button)

			possibility_button.text = process_text(possibilities[i].description, characters)

			possibility_button.size_flags_horizontal = Control.SIZE_SHRINK_CENTER
			possibility_button.custom_minimum_size = Vector2(possibilities_width, possibilities_height)
			
			possibility_button.pressed.connect(on_possibilities_buttons_pressed.bind(possibilities[i].id))
			possibility_button.pressed.connect(AudioManager.play_sfx.bind(AudioManager.UI_BUTTON_CLICK))
			
					
	card_description_label.position.y = 0
	
func get_event_data(curr_place: String, random: bool = false) -> Resource :
	# Define base search paths
	var base_path = "res://text/events/"
	var random_base_path = base_path.path_join("random_events") # "res://text/events/random_events"
	var target_filename = curr_place + ".json"

	var found_path = ""

	if random:
		found_path = _find_file_recursively(random_base_path, target_filename)
	else:
		found_path = _find_file_recursively(base_path, target_filename)


	if found_path.is_empty():
		if random: 
			found_path = _find_file_recursively(base_path, target_filename)

	if not found_path.is_empty():
		if ResourceLoader.exists(found_path): # Double-check existence before loading
			return load(found_path)
		else:
			printerr("File path found but ResourceLoader says it doesn't exist: ", found_path)
			return null
	else:
		printerr("Event file '%s' not found in event directories." % target_filename)
		return null


##
## Recursive function to search for a file in a directory and its subdirectories 
## Returns the full path if found, or an empty string if not found
##
func _find_file_recursively(search_dir: String, filename_to_find: String) -> String:
	var dir = DirAccess.open(search_dir)

	if not dir:
		return "" # Return empty, just means not found here

	# Check if the file exists directly in the current directory
	var direct_path = search_dir.path_join(filename_to_find)
	if FileAccess.file_exists(direct_path):
		return direct_path # Found it!

	# If not found directly, search subdirectories
	dir.list_dir_begin()
	var item_name = dir.get_next()
	while item_name != "":
		if item_name != "." and item_name != "..": # Skip navigation entries
			if dir.current_is_dir():
				var subdir_path = search_dir.path_join(item_name)
				var found_in_subdir = _find_file_recursively(subdir_path, filename_to_find)
				if not found_in_subdir.is_empty():
					dir.list_dir_end() 
					return found_in_subdir
		item_name = dir.get_next()

	dir.list_dir_end()

	return ""
		
func on_possibilities_buttons_pressed(event_conclusion: String) :
	resolve_event.emit(event_conclusion)
	
func process_text(raw_text: String, party: Array[PartyMember]) -> String:
	var new_text: String = raw_text
	for i  in range(0, party.size()):
		new_text = new_text.replace("[Name " + str(i) + "]", party[i].character_name)
		new_text = new_text.replace("[Class " + str(i) + "]", party[i].get_char_class())
		new_text = new_text.replace("[he/she/they " + str(i) + "]", "he" if party[i].character_sex == PartyMember.SEX.Male else "she" if party[i].character_sex == PartyMember.SEX.Female else "they")
		new_text = new_text.replace("[his/her/their " + str(i) + "]", "his" if party[i].character_sex == PartyMember.SEX.Male else "her" if party[i].character_sex == PartyMember.SEX.Female else "their")
		new_text = new_text.replace("[him/her/them " + str(i) + "]", "him" if party[i].character_sex == PartyMember.SEX.Male else "her" if party[i].character_sex == PartyMember.SEX.Female else "them")
	return new_text
	




### fight_ui.gd ###
@tool
extends Control
class_name FightUI

@onready var party_display = $bg/party_display
@onready var enemies_display: EnemiesDisplay = $bg/enemies_display
@onready var chances_label = $bg/chances_bg/chances_label
@onready var result_label = $bg/result_label
@onready var fight_button = $bg/fight_button
@onready var simulation_button = $bg/simulation_button
@onready var flee_button = $bg/flee_button
@onready var proceed_button = $bg/proceed_button

@export var debug_fight = false : 
	set(value) : 
		_debug_fight()

signal launch_fight(party: Array[PartyMember], enemy_group: EnemyGroup)
signal resolve_fight(fight_ccl: String)
var fight_result = false

var party: Array[PartyMember]
var enemy_group: EnemyGroup

var party_strength: float
var enemy_strength: float

func _ready() : 
	if Engine.is_editor_hint() :
		enemies_display.enemy_group_changed.connect(_debug_fight)
		for char_display in party_display.get_children() : 
			char_display = char_display as Character_Display
			char_display.character_changed.connect(_debug_fight)

	proceed_button.pressed.connect(_on_proceed_button_pressed)
	proceed_button.pressed.connect(AudioManager.play_sfx.bind(AudioManager.UI_BUTTON_CLICK))
	fight_button.pressed.connect(_on_fight_button_pressed)
	fight_button.pressed.connect(AudioManager.play_sfx.bind(AudioManager.UI_ENTER_COMBAT))
	simulation_button.pressed.connect(_on_simulate_button_pressed)
	simulation_button.pressed.connect(AudioManager.play_sfx.bind(AudioManager.UI_BUTTON_CLICK))
	
	
func update_ui(_party: Array[PartyMember], _enemy_group: EnemyGroup) :
	self.party = _party
	self.enemy_group = _enemy_group
	
	var displays = party_display.get_children()
	for i in range(0, _party.size()):
		var display: Character_Display = displays[i]
		display.update_character(_party[i])
		display.visible = true
		display.show_delete_button = false
	for i in range(_party.size(), 4) :
		displays[i].visible = false
	
	enemies_display.update_group(_enemy_group)
	
	party_strength = _calculate_party_strength()
	enemy_strength = _calculate_enemy_strength()
	
	var odds = _calculate_odds(100000)
	
	chances_label.text = "Victory Chances : " + str(roundi(odds * 100)) +  "%"
	result_label.visible = false
	proceed_button.visible = false
	




func _get_advantage_factor(attacker_class, defender_class):
	if defender_class == "None" :
		return 1.2
	if (attacker_class == "Warrior" and defender_class == "Mage") or \
	   (attacker_class == "Mage" and defender_class == "Rogue") or \
	   (attacker_class == "Rogue" and defender_class == "Warrior"):
		return 1.5  # 50% advantage
	elif (defender_class == "Warrior" and attacker_class == "Mage") or \
		 (defender_class == "Mage" and attacker_class == "Rogue") or \
		 (defender_class == "Rogue" and attacker_class == "Warrior"):
		return 0.5  # 50% disadvantage
	else:
		return 1.0  # No advantage

# Calculate the total effective strength of a party
func _calculate_party_strength():
	var total_strength = 0
	for member in party:
		var advantage_factor = _get_advantage_factor(member.get_char_class(), enemy_group.enemy.get_char_class())
		var member_strength = member.character_level * advantage_factor
		total_strength += member_strength
	return total_strength

# Calculate the total effective strength of an enemy group
func _calculate_enemy_strength() -> float:
	return enemy_group.enemy.character_level * enemy_group.enemies.size()

# Simulate the fight
func _simulate_fight() -> bool:
	var fight_party_strength = party_strength * randf_range(0.5, 1.5)
	var fight_enemy_strength = enemy_strength * randf_range(0.5, 1.5)
	if fight_party_strength >= fight_enemy_strength:
		return true
	return false
	
func _calculate_odds(simulations: int):
	var wins: float = 0
	for i in range(simulations):
		if _simulate_fight():
			wins += 1

	var win_rate = wins / simulations

	return win_rate

func _on_fight_button_pressed() :
	launch_fight.emit(party, enemy_group)
	
func _on_simulate_button_pressed() :
	fight_result = _simulate_fight()
	if fight_result:
		result_label.text = "Victory !"
	else :
		result_label.text = "Defeat..."
	result_label.visible = true
	proceed_button.visible = true
	
func _on_proceed_button_pressed() :
	resolve_fight.emit(fight_result)
	
func _debug_fight() : 
	if Engine.is_editor_hint():
		party = []
		for char_display in party_display.get_children() : 
			char_display = char_display as Character_Display 
			party.append(char_display.party_member)
			
		enemy_group = enemies_display.enemy_group
		
		party_strength = _calculate_party_strength()
		enemy_strength = _calculate_enemy_strength()
	
		var odds: int =  round(_calculate_odds(500000) * 100)
		chances_label.text = "Victory Chances : " + str(odds) + "%"
	


### game_over_screen.gd ###
# GameOverScreen.gd
extends Control

signal retry_arena_pressed
signal main_menu_pressed

@onready var game_over_title_label: Label = $background/CenterContainer/content_vbox/title_label_bg/title_label # Adjust path
@onready var stats_label: Label = $background/CenterContainer/content_vbox/stats_vbox/stats_label # Adjust path
@onready var final_skills: Array[TextureRect] = [
	$background/CenterContainer/content_vbox/stats_vbox/final_skills/skill_1/skill_icon,
	$background/CenterContainer/content_vbox/stats_vbox/final_skills/skill_2/skill_icon,
	$background/CenterContainer/content_vbox/stats_vbox/final_skills/skill_3/skill_icon
] 
@onready var retry_button: TextureButton = $background/CenterContainer/content_vbox/actions_hbox/retry_button # Adjust path
@onready var main_menu_button: TextureButton = $background/CenterContainer/content_vbox/actions_hbox/main_menu_button # Adjust path

func _ready():
	retry_button.pressed.connect(_on_retry_button_pressed)
	main_menu_button.pressed.connect(_on_main_menu_button_pressed)
	hide() # Start hidden

func show_screen(wave_reached: int, character: Character):
	stats_label.text = "Wave Reached: %d\nFinal Skills :" % wave_reached

	for i in range(3):
		if i < character.skill_list.size():
			final_skills[i].texture = character.skill_list[i].get_skill_icon()
		else:
			final_skills[i].hide()

	show()
	retry_button.grab_focus() # Focus the retry button

func _on_retry_button_pressed():
	retry_arena_pressed.emit()
	hide()

func _on_main_menu_button_pressed():
	main_menu_pressed.emit()
	hide()

### main_menu.gd ###
# MainMenu.gd
extends Control

# Get references to the buttons
@onready var campaign_button: TextureButton = $background/center_container/vbox_container/campaign_button
@onready var arena_button: TextureButton = $background/center_container/vbox_container/arena_button
@onready var options_button: TextureButton = $background/center_container/vbox_container/options_button
@onready var quit_button: TextureButton = $background/center_container/vbox_container/exit_button

func _ready():
	# Connect button signals to functions
	campaign_button.pressed.connect(_on_campaign_button_pressed)
	campaign_button.pressed.connect(AudioManager.play_sfx.bind(AudioManager.UI_BUTTON_CLICK))
	arena_button.pressed.connect(_on_arena_button_pressed)
	arena_button.pressed.connect(AudioManager.play_sfx.bind(AudioManager.UI_BUTTON_CLICK))
	options_button.pressed.connect(_on_options_button_pressed)
	options_button.pressed.connect(AudioManager.play_sfx.bind(AudioManager.UI_BUTTON_CLICK))
	quit_button.pressed.connect(_on_quit_button_pressed)
	quit_button.pressed.connect(AudioManager.play_sfx.bind(AudioManager.UI_BUTTON_CLICK))

	AudioManager.play_music(AudioManager.MAIN_MENU_MUSIC) # Play main menu music

	campaign_button.grab_focus()

func _on_campaign_button_pressed():
	var err = get_tree().change_scene_to_file("res://scenes/main_scene.tscn")
	if err != OK:
		printerr("Error loading main scene: ", err)

func _on_arena_button_pressed():
	var err = get_tree().change_scene_to_file("res://scenes/arena_manager.tscn") 
	if err != OK:
		printerr("Error loading arena scene: ", err)

func _on_options_button_pressed():
	# TODO: Implement options screen or panel opening here
	# Example: $OptionsMenu.show() if you have an options menu node
	pass

func _on_quit_button_pressed():
	get_tree().quit()

# Optional: Allow quitting with the Escape key
func _unhandled_input(event: InputEvent):
	if event.is_action_pressed("ui_cancel"): # ui_cancel is usually mapped to Escape
		get_tree().quit()


### party_ui.gd ###
extends Control
class_name PartyUI

@onready var displays: Array[Character_Display] = [$bg/displays/main_character_display, 
	$bg/displays/character_display2, 
	$bg/displays/character_display3, 
	$bg/displays/character_display4]
	
signal fire_character(index)
signal show_skill_tree(index)
	
const PARTY_MAX_NUMBER = 4

func _ready() : 
	displays[0].show_skill_tree.connect(_on_show_skill_tree.bind(0))
	displays[1].fire_character.connect(_on_fire_character.bind(1))
	displays[1].show_skill_tree.connect(_on_show_skill_tree.bind(1))
	displays[2].fire_character.connect(_on_fire_character.bind(2))
	displays[2].show_skill_tree.connect(_on_show_skill_tree.bind(2))
	displays[3].fire_character.connect(_on_fire_character.bind(3))
	displays[3].show_skill_tree.connect(_on_show_skill_tree.bind(3))

# Called when the node enters the scene tree for the first time.
func update_ui(party: Array[PartyMember]) :
	for i in range(0, party.size()):
		displays[i].update_character(party[i])
		displays[i].visible = true
	for i in range(party.size(), PARTY_MAX_NUMBER) :
		displays[i].visible = false
		
func _on_fire_character(index: int) : 
	fire_character.emit(index)

func _on_show_skill_tree(index: int) : 
	show_skill_tree.emit(index)


### post_fight_screen.gd ###
# PostFightScreen.gd
extends Control

@onready var title_label: Label = $background/borders/header/title_label
@onready var char_1: TextureRect = $background/character_result_display_1
@onready var char_2: TextureRect = $background/character_result_display_2
@onready var char_3: TextureRect = $background/character_result_display_3
@onready var char_4: TextureRect = $background/character_result_display_4
@onready var proceed_button: TextureButton = $background/proceed_button

# Call this function from main_scene.gd to initialize the screen
func setup(party_before: Array[PartyMember], party_after: Array[PartyMember], xp_gained: int, victory: bool):
	# Set Title
	title_label.text = "Victory!" if victory else "Defeat..." # Or "Combat Over"

	var displays: Array[TextureRect] = [char_1, char_2, char_3, char_4]

	for i in range(4):
		if i >= party_after.size():
			displays[i].hide() # Hide unused displays
			continue

		var char_after = party_after[i]
		var char_before = party_before[i]

		# Update the display using before & after states
		displays[i].update_display(char_before, char_after, xp_gained)


### quest_log_ui.gd ###
extends Control
class_name QuestLogUI

@onready var displayed_quest = $bg/displayed_quest
@onready var displayed_quest_title = $bg/displayed_quest/quest_title_bg/quest_title
@onready var displayed_quest_description = $bg/displayed_quest/quest_description_container/quest_description
@onready var quests_control = $bg/quests_scroll/quests_control

var quests_info: Array[Dictionary]

const QUESTS_HEIGHT = 70
const QUESTS_WIDTH = 500
const QUESTS_MARGIN = 20

var curr_quest: int

func update_ui(quest_log: Dictionary) :
	quests_info.clear()
	for quest_button in quests_control.get_children() :
		quest_button.queue_free()
	displayed_quest.visible = false
	
	for i in range(0, quest_log.size()):
		var quest_state = quest_log[quest_log.keys()[i]]
		if quest_state != game_state.QUEST_STATE.Turned :  
			var quest_info = load("res://text/quests/" + "%03d" % quest_log.keys()[i] + ".json").data
			quests_info.append(quest_info)
			
			var quest_button = Button.new()
			quest_button.add_theme_color_override("font_color", Color(0, 0, 0))
			quest_button.add_theme_font_size_override("font_size", 30)
			var quest_title = quest_info.name + (" (Accomplished)" if quest_state == game_state.QUEST_STATE.Accomplished else "") 
			quest_button.set_text(quest_title)
			quest_button.pressed.connect(_on_quest_button_pressed.bind(i))
			quest_button.pressed.connect(AudioManager.play_sfx.bind(AudioManager.UI_BUTTON_CLICK))
			quest_button.set_size(Vector2(QUESTS_WIDTH, QUESTS_HEIGHT))
			quest_button.set_position(Vector2(0, QUESTS_MARGIN + i * (QUESTS_HEIGHT + QUESTS_MARGIN)))
			quests_control.add_child(quest_button)

func _on_quest_button_pressed(index: int) :
	var quest_info = quests_info[index]
	displayed_quest_title.set_text(quest_info.name)
	displayed_quest_description.set_text(
		"Difficulty: {difficulty}
		Location: {location}
		Description: {description}
		Reward: {reward}".format({"difficulty" : quest_info.difficulty, "location" : quest_info.location, 
		"description": quest_info.description, "reward": quest_info.reward}))
	if index != curr_quest :
		displayed_quest.visible = true
	else :
		displayed_quest.visible = not displayed_quest.visible
	curr_quest = index
		


### skill_node.gd ###
extends TextureButton
class_name SkillNode

@onready var skill_icon: TextureRect = $skill_icon

@export var previous_node: SkillNode


var skill: Skill
var curr_char: PartyMember

var highlight_mode: SkillTree.HighlightMode = SkillTree.HighlightMode.NONE
var glowing: bool = false

var is_unlocked: Array[PartyMember] = []

signal skill_hover_entered(skill_node: Control, skill: Skill) 
signal skill_hover_exited()
signal skill_selected_for_slot(skill: Skill)

func _ready():
	mouse_entered.connect(_on_mouse_entered)
	mouse_exited.connect(_on_mouse_exited)


func update_node(new_skill: Skill, party_member: PartyMember):
	self_modulate = Color(1, 1, 1, 1)
	skill_icon.texture = new_skill.get_skill_icon()
	skill_icon.modulate = Color(1, 1, 1, 1)

	skill = new_skill
	curr_char = party_member
	if previous_node and not previous_node.is_unlocked.has(curr_char):
		disabled = true
	else:
		disabled = false

func update_visual_state(new_highlight_mode, equipped_skills: Array[Skill], pending_skill: Skill):
	if not curr_char: return

	var base_modulate = Color.WHITE
	var icon_modulate = Color.WHITE
	var is_unlocked_by_current = is_unlocked.has(curr_char)
	var can_unlock = curr_char.skill_points > 0 and \
					 (not previous_node or previous_node.is_unlocked.has(curr_char))

	match new_highlight_mode:
		SkillTree.HighlightMode.NONE:
			if is_unlocked_by_current or can_unlock:
				disabled = false 
			else : 
				disabled = true

		SkillTree.HighlightMode.HIGHLIGHT_SELECTABLE_FOR_SLOT:
			if is_unlocked_by_current:
				disabled = false # Can be clicked
				if skill in equipped_skills:
					base_modulate = Color.DARK_GRAY # Dim if already equipped
					icon_modulate = Color(0.6, 0.6, 0.6)
				else:
					base_modulate = Color.GOLD # Highlight selectable
			else: # Not unlocked
				disabled = true
				base_modulate = Color(0.5, 0.5, 0.5) # Dim non-selectable
				icon_modulate = Color(0.5, 0.5, 0.5)

		SkillTree.HighlightMode.HIGHLIGHT_PENDING_SKILL:
			disabled = true
			if is_unlocked_by_current and skill == pending_skill:
				base_modulate = Color.GOLD # Highlight the pending skill
				disabled = false
			elif is_unlocked_by_current:
				base_modulate = Color(0.6, 0.6, 0.6) # Dim other unlocked
				icon_modulate = Color(0.6, 0.6, 0.6)
			else: # Not unlocked
				base_modulate = Color(0.4, 0.4, 0.4)
				icon_modulate = Color(0.4, 0.4, 0.4)

	self_modulate = base_modulate
	skill_icon.modulate = icon_modulate
	highlight_mode = new_highlight_mode




func _on_mouse_entered():
	# Only show hover info if the skill has data
	if skill:
		skill_hover_entered.emit(self, skill)

func _on_mouse_exited():
	# Always emit exit signal to ensure tooltip hides
	skill_hover_exited.emit()	

func _process(delta):
	if not curr_char:
		return

	if (highlight_mode == SkillTree.HighlightMode.NONE):
		if not disabled and not is_unlocked.has(curr_char) and curr_char.skill_points > 0:
			if glowing:
				self_modulate.b -= clamp(delta * 2, 0, 1)
				skill_icon.modulate = self_modulate
				if self_modulate.b <= 0:
					glowing = false
			else:
				self_modulate.b += clamp(delta * 2, 0, 1)
				skill_icon.modulate = self_modulate
				if self_modulate.b >= 1:
					glowing = true

		elif is_unlocked.has(curr_char):
			self_modulate = Color(1, 1, 1, 1)

		else :
			$skill_icon.modulate = Color(0.5, 0.5, 0.5, 1)
			self_modulate = Color(0.5, 0.5, 0.5, 1)
	


### skill_tooltip.gd ###
# SkillTooltip.gd
extends PanelContainer

@onready var skill_name_label: Label = $VBoxContainer/SkillNameLabel
@onready var skill_description_label: Label = $VBoxContainer/SkillDescriptionLabel

func update_content(skill: Skill):
	if not skill:
        # Handle cases where skill might be null, maybe hide?
		skill_name_label.text = "???"
		skill_description_label.text = "No skill data."
		return

	skill_name_label.text = skill.get_skill_name()
	skill_description_label.text = skill.get_skill_description()

	reset_size()
	await get_tree().process_frame
	

func _ready():
    # Ensure it starts hidden
	skill_name_label.text = ""
	skill_description_label.text = ""

	reset_size()
	await get_tree().process_frame
	global_position = Vector2(-1000, -1000)
	show()

### skill_tree.gd ###
extends MarginContainer
class_name SkillTree


var skills: Array[SkillNode]

var party_member: PartyMember

enum HighlightMode { NONE, HIGHLIGHT_SELECTABLE_FOR_SLOT, HIGHLIGHT_PENDING_SKILL }
var current_highlight_mode = HighlightMode.NONE
var currently_equipped_skills: Array[Skill] = []
var pending_skill_selection: Skill = null

signal unlocked_skill_pressed(skill: Skill)
signal skill_tooltip_needed(hovered_node: SkillNode, skill_data: Skill)
signal skill_tooltip_not_needed(skill_data: Skill)

func _ready() :
	_get_skills($background, skills)

	for skill_node in skills : 
		# Check if signals are already connected if _ready can be called multiple times
		skill_node.skill_hover_entered.connect(_on_skill_hover_entered)
		skill_node.skill_hover_exited.connect(_on_skill_hover_exited)
		skill_node.pressed.connect(_on_skill_node_activated.bind(skill_node))


func update_ui(new_member: PartyMember) : 
	party_member = new_member

	var warrior_skills: Array[Skill] = [DefensiveStance.new(), Charge.new(), ShieldBash.new(), GuardiansAura.new(), HolyStrike.new(), DivineShield.new(), ZealousCharge.new(), Inquisition.new(), Frenzy.new(), RageSlam.new(), WarCry.new(), Whirlwind.new(), BloodFury.new(), RagingBlow.new()]
	var mage_skills: Array[Skill] = [Blink.new(), ArcaneShield.new(), Frostbolt.new(), Thunderstrike.new(), LightningStorm.new(), Meteor.new(), ArcaneSlash.new(), MoltenBlade.new(), DarkPact.new(), DrainLife.new(), BoneArmor.new(), SoulHarvest.new(), DeathCoil.new(), Decay.new()]
	var rogue_skills: Array[Skill] = [Sprint.new(), Charge.new(), Firespark.new(),Sprint.new(), Charge.new(), Firespark.new(),Sprint.new(), Charge.new(), Firespark.new(),Sprint.new(), Charge.new(), Firespark.new(),Sprint.new(), Charge.new()]

	var background: ColorRect = $background
	var curr_skills: Array[Skill] = []
	match party_member.get_char_class():
		"Warrior":
			background.color = Color(0x81220eff)
			curr_skills = warrior_skills
		"Mage":
			background.color = Color(0x08748bff)
			curr_skills = mage_skills
		"Rogue":
			background.color = Color(0x4f4f4fff)
			curr_skills = rogue_skills

	for i in range(min(skills.size(), curr_skills.size())):
		var skill_node = skills[i]
		var skill_data = curr_skills[i] 
		skill_node.update_node(skill_data, party_member)

func set_highlight_mode(mode, equipped_skills: Array[Skill] = [], pending_skill: Skill = null):
	match mode:
		SkillUI.SelectionMode.NONE:
			current_highlight_mode = HighlightMode.NONE
		SkillUI.SelectionMode.SELECTING_SKILL_FOR_SLOT:
			current_highlight_mode = HighlightMode.HIGHLIGHT_SELECTABLE_FOR_SLOT
		SkillUI.SelectionMode.SELECTING_SLOT_FOR_SKILL:
			current_highlight_mode = HighlightMode.HIGHLIGHT_PENDING_SKILL

	currently_equipped_skills = equipped_skills
	pending_skill_selection = pending_skill # Store the skill to highlight
	_update_node_visuals()

# Helper function to update visuals based on mode
func _update_node_visuals():
	for skill_node in skills:
		skill_node.update_visual_state(current_highlight_mode, currently_equipped_skills, pending_skill_selection)


func _get_skills(node: Node, result : Array[SkillNode]) -> void:
	if node is SkillNode :
		result.append(node)

	for child in node.get_children():
		_get_skills(child, result)



func _on_skill_hover_entered(hovered_node: SkillNode, skill_data: Skill):	
	skill_tooltip_needed.emit(hovered_node, skill_data)




func _on_skill_hover_exited():
	skill_tooltip_not_needed.emit()



func _on_skill_node_activated(skill_node: SkillNode):
	var skill = skill_node.skill
	if not skill: return

	match current_highlight_mode:
		HighlightMode.NONE:
			if not skill_node.is_unlocked.has(party_member) and party_member.skill_points > 0:
				skill_node.is_unlocked.append(party_member)
				party_member.spend_skill_point()
				AudioManager.play_sfx(AudioManager.UI_SKILL_UNLOCK)
				update_ui(party_member) 
				_on_skill_hover_exited()
			elif skill_node.is_unlocked.has(party_member):
				unlocked_skill_pressed.emit(skill)
				AudioManager.play_sfx(AudioManager.UI_BUTTON_CLICK)

		HighlightMode.HIGHLIGHT_SELECTABLE_FOR_SLOT, HighlightMode.HIGHLIGHT_PENDING_SKILL:
			if skill_node.is_unlocked.has(party_member):
				unlocked_skill_pressed.emit(skill)
				AudioManager.play_sfx(AudioManager.UI_BUTTON_CLICK)


### skill_ui.gd ###
extends Control
class_name SkillUI


@export var debugging: bool = false

@onready var skill_tree: SkillTree = $bg/skill_tree_container/skill_tree
@onready var title = $bg/UI_title/title
@onready var class_icon = $bg/UI_title/class_icon
@onready var close_button = $bg/UI_title/close_button
@onready var confirm_button = $bg/confirm_button

@onready var equipped_slot_1: TextureButton = $bg/equipped_skills_container/equipped_skill_1 # Adjust path
@onready var equipped_slot_2: TextureButton = $bg/equipped_skills_container/equipped_skill_2
@onready var equipped_slot_3: TextureButton = $bg/equipped_skills_container/equipped_skill_3

@onready var icon_slot_1: TextureRect = $bg/equipped_skills_container/equipped_skill_1/skill_icon
@onready var icon_slot_2: TextureRect = $bg/equipped_skills_container/equipped_skill_2/skill_icon
@onready var icon_slot_3: TextureRect = $bg/equipped_skills_container/equipped_skill_3/skill_icon

var curr_party_member: PartyMember = null
var pending_selection = null # Can hold either slot_index (int) or skill (Skill)

enum SelectionMode { NONE, SELECTING_SKILL_FOR_SLOT, SELECTING_SLOT_FOR_SKILL }
var current_selection_mode = SelectionMode.NONE

const SkillTooltipScene: PackedScene = preload("res://scenes/skill_tooltip.tscn")
var skill_tooltip_instance: PanelContainer

signal skills_confirmed


func _ready():
	if SkillTooltipScene:
		skill_tooltip_instance = SkillTooltipScene.instantiate()
		add_child(skill_tooltip_instance) 
		skill_tooltip_instance.z_index = 1000 # Ensure it's on top
		skill_tooltip_instance.hide()
	else:
		printerr("SkillTree: Skill Tooltip Scene not assigned!")

	close_button.pressed.connect(_on_close_button_pressed)
	close_button.pressed.connect(AudioManager.play_sfx.bind(AudioManager.UI_BUTTON_CLICK))
	confirm_button.pressed.connect(_on_confirm_button_pressed)
	confirm_button.pressed.connect(AudioManager.play_sfx.bind(AudioManager.UI_BUTTON_CLICK))
	skill_tree.skill_tooltip_needed.connect(_on_skill_tooltip_needed)
	skill_tree.skill_tooltip_not_needed.connect(_on_skill_tooltip_not_needed)

	equipped_slot_1.pressed.connect(_on_equipped_slot_pressed.bind(0))
	equipped_slot_1.pressed.connect(AudioManager.play_sfx.bind(AudioManager.UI_BUTTON_CLICK))
	equipped_slot_2.pressed.connect(_on_equipped_slot_pressed.bind(1))
	equipped_slot_2.pressed.connect(AudioManager.play_sfx.bind(AudioManager.UI_BUTTON_CLICK))
	equipped_slot_3.pressed.connect(_on_equipped_slot_pressed.bind(2))
	equipped_slot_3.pressed.connect(AudioManager.play_sfx.bind(AudioManager.UI_BUTTON_CLICK))

	equipped_slot_1.mouse_entered.connect(_on_slot_hovered.bind(0))
	equipped_slot_2.mouse_entered.connect(_on_slot_hovered.bind(1))
	equipped_slot_3.mouse_entered.connect(_on_slot_hovered.bind(2))
	equipped_slot_1.mouse_exited.connect(_on_skill_tooltip_not_needed)
	equipped_slot_2.mouse_exited.connect(_on_skill_tooltip_not_needed)
	equipped_slot_3.mouse_exited.connect(_on_skill_tooltip_not_needed)

	skill_tree.unlocked_skill_pressed.connect(_on_skill_selected_from_tree)
	
	await get_tree().process_frame

	if debugging:
		curr_party_member = PartyMember.new("DebugWarrior", Character.CLASSES.Warrior, 1, 5, PartyMember.SEX.Male)
		curr_party_member.skill_points = 10
		update_ui(curr_party_member)


func update_ui(party_member: PartyMember) : 
	self.curr_party_member = party_member

	title.text = party_member.get_char_class()
	class_icon.texture = load("res://assets/ui/classes_icons/" + party_member.get_char_class() + ".png")

	skill_tree.update_ui(party_member)

	_update_equipped_slots()

	# Reset selection state
	_cancel_selection()

	$bg/skill_tree_container.scroll_vertical = 1431


func _on_close_button_pressed() : 
	_cancel_selection()
	visible = false

func _on_confirm_button_pressed() :
	_cancel_selection()
	skills_confirmed.emit() # Emit signal with the updated skill list
	visible = false

func _on_slot_hovered(slot_index: int):
	if not curr_party_member or curr_party_member.skill_list.size() <= slot_index : return
	if current_selection_mode == SelectionMode.NONE:
		var button = [equipped_slot_1, equipped_slot_2, equipped_slot_3][slot_index]
		var skill_data = curr_party_member.skill_list[slot_index]
		if skill_data:
			_on_skill_tooltip_needed(button, skill_data)
	
func _on_skill_tooltip_needed(hovered_node: TextureButton, skill_data: Skill) -> void:
	if skill_tooltip_instance and is_instance_valid(hovered_node): 	
		skill_tooltip_instance.update_content(skill_data)

		# Get necessary info for positioning
		var tooltip_size = skill_tooltip_instance.size 

		var viewport_rect = get_viewport_rect()
		var offset = Vector2(10, 0) 

		var target_pos = hovered_node.global_position + Vector2(hovered_node.size.x, 0) + offset

		if target_pos.x + tooltip_size.x > viewport_rect.size.x:
			target_pos.x = hovered_node.global_position.x - tooltip_size.x - offset.x

		if target_pos.y + tooltip_size.y > viewport_rect.size.y:
			target_pos.y = viewport_rect.size.y - tooltip_size.y # Stick to viewport bottom

		if target_pos.y < 0:
			target_pos.y = 0 

		if target_pos.x < 0:
			target_pos.x = 0 

		skill_tooltip_instance.global_position = target_pos
		skill_tooltip_instance.show()

func _on_skill_tooltip_not_needed():
	if skill_tooltip_instance:
		skill_tooltip_instance.hide()

func _update_equipped_slots():
	if not curr_party_member: return

	var equipped_skills = curr_party_member.skill_list
	var slots = [icon_slot_1, icon_slot_2, icon_slot_3]

	for i in range(3):
		if i < equipped_skills.size() and equipped_skills[i]:
			slots[i].texture = equipped_skills[i].get_skill_icon()
			slots[i].show()
		else:
			slots[i].texture = null
			slots[i].hide()



func _on_equipped_slot_pressed(slot_index: int):
	match current_selection_mode:
		SelectionMode.NONE:
			# Start selecting a skill FOR this slot
			pending_selection = slot_index
			current_selection_mode = SelectionMode.SELECTING_SKILL_FOR_SLOT
			skill_tree.set_highlight_mode(SelectionMode.SELECTING_SKILL_FOR_SLOT, curr_party_member.skill_list)
			_update_slot_highlights()

		SelectionMode.SELECTING_SKILL_FOR_SLOT:
			if pending_selection == slot_index:
				_cancel_selection()
			else:
				pending_selection = slot_index
				_update_slot_highlights() # Update highlights

		SelectionMode.SELECTING_SLOT_FOR_SKILL:
			if pending_selection is Skill:
				_equip_skill(pending_selection, slot_index)
			else:
				_cancel_selection()




func _on_skill_selected_from_tree(selected_skill: Skill):
	match current_selection_mode:
		SelectionMode.NONE:
			# Start selecting a slot FOR this skill
			pending_selection = selected_skill
			current_selection_mode = SelectionMode.SELECTING_SLOT_FOR_SKILL
			skill_tree.set_highlight_mode(SelectionMode.SELECTING_SLOT_FOR_SKILL, curr_party_member.skill_list, selected_skill) # Highlight selected skill node
			_update_slot_highlights() # Highlight available slots

		SelectionMode.SELECTING_SLOT_FOR_SKILL:
			# Selecting the same skill again cancels
			if pending_selection == selected_skill:
				_cancel_selection()
			else:
				# Selecting a different skill switches the pending skill
				pending_selection = selected_skill
				skill_tree.set_highlight_mode(SelectionMode.SELECTING_SLOT_FOR_SKILL, [], selected_skill) # Update tree highlight

		SelectionMode.SELECTING_SKILL_FOR_SLOT:
			# A slot is pending, equip THIS skill to that slot
			if pending_selection is int:
				_equip_skill(selected_skill, pending_selection)
			else:
				printerr("Error: Pending selection was not an int when selecting skill.")
				_cancel_selection()


func _equip_skill(skill_to_equip: Skill, target_slot_index: int):
	if not curr_party_member: return

	var current_equipped = curr_party_member.skill_list

	# Check if the skill is already in another slot and handle swap/removal
	var existing_index = current_equipped.find(skill_to_equip)
	if existing_index != -1 and existing_index != target_slot_index:
		current_equipped[existing_index] = null

	# Ensure array is big enough
	while current_equipped.size() <= target_slot_index:
		current_equipped.append(null)

	# Place the new skill
	current_equipped[target_slot_index] = skill_to_equip

	# Clean up trailing nulls (optional)
	while not current_equipped.is_empty() and current_equipped.back() == null:
		current_equipped.pop_back()

	_cancel_selection() # Clear pending state and exit selection mode
	_update_equipped_slots() # Refresh display


func _cancel_selection():
	pending_selection = null
	current_selection_mode = SelectionMode.NONE
	skill_tree.set_highlight_mode(SelectionMode.NONE) # Tell tree to clear highlights
	_update_slot_highlights() # Clear slot highlights


func _update_slot_highlights():
	var slots = [equipped_slot_1, equipped_slot_2, equipped_slot_3]
	for i in range(slots.size()):
		var button = slots[i]
		match current_selection_mode:
			SelectionMode.NONE:
				button.modulate = Color.WHITE # Normal state
			SelectionMode.SELECTING_SKILL_FOR_SLOT:
				# Highlight the slot that is pending
				if pending_selection == i:
					button.modulate = Color.GOLD # Highlight pending slot
				else:
					button.modulate = Color.WHITE
			SelectionMode.SELECTING_SLOT_FOR_SKILL:
				if curr_party_member.skill_list.size() <= i or not curr_party_member.skill_list[i] :
					button.modulate = Color.GOLD # Highlight the slot with the pending skill
				else:
					button.modulate = Color.LIGHT_BLUE

### status_icon.gd ###
extends TextureRect
@onready var duration_label: Label = $duration_label # If you added a label
@onready var level_label: Label = $level_label # If you added a label


func set_data(icon_texture: Texture, duration: int = -1, level: int = -1) -> void:

	texture = icon_texture
	if duration > 0:
		duration_label.text = str(duration)
		duration_label.show()
	else:
		duration_label.text = ""
		duration_label.hide()
	
	if level > 0:
		level_label.text = str(level)
		level_label.show()
	else:
		level_label.text = ""
		level_label.hide()


### turn_order_portrait.gd ###
extends TextureRect # Or TextureRect if no background panel

@onready var portrait_image: TextureRect = $portrait_image
@onready var highlight: ColorRect = $highlight_indicator # Optional

func set_character(character: CombatCharacter, is_current_turn: bool):
	if not character: return
	portrait_image.texture = load(character.character.get_portrait_path())
	if highlight:
		highlight.visible = is_current_turn

func _ready():
	if highlight: highlight.visible = false


### audio_manager.gd ###
# AudioManager.gd
extends Node

var music_player: AudioStreamPlayer
var ui_sfx_player: AudioStreamPlayer


const MAIN_MENU_MUSIC = preload("res://audio/music/main_menu_music.wav")
const OVERWORLD_MUSIC = [
	preload("res://audio/music/overworld_music_1.wav"),
	preload("res://audio/music/overworld_music_2.wav"),
]
const BATTLE_MUSIC = [
	preload("res://audio/music/battle_music_1.wav"),
	preload("res://audio/music/battle_music_2.wav")
]
const ARENA_MUSIC = BATTLE_MUSIC
const VICTORY_STINGER = preload("res://audio/music/victory_music.wav")
const DEFEAT_STINGER = preload("res://audio/music/defeat_music.wav")

const UI_BUTTON_CLICK = preload("res://audio/sfx/ui/button_click.wav") 
const UI_SKILL_UNLOCK = preload("res://audio/sfx/ui/skill_unlock.wav") 
const UI_SCREEN_OPEN = preload("res://audio/sfx/ui/panel_open.wav") 
const UI_HOVERING = preload("res://audio/sfx/ui/hovering.wav")
const UI_CANCEL_ACTION = preload("res://audio/sfx/ui/cancel.wav")
const UI_ENTER_COMBAT = preload("res://audio/sfx/ui/enter_combat.wav")

var current_music: AudioStream = null

func _ready():
	# Create the music player node
	music_player = AudioStreamPlayer.new()
	music_player.name = "MusicPlayer"
	music_player.bus = "Music"
	add_child(music_player) 

	ui_sfx_player = AudioStreamPlayer.new()
	ui_sfx_player.name = "UISFXPlayer"
	ui_sfx_player.bus = "UI SFX"
	add_child(ui_sfx_player)

# Function to play music, optionally choosing randomly from a list
func play_music(music_resource: Variant, random_from_list: bool = false):
	var track_to_play: AudioStream = null

	if music_resource is Array and random_from_list:
		if not music_resource.is_empty():
			track_to_play = music_resource[randi() % music_resource.size()]
	elif music_resource is AudioStream:
		track_to_play = music_resource

	if track_to_play and track_to_play != current_music:
		music_player.stream = track_to_play
		music_player.play()
		current_music = track_to_play
	elif track_to_play == current_music and not music_player.playing:
		# Resume if same track was paused/stopped
		music_player.play()

func stop_music():
	music_player.stop()
	current_music = null # Clear current track

# Function for short one-off sounds like victory/defeat
func play_stinger(stinger_resource: AudioStream):
	if stinger_resource:
		stop_music()
		music_player.stream = stinger_resource
		music_player.play()

func play_sfx(sfx_resource: AudioStream):
	if sfx_resource and ui_sfx_player:
		ui_sfx_player.stream = sfx_resource
		ui_sfx_player.play()

func set_music_volume(volume_db: float):
	AudioServer.set_bus_volume_db(AudioServer.get_bus_index("Music"), volume_db)

func set_sfx_volume(volume_db: float):
	AudioServer.set_bus_volume_db(AudioServer.get_bus_index("SFX"), volume_db)

### enemy_data.gd ###
class_name EnemyData

static var ENEMY_CLASS_DEFINITIONS = {
	"Brute Marauder": {
        "class_enum": Character.CLASSES.Warrior,
		"base_hp": 40, "hp_per_level": 10,
		"base_damage_stat": 5, "damage_stat_per_level": 1,
		"skill_pool_config": [ 
			{"skill": Charge, "min_level": 2},
			{"skill": Frenzy, "min_level": 4},
			{"skill": WarCry, "min_level": 6}
		],
		"portraits": [0] # Indices or paths
	},
	"Arcane Channeler": {
        "class_enum": Character.CLASSES.Mage,
		"base_hp": 30, "hp_per_level": 5,
		"base_damage_stat": 5, "damage_stat_per_level": 1.5,
		"skill_pool_config": [
			{"skill": ArcaneShield, "min_level": 2},
			{"skill": Blink, "min_level": 4},
			{"skill": Thunderstrike, "min_level": 6}
		],
		"portraits": [2]
	},
    "Frost Guardian": {
        "class_enum": Character.CLASSES.Mage,
        "base_hp": 35, "hp_per_level": 5,
        "base_damage_stat": 7, "damage_stat_per_level": 1.5,
        "skill_pool_config": [
            {"skill": Frostbolt, "min_level": 2},
            {"skill": ArcaneSlash, "min_level": 4},
            {"skill": BoneArmor, "min_level": 6}
        ],
        "portraits": [10]
    },
    "Necromancer": {
        "class_enum": Character.CLASSES.Mage,
        "base_hp": 40, "hp_per_level": 10,
        "base_damage_stat": 5, "damage_stat_per_level": 1,
        "skill_pool_config": [
            {"skill": DarkPact, "min_level": 2},
            {"skill": Blink, "min_level": 4},
            {"skill": Decay, "min_level": 6}
        ],
        "portraits": [12]
    },
    "Raging Berserker": {
        "class_enum": Character.CLASSES.Warrior,
        "base_hp": 40, "hp_per_level": 10,
        "base_damage_stat": 5, "damage_stat_per_level": 1,
        "skill_pool_config": [
            {"skill": Frenzy, "min_level": 2},
            {"skill": RagingBlow, "min_level": 4},
            {"skill": BloodFury, "min_level": 6}
        ],
        "portraits": [11]
    },
    "Lich Warrior": {
        "class_enum": Character.CLASSES.Warrior,
        "base_hp": 35, "hp_per_level": 5,
        "base_damage_stat": 7, "damage_stat_per_level": 1.5,
        "skill_pool_config": [
            {"skill": ArcaneSlash, "min_level": 2},
            {"skill": BoneArmor, "min_level": 4},
            {"skill": DeathCoil, "min_level": 6}
        ],
        "portraits": [9]
    },
}

### event_manager.gd ###
class_name EventManager

var event_ui: EventUI
var fight_ui: FightUI
var game_state: GameState
var curr_fight: String

var curr_place = ""

func _init(_event_ui: EventUI, _fight_ui: FightUI, _game_state: GameState) :
	self.event_ui = _event_ui
	self.fight_ui = _fight_ui
	event_ui.resolve_event.connect(event_manager)
	self.game_state = _game_state

func event_manager(event_id: String) : 
	match event_id : 
		"leave" :
			leave_event()
			
		# GALL	
		"evt_tavern_find_potential_companion" :
			display_new_member()
		"recruit_member" :
			game_state.change_gold(-100)
			game_state.recruit_candidate()
			event_ui.show_event(curr_place, "evt_gall_tavern_interior")
		"opt_quest_accept_cauldron_easy" :
			game_state.accept_quest(1)
			event_ui.show_event(curr_place, "evt_guild_noticeboard")
		"opt_quest_accept_hollow_hard" :
			game_state.accept_quest(2)
			event_ui.show_event(curr_place, "evt_guild_noticeboard")
		"opt_turn_in_quest_cauldron" : 
			game_state.turn_quest(1)
			game_state.change_gold(150)
			game_state.receive_experience(1500)
			event_ui.show_event(curr_place, "evt_guild_clerk_interaction")
		"opt_turn_in_quest_hollow" : 
			game_state.turn_quest(2)
			game_state.change_gold(400)
			game_state.receive_experience(4000)
			event_ui.show_event(curr_place, "evt_guild_clerk_interaction")
			
			
		# Cauldron Moutains
		"fight_drake_ambush" : 
			enter_fight(EnemyGroup.new("Mountain Drakes", Character.CLASSES.Warrior, 1, 2, 2), event_id)
		"evt_cauldron_prospector_found" :
			game_state.accomplish_quest(1)
			event_ui.show_event(curr_place, event_id)
			
		# Whispering Hollow
		"hollow_fight_first_cultists" : 
			enter_fight(EnemyGroup.new("Cultists", Character.CLASSES.Mage, 2, 2, 3), event_id)
		"hollow_fight_leader_and_cultists" : 
			enter_fight(EnemyGroup.new("Cultist Leader", Character.CLASSES.Mage, 2, 7, 1), event_id)
		"hollow_fight_leader_and_cultists_victory" : 
			game_state.accomplish_quest(2)
			event_ui.show_event(curr_place, event_id)

		_ : 
			event_ui.show_event(curr_place, event_id)

func random_event_manager(_event_content: Dictionary) : 
	var party = game_state.party
	#TODO change party to whatever
	# event_ui.show_event("conversation", "conversation", party, true)
	# event_ui.visible = true
	# game_state.in_event = true


func enter_event(place_id: String) :
	self.curr_place = place_id

	event_ui.show_event(place_id, place_id)
	event_ui.visible = true
	game_state.in_event = true
	
func display_new_member() :
	var candidate: PartyMember = PartyMember.new_rand()
	game_state.new_candidate(candidate)
	var candidate_array: Array[PartyMember] = [candidate]
	event_ui.show_event(curr_place, "evt_tavern_find_potential_companion", candidate_array)
	
	
func leave_event() : 
	event_ui.visible = false
	game_state.in_event = false
	
func enter_fight(enemy_group: EnemyGroup, event_id: String) :
	fight_ui.visible = true
	fight_ui.update_ui(game_state.party, enemy_group)
	curr_fight = event_id
	event_ui.visible = false
	
func exit_fight(victory: bool) :
	fight_ui.visible = false
	var next_event = curr_fight + ("_victory" if victory else "_defeat")
	event_ui.visible = true
	event_manager(next_event)


### game_state.gd ###
extends Node
class_name GameState

var player_coords: Vector2
var party: Array[PartyMember]
var curr_candidate: PartyMember
const PARTY_MAX_NUMBER = 4

enum QUEST_STATE {Accepted, Accomplished, Turned}
var quest_log: Dictionary

var party_money : int
signal money_changed

var in_ui: bool = false
var in_event: bool = false

var steps_until_event: int = randi_range(12, 20)
signal random_event

func _ready():
	party.append(PartyMember.new_rand())
	
	
## PARTY LOGIC 
func recruit_candidate() :
	party.append(curr_candidate)
	curr_candidate = null
	
func new_candidate(candidate: PartyMember): 
	curr_candidate = candidate

func receive_experience(experience: int) : 
	for character in party : 
		character.receive_experience(round(experience * randf_range(0.9, 1.1)))
		
func fire_member(index: int) : 
	party.remove_at(index)	
	
## QUEST LOGIC
	
func accept_quest(quest_id: int):
	quest_log[quest_id] = QUEST_STATE.Accepted

func accomplish_quest(quest_id: int):
	quest_log[quest_id] = QUEST_STATE.Accomplished
	
func turn_quest(quest_id: int) :
	quest_log[quest_id] = QUEST_STATE.Turned
	
## MONEY LOGIC	
	
func change_gold(amount: int) : 
	party_money += amount
	money_changed.emit()
	
## CONDITION LOGIC

func conditions(expression: String) -> bool:
	expression.strip_edges()
	if expression.begins_with("not(") and expression.ends_with(")"):
		var inner_expression = expression.substr(4, expression.length() - 5)
		return not evaluate_expression(inner_expression)
	
	# If the expression is a single condition ID
	return evaluate_expression(expression)

	
func quest_check(condition_id: String, quest_condition: String) -> String :
	var regex = RegEx.new()
	regex.compile(r"quest_(.+)" + quest_condition)
	var regex_match = regex.search(condition_id)
	if regex_match : 
		return regex_match.get_string(1)
	return ""
		
func gold_check(condition_id: String) -> String : 
	var regex = RegEx.new()
	regex.compile(r"gold_(.+)")
	var regex_match = regex.search(condition_id)
	if regex_match : 
		return regex_match.get_string(1)
	return ""
		
func evaluate_expression(condition_id: String) -> bool:
	var quest_accepted_id = quest_check(condition_id, "_accepted")
	if quest_accepted_id != "" :
		return quest_log.has(int(quest_accepted_id)) && quest_log[int(quest_accepted_id)] == QUEST_STATE.Accepted
		
	var quest_accomplished_id = quest_check(condition_id, "_accomplished")
	if quest_accomplished_id != "" :
		return quest_log.has(int(quest_accomplished_id)) && quest_log[int(quest_accomplished_id)] == QUEST_STATE.Accomplished
	
	var quest_turned_id = quest_check(condition_id, "_turned")
	if quest_turned_id != "" :
		return quest_log.has(int(quest_turned_id)) && quest_log[int(quest_turned_id)] == QUEST_STATE.Turned
		
	var gold_amount = gold_check(condition_id)
	if gold_amount != "" : 
		return party_money >= int(gold_amount)
		
	match condition_id :
		"quest_accepted" :
			for quest in quest_log : 
				if quest_log[quest] == QUEST_STATE.Accepted : 
					return true
			return false
		"quest_accomplished" :
			for quest in quest_log : 
				if quest_log[quest] == QUEST_STATE.Accomplished : 
					return true
			return false
		"quest_turned" :
			for quest in quest_log : 
				if quest_log[quest] == QUEST_STATE.Turned : 
					return true
			return false
		"party_full" :
			return party.size() == PARTY_MAX_NUMBER

	push_error("unknown condition " + condition_id)
	return false


func step_taken() : 
	steps_until_event -= 1
	if steps_until_event == 0 : 
		steps_until_event = randi_range(12, 20)
		random_event.emit()


### hex_helper.gd ###
class_name HexHelper

# Conversions
static func cube_to_axial(cube: Vector3i) -> Vector2i:
    var q = cube.x
    var r = cube.y
    return Vector2i(q, r)

static func axial_to_cube(hex: Vector2i) -> Vector3i:
    var q = hex.x
    var r = hex.y
    var s = -q-r
    return Vector3i(q, r, s)

static func axial_to_oddr(hex: Vector2i) -> Vector2i:
    var col = round(hex.x + (hex.y - (hex.y&1)) / 2.0)
    var row = hex.y
    return Vector2i(col, row)

static func oddr_to_axial(hex: Vector2i) -> Vector2i:
    var q = round(hex.x - (hex.y - (hex.y&1)) / 2.0)
    var r = hex.y
    return Vector2i(q, r)


## Neighbors

## Cube coordinates
static var cube_direction_vectors = [
    Vector3i(+1, 0, -1), Vector3i(+1, -1, 0), Vector3i(0, -1, +1), 
    Vector3i(-1, 0, +1), Vector3i(-1, +1, 0), Vector3i(0, +1, -1), 
]

static func cube_direction(direction: int) -> Vector3i:
    return cube_direction_vectors[direction]

static func cube_add(hex: Vector3i, vec: Vector3i) -> Vector3i:
    return Vector3i(hex.x + vec.x, hex.y + vec.y, hex.z + vec.z)

static func cube_neighbor(cube: Vector3i, direction: int) -> Vector3i:
    return cube_add(cube, cube_direction(direction))

## Axial coordinates
static var axial_direction_vectors = [
    Vector2i(+1, 0), Vector2i(+1, -1), Vector2i(0, -1), 
    Vector2i(-1, 0), Vector2i(-1, +1), Vector2i(0, +1), 
]

static func axial_direction(direction: int) -> Vector2i:
    return axial_direction_vectors[direction]

static func axial_add(hex: Vector2i, vec: Vector2i) -> Vector2i:
    return Vector2i(hex.x + vec.x, hex.y + vec.y)

static func axial_neighbor(hex: Vector2i, direction: int) -> Vector2i:
    return axial_add(hex, axial_direction(direction))

## Offset coordinates

static var oddr_direction_differences = [
    # even rows 
    [[+1,  0], [ 0, -1], [-1, -1], 
     [-1,  0], [-1, +1], [ 0, +1]],
    # odd rows 
    [[+1,  0], [+1, -1], [ 0, -1], 
     [-1,  0], [ 0, +1], [+1, +1]],
]

static func hex_neighbor(hex: Vector2i, direction: int) -> Vector2i:
    var parity = hex.y & 1
    var diff = oddr_direction_differences[parity][direction]
    return Vector2i(hex.x + diff[0], hex.y + diff[1])

# Distances

## Cube coordinates

static func cube_subtract(a: Vector3i, b: Vector3i) -> Vector3i:
    return Vector3i(a.x - b.x, a.y - b.y, a.z - b.z)

static func cube_distance(a: Vector3i, b: Vector3i) -> int:
    var vec = cube_subtract(a, b)
    return max(abs(vec.x),  abs(vec.y), abs(vec.z))

## Axial coordinates

static func axial_subtract(a: Vector2i, b: Vector2i) -> Vector2i:
    return Vector2i(a.x - b.x, a.y - b.y)

static func axial_distance(a: Vector2i, b: Vector2i) -> int:
    var ac = axial_to_cube(a)
    var bc = axial_to_cube(b)
    return cube_distance(ac, bc)

## Offset coordinates

static func distance(a: Vector2i, b: Vector2i) -> int:
    var ac = oddr_to_axial(a)
    var bc = oddr_to_axial(b)
    return axial_distance(ac, bc)

# Line drawing

static func lerp(a: float, b: float, t: float) -> float:
    return a + (b - a) * t

static func cube_lerp(a: Vector3i, b: Vector3i, t: float) -> Vector3:
    return Vector3(lerp(a.x, b.x, t),
                lerp(a.y, b.y, t),
                lerp(a.z, b.z, t))

static func cube_linedraw(a: Vector3i, b: Vector3i) -> Array[Vector3i]:
    var N = cube_distance(a, b)
    var results: Array[Vector3i] = []
    for i in range(N+1):
        results.append(cube_round(cube_lerp(a, b, 1.0/N * i)))
    return results

static func axial_linedraw(a: Vector2i, b: Vector2i) -> Array[Vector2i]:
    var results: Array[Vector2i] = []
    for hex in cube_linedraw(axial_to_cube(a), axial_to_cube(b)):
        results.append(cube_to_axial(hex))
    return results

static func oddr_linedraw(a: Vector2i, b: Vector2i) -> Array[Vector2i]:
    var results: Array[Vector2i] = []
    for hex in axial_linedraw(oddr_to_axial(a), oddr_to_axial(b)):
        results.append(axial_to_oddr(hex))
    return results

# Range

static func cube_range(center: Vector3i, radius: int) -> Array[Vector3i]:
    var results: Array[Vector3i] = []
    for dx in range(-radius, radius+1):
        for dy in range(max(-radius, -dx-radius), min(radius, -dx+radius)+1):
            var dz = -dx-dy
            results.append(Vector3i(center.x + dx, center.y + dy, center.z + dz))
    return results

static func axial_range(center: Vector2i, radius: int) -> Array[Vector2i]:
    var results: Array[Vector2i] = []
    for dx in range(-radius, radius+1):
        for dy in range(max(-radius, -dx-radius), min(radius, -dx+radius)+1):
            results.append(Vector2i(center.x + dx, center.y + dy))
    return results

static func range(center: Vector2i, radius: int) -> Array[Vector2i]:
    var results: Array[Vector2i] = []
    for hex in axial_range(oddr_to_axial(center), radius):
        results.append(axial_to_oddr(hex))
    return results

static func cube_range_intersection(a: Vector3i, b: Vector3i, radius: int) -> Array[Vector2i]:
    var results = []
    var xmin = max(a.x - radius, b.x - radius)
    var xmax = min(a.x + radius, b.x + radius)
    var ymin = max(a.y - radius, b.y - radius)
    var ymax = min(a.y + radius, b.y + radius)
    var zmin = max(a.z - radius, b.z - radius)
    var zmax = min(a.z + radius, b.z + radius)

    for dx in range(xmin, xmax+1):
        for dy in range(max(ymin, -dx-zmax), min(ymax, -dx-zmin)+1):
            results.append(Vector2i(dx, dy))

    return results


static func axial_range_intersection(a: Vector2i, b: Vector2i, radius: int) -> Array[Vector2i]:
    return cube_range_intersection(axial_to_cube(a), axial_to_cube(b), radius)

static func range_intersection(a: Vector2i, b: Vector2i, radius: int) -> Array[Vector2i]:
    var results = []
    for hex in axial_range_intersection(oddr_to_axial(a), oddr_to_axial(b), radius):
        results.append(axial_to_oddr(hex))
    return results

static func hex_reachable(start: Vector2i, movement: int, can_move_to: Callable) -> Array[Vector2i]:
    var visited = {} # set of hexes
    visited[start] = null
    var fringes = [] # array of arrays of hexes
    fringes.append([start])

    for k in range(1, movement+1):
        fringes.append([])
        for hex in fringes[k-1]:
            for dir in range(6):
                var neighbor = hex_neighbor(hex, dir)
                if neighbor not in visited and can_move_to.call(neighbor):
                    visited[neighbor] = null
                    fringes[k].append(neighbor)

    var reachables : Array[Vector2i] = []
    for hex in visited.keys():
        reachables.append(hex)
    return reachables

# Rotation

static func rotate_left(hex: Vector2i, center: Vector2i) -> Vector2i:
    var hex_cube = axial_to_cube(oddr_to_axial(hex))
    var center_cube = axial_to_cube(oddr_to_axial(center))
    var vec = cube_subtract(hex_cube, center_cube)
    var rotated = Vector3i(-vec.y, -vec.z, -vec.x)
    return axial_to_oddr(cube_to_axial(cube_add(rotated, center_cube)))

static func rotate_right(hex: Vector2i, center: Vector2i) -> Vector2i:
    var hex_cube = axial_to_cube(oddr_to_axial(hex))
    var center_cube = axial_to_cube(oddr_to_axial(center))
    var vec = cube_subtract(hex_cube, center_cube)
    var rotated = Vector3i(-vec.z, -vec.x, -vec.y)
    return axial_to_oddr(cube_to_axial(cube_add(rotated, center_cube)))

# Rings and Spirals

static func cube_scale(hex: Vector3i, factor: int) -> Vector3i:
    return Vector3i(hex.x * factor, hex.y * factor, hex.z * factor)

static func cube_ring(center: Vector3i, radius: int) -> Array[Vector3i]:
    var results: Array[Vector3i] = []
    var hex = cube_add(center,
                        cube_scale(cube_direction(4), radius))
    for i in range(0, 6):
        for j in range(0, radius):
            results.append(hex)
            hex = cube_neighbor(hex, i)
    return results

static func cube_spiral(center: Vector3i, radius: int) -> Array[Vector3i]:
    var results: Array[Vector3i] = [center]
    for k in range(1, radius+1):
        results += cube_ring(center, k)
    return results

static func axial_ring(center: Vector2i, radius: int) -> Array[Vector2i]:
    var results: Array[Vector2i] = []
    for hex in cube_ring(axial_to_cube(center), radius):
        results.append(cube_to_axial(hex))
    return results

static func axial_spiral(center: Vector2i, radius: int) -> Array[Vector2i]:
    var results: Array[Vector2i] = [center]
    for k in range(1, radius+1):
        results += axial_ring(center, k)
    return results

static func ring(center: Vector2i, radius: int) -> Array[Vector2i]:
    var results: Array[Vector2i] = []
    for hex in axial_ring(oddr_to_axial(center), radius):
        results.append(axial_to_oddr(hex))
    return results

static func spiral(center: Vector2i, radius: int) -> Array[Vector2i]:
    var results: Array[Vector2i] = [center]
    for k in range(1, radius+1):
        results += ring(center, k)
    return results

# Columns

static func cube_column(start: Vector3i, direction: int, length: int) -> Array[Vector3i]:
    var results: Array[Vector3i] = []
    for i in range(0, length):
        results.append(start)
        start = cube_neighbor(start, direction)
    return results

static func axial_column(start: Vector2i, direction: int, length: int) -> Array[Vector2i]:
    var results: Array[Vector2i] = []
    for hex in cube_column(axial_to_cube(start), direction, length):
        results.append(cube_to_axial(hex))
    return results

static func column(start: Vector2i, direction: int, length: int) -> Array[Vector2i]:
    var results: Array[Vector2i] = []
    for hex in axial_column(oddr_to_axial(start), direction, length):
        results.append(axial_to_oddr(hex))
    return results


# Field of view


static func fov(center: Vector2i, target: Vector2i, can_view: Callable) -> Array[Vector2i]:
    var results: Array[Vector2i] = []
    for hex in oddr_linedraw(center, target):
        if not can_view.call(hex):
            break
        results.append(hex)
    return results

# Rounding

static func cube_round(frac: Vector3) -> Vector3i:
    var q = round(frac.x)
    var r = round(frac.y)
    var s = round(frac.z)

    var q_diff = abs(q - frac.x)
    var r_diff = abs(r - frac.y)
    var s_diff = abs(s - frac.z)

    if q_diff > r_diff and q_diff > s_diff:
        q = -r-s
    elif r_diff > s_diff:
        r = -q-s
    else:
        s = -q-r

    return Vector3i(q, r, s)


### quest_manager.gd ###
class_name QuestManager


